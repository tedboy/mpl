

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mpl.axes._axes</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="" href="../../../index.html"/>
        <link rel="up" title="mpl" href="../../mpl.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> My Project
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Autogenerated API</span></p>
<ul class="simple">
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/mpl.html"><code class="docutils literal"><span class="pre">mpl</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/mpl.pyplot.html"><code class="docutils literal"><span class="pre">mpl.pyplot</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/mpl.axes.html"><code class="docutils literal"><span class="pre">mpl.axes</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/mpl.axis.html"><code class="docutils literal"><span class="pre">mpl.axis</span></code></a></li>
</ul>
<p class="caption"><span class="caption-text">Autogenerated API - More</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../others.html">Other modules</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../infreq.html">Infreqeuntly used</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">My Project</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../mpl.html">mpl</a> &raquo;</li>
        
      <li>mpl.axes._axes</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mpl.axes._axes</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">matplotlib.externals</span> <span class="kn">import</span> <span class="n">six</span>
<span class="kn">from</span> <span class="nn">matplotlib.externals.six.moves</span> <span class="kn">import</span> <span class="nb">reduce</span><span class="p">,</span> <span class="nb">xrange</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="n">zip_longest</span>

<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>

<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">unpack_labeled_data</span>

<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="kn">as</span> <span class="nn">cbook</span>
<span class="kn">from</span> <span class="nn">matplotlib.cbook</span> <span class="kn">import</span> <span class="p">(</span><span class="n">mplDeprecation</span><span class="p">,</span> <span class="n">STEP_LOOKUP_MAP</span><span class="p">,</span>
                              <span class="n">iterable</span><span class="p">,</span> <span class="n">is_string_like</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.collections</span> <span class="kn">as</span> <span class="nn">mcoll</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="kn">as</span> <span class="nn">mcolors</span>
<span class="kn">import</span> <span class="nn">matplotlib.contour</span> <span class="kn">as</span> <span class="nn">mcontour</span>
<span class="kn">import</span> <span class="nn">matplotlib.dates</span> <span class="kn">as</span> <span class="nn">_</span>  <span class="c1"># &lt;-registers a date unit converter</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">docstring</span>
<span class="kn">import</span> <span class="nn">matplotlib.image</span> <span class="kn">as</span> <span class="nn">mimage</span>
<span class="kn">import</span> <span class="nn">matplotlib.legend</span> <span class="kn">as</span> <span class="nn">mlegend</span>
<span class="kn">import</span> <span class="nn">matplotlib.lines</span> <span class="kn">as</span> <span class="nn">mlines</span>
<span class="kn">import</span> <span class="nn">matplotlib.markers</span> <span class="kn">as</span> <span class="nn">mmarkers</span>
<span class="kn">import</span> <span class="nn">matplotlib.mlab</span> <span class="kn">as</span> <span class="nn">mlab</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="kn">as</span> <span class="nn">mpath</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="kn">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.quiver</span> <span class="kn">as</span> <span class="nn">mquiver</span>
<span class="kn">import</span> <span class="nn">matplotlib.stackplot</span> <span class="kn">as</span> <span class="nn">mstack</span>
<span class="kn">import</span> <span class="nn">matplotlib.streamplot</span> <span class="kn">as</span> <span class="nn">mstream</span>
<span class="kn">import</span> <span class="nn">matplotlib.table</span> <span class="kn">as</span> <span class="nn">mtable</span>
<span class="kn">import</span> <span class="nn">matplotlib.text</span> <span class="kn">as</span> <span class="nn">mtext</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="kn">as</span> <span class="nn">mticker</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="kn">as</span> <span class="nn">mtransforms</span>
<span class="kn">import</span> <span class="nn">matplotlib.tri</span> <span class="kn">as</span> <span class="nn">mtri</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="kn">as</span> <span class="nn">mtrans</span>
<span class="kn">from</span> <span class="nn">matplotlib.container</span> <span class="kn">import</span> <span class="n">BarContainer</span><span class="p">,</span> <span class="n">ErrorbarContainer</span><span class="p">,</span> <span class="n">StemContainer</span>
<span class="kn">from</span> <span class="nn">matplotlib.axes._base</span> <span class="kn">import</span> <span class="n">_AxesBase</span>
<span class="kn">from</span> <span class="nn">matplotlib.axes._base</span> <span class="kn">import</span> <span class="n">_process_plot_format</span>


<span class="n">rcParams</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">rcParams</span>


<span class="k">def</span> <span class="nf">_plot_args_replacer</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># this can be two cases: x,y or y,c</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="c1"># this is not in data, so just assume that it is something which</span>
            <span class="c1"># will not get replaced (color spec or array like).</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]</span>
        <span class="c1"># it&#39;s data, but could be a color code like &#39;ro&#39; or &#39;b--&#39;</span>
        <span class="c1"># -&gt; warn the user in that case...</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Second argument is ambiguous: could be a color spec &quot;</span> \
                  <span class="s2">&quot;but is in data. Using as data.</span><span class="se">\n</span><span class="s2">Either rename the &quot;</span> \
                  <span class="s2">&quot;entry in data or use three arguments to plot.&quot;</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Using arbitrary long args with data is not &quot;</span>
                         <span class="s2">&quot;supported due to ambiguity of arguments.</span><span class="se">\n</span><span class="s2">Use &quot;</span>
                         <span class="s2">&quot;multiple plotting calls instead.&quot;</span><span class="p">)</span>


<span class="c1"># The axes module contains all the wrappers to plotting functions.</span>
<span class="c1"># All the other methods should go in the _AxesBase class.</span>


<div class="viewcode-block" id="Axes"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.html#mpl.axes.Axes">[docs]</a><span class="k">class</span> <span class="nc">Axes</span><span class="p">(</span><span class="n">_AxesBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`Axes` contains most of the figure elements:</span>
<span class="sd">    :class:`~matplotlib.axis.Axis`, :class:`~matplotlib.axis.Tick`,</span>
<span class="sd">    :class:`~matplotlib.lines.Line2D`, :class:`~matplotlib.text.Text`,</span>
<span class="sd">    :class:`~matplotlib.patches.Polygon`, etc., and sets the</span>
<span class="sd">    coordinate system.</span>

<span class="sd">    The :class:`Axes` instance supports callbacks through a callbacks</span>
<span class="sd">    attribute which is a :class:`~matplotlib.cbook.CallbackRegistry`</span>
<span class="sd">    instance.  The events you can connect to are &#39;xlim_changed&#39; and</span>
<span class="sd">    &#39;ylim_changed&#39; and the callback will be called with func(*ax*)</span>
<span class="sd">    where *ax* is the :class:`Axes` instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">### Labelling, legend and texts</span>

<div class="viewcode-block" id="Axes.get_title"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.get_title.html#mpl.axes.Axes.get_title">[docs]</a>    <span class="k">def</span> <span class="nf">get_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get an axes title.</span>

<span class="sd">        Get one of the three available axes titles. The available titles</span>
<span class="sd">        are positioned above the axes in the center, flush with the left</span>
<span class="sd">        edge, and flush with the right edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : {&#39;center&#39;, &#39;left&#39;, &#39;right&#39;}, str, optional</span>
<span class="sd">            Which title to get, defaults to &#39;center&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        title: str</span>
<span class="sd">            The title text string.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_title</span><span class="p">,</span>
                     <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
                     <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_title</span><span class="p">}[</span><span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid location&quot;</span> <span class="o">%</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">title</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span></div>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.set_title"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.set_title.html#mpl.axes.Axes.set_title">[docs]</a>    <span class="k">def</span> <span class="nf">set_title</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="s2">&quot;center&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a title for the axes.</span>

<span class="sd">        Set one of the three available axes titles. The available titles</span>
<span class="sd">        are positioned above the axes in the center, flush with the left</span>
<span class="sd">        edge, and flush with the right edge.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        label : str</span>
<span class="sd">            Text to use for the title</span>

<span class="sd">        fontdict : dict</span>
<span class="sd">            A dictionary controlling the appearance of the title text,</span>
<span class="sd">            the default `fontdict` is::</span>

<span class="sd">               {&#39;fontsize&#39;: rcParams[&#39;axes.titlesize&#39;],</span>
<span class="sd">                &#39;fontweight&#39; : rcParams[&#39;axes.titleweight&#39;],</span>
<span class="sd">                &#39;verticalalignment&#39;: &#39;baseline&#39;,</span>
<span class="sd">                &#39;horizontalalignment&#39;: loc}</span>

<span class="sd">        loc : {&#39;center&#39;, &#39;left&#39;, &#39;right&#39;}, str, optional</span>
<span class="sd">            Which title to set, defaults to &#39;center&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        text : :class:`~matplotlib.text.Text`</span>
<span class="sd">            The matplotlib text instance representing the title</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs : text properties</span>
<span class="sd">            Other keyword arguments are text properties, see</span>
<span class="sd">            :class:`~matplotlib.text.Text` for a list of valid text</span>
<span class="sd">            properties.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_left_title</span><span class="p">,</span>
                     <span class="s1">&#39;center&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="p">,</span>
                     <span class="s1">&#39;right&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_right_title</span><span class="p">}[</span><span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39; is not a valid location&quot;</span> <span class="o">%</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">default</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;fontsize&#39;</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titlesize&#39;</span><span class="p">],</span>
            <span class="s1">&#39;fontweight&#39;</span><span class="p">:</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.titleweight&#39;</span><span class="p">],</span>
            <span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;baseline&#39;</span><span class="p">,</span>
            <span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="n">loc</span><span class="o">.</span><span class="n">lower</span><span class="p">()}</span>
        <span class="n">title</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fontdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fontdict</span><span class="p">)</span>
        <span class="n">title</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">title</span></div>

<div class="viewcode-block" id="Axes.get_xlabel"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.get_xlabel.html#mpl.axes.Axes.get_xlabel">[docs]</a>    <span class="k">def</span> <span class="nf">get_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the xlabel text string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">label</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span></div>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.set_xlabel"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.set_xlabel.html#mpl.axes.Axes.set_xlabel">[docs]</a>    <span class="k">def</span> <span class="nf">set_xlabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xlabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the label for the xaxis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xlabel : string</span>
<span class="sd">            x label</span>

<span class="sd">        labelpad : scalar, optional, default: None</span>
<span class="sd">            spacing in points between the label and the x-axis</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs : `~matplotlib.text.Text` properties</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        text : for information on how override and the optional args work</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labelpad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="n">labelpad</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_label_text</span><span class="p">(</span><span class="n">xlabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.get_ylabel"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.get_ylabel.html#mpl.axes.Axes.get_ylabel">[docs]</a>    <span class="k">def</span> <span class="nf">get_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the ylabel text string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">label</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span></div>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.set_ylabel"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.set_ylabel.html#mpl.axes.Axes.set_ylabel">[docs]</a>    <span class="k">def</span> <span class="nf">set_ylabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ylabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labelpad</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the label for the yaxis</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ylabel : string</span>
<span class="sd">            y label</span>

<span class="sd">        labelpad : scalar, optional, default: None</span>
<span class="sd">            spacing in points between the label and the x-axis</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs : `~matplotlib.text.Text` properties</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        text : for information on how override and the optional args work</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">labelpad</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">labelpad</span> <span class="o">=</span> <span class="n">labelpad</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_label_text</span><span class="p">(</span><span class="n">ylabel</span><span class="p">,</span> <span class="n">fontdict</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_legend_handles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">legend_handler_map</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a generator of artists that can be used as handles in</span>
<span class="sd">        a legend.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">handles_original</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">patches</span> <span class="o">+</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">containers</span><span class="p">)</span>
        <span class="n">handler_map</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">Legend</span><span class="o">.</span><span class="n">get_default_handler_map</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">legend_handler_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">handler_map</span> <span class="o">=</span> <span class="n">handler_map</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">handler_map</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">legend_handler_map</span><span class="p">)</span>

        <span class="n">has_handler</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">Legend</span><span class="o">.</span><span class="n">get_legend_handler</span>

        <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">handles_original</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">handle</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">label</span> <span class="o">!=</span> <span class="s1">&#39;_nolegend_&#39;</span> <span class="ow">and</span> <span class="n">has_handler</span><span class="p">(</span><span class="n">handler_map</span><span class="p">,</span> <span class="n">handle</span><span class="p">):</span>
                <span class="k">yield</span> <span class="n">handle</span>

<div class="viewcode-block" id="Axes.get_legend_handles_labels"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.get_legend_handles_labels.html#mpl.axes.Axes.get_legend_handles_labels">[docs]</a>    <span class="k">def</span> <span class="nf">get_legend_handles_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">legend_handler_map</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return handles and labels for legend</span>

<span class="sd">        ``ax.legend()`` is equivalent to ::</span>

<span class="sd">          h, l = ax.get_legend_handles_labels()</span>
<span class="sd">          ax.legend(h, l)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">handles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_legend_handles</span><span class="p">(</span><span class="n">legend_handler_map</span><span class="p">):</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">handle</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
                <span class="n">handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span></div>

<div class="viewcode-block" id="Axes.legend"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.legend.html#mpl.axes.Axes.legend">[docs]</a>    <span class="k">def</span> <span class="nf">legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Places a legend on the axes.</span>

<span class="sd">        To make a legend for lines which already exist on the axes</span>
<span class="sd">        (via plot for instance), simply call this function with an iterable</span>
<span class="sd">        of strings, one for each legend item. For example::</span>

<span class="sd">            ax.plot([1, 2, 3])</span>
<span class="sd">            ax.legend([&#39;A simple line&#39;])</span>

<span class="sd">        However, in order to keep the &quot;label&quot; and the legend element</span>
<span class="sd">        instance together, it is preferable to specify the label either at</span>
<span class="sd">        artist creation, or by calling the</span>
<span class="sd">        :meth:`~matplotlib.artist.Artist.set_label` method on the artist::</span>

<span class="sd">            line, = ax.plot([1, 2, 3], label=&#39;Inline label&#39;)</span>
<span class="sd">            # Overwrite the label by calling the method.</span>
<span class="sd">            line.set_label(&#39;Label via method&#39;)</span>
<span class="sd">            ax.legend()</span>

<span class="sd">        Specific lines can be excluded from the automatic legend element</span>
<span class="sd">        selection by defining a label starting with an underscore.</span>
<span class="sd">        This is default for all artists, so calling :meth:`legend` without</span>
<span class="sd">        any arguments and without setting the labels manually will result in</span>
<span class="sd">        no legend being drawn.</span>

<span class="sd">        For full control of which artists have a legend entry, it is possible</span>
<span class="sd">        to pass an iterable of legend artists followed by an iterable of</span>
<span class="sd">        legend labels respectively::</span>

<span class="sd">           legend((line1, line2, line3), (&#39;label1&#39;, &#39;label2&#39;, &#39;label3&#39;))</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        loc : int or string or pair of floats, default: &#39;upper right&#39;</span>
<span class="sd">            The location of the legend. Possible codes are:</span>

<span class="sd">                ===============   =============</span>
<span class="sd">                Location String   Location Code</span>
<span class="sd">                ===============   =============</span>
<span class="sd">                &#39;best&#39;            0</span>
<span class="sd">                &#39;upper right&#39;     1</span>
<span class="sd">                &#39;upper left&#39;      2</span>
<span class="sd">                &#39;lower left&#39;      3</span>
<span class="sd">                &#39;lower right&#39;     4</span>
<span class="sd">                &#39;right&#39;           5</span>
<span class="sd">                &#39;center left&#39;     6</span>
<span class="sd">                &#39;center right&#39;    7</span>
<span class="sd">                &#39;lower center&#39;    8</span>
<span class="sd">                &#39;upper center&#39;    9</span>
<span class="sd">                &#39;center&#39;          10</span>
<span class="sd">                ===============   =============</span>


<span class="sd">            Alternatively can be a 2-tuple giving ``x, y`` of the lower-left</span>
<span class="sd">            corner of the legend in axes coordinates (in which case</span>
<span class="sd">            ``bbox_to_anchor`` will be ignored).</span>

<span class="sd">        bbox_to_anchor : :class:`matplotlib.transforms.BboxBase` instance \</span>
<span class="sd">                         or tuple of floats</span>
<span class="sd">            Specify any arbitrary location for the legend in `bbox_transform`</span>
<span class="sd">            coordinates (default Axes coordinates).</span>

<span class="sd">            For example, to put the legend&#39;s upper right hand corner in the</span>
<span class="sd">            center of the axes the following keywords can be used::</span>

<span class="sd">               loc=&#39;upper right&#39;, bbox_to_anchor=(0.5, 0.5)</span>

<span class="sd">        ncol : integer</span>
<span class="sd">            The number of columns that the legend has. Default is 1.</span>

<span class="sd">        prop : None or :class:`matplotlib.font_manager.FontProperties` or dict</span>
<span class="sd">            The font properties of the legend. If None (default), the current</span>
<span class="sd">            :data:`matplotlib.rcParams` will be used.</span>

<span class="sd">        fontsize : int or float or {&#39;xx-small&#39;, &#39;x-small&#39;, &#39;small&#39;, &#39;medium&#39;,\</span>
<span class="sd">                   &#39;large&#39;, &#39;x-large&#39;, &#39;xx-large&#39;}</span>
<span class="sd">            Controls the font size of the legend. If the value is numeric the</span>
<span class="sd">            size will be the absolute font size in points. String values are</span>
<span class="sd">            relative to the current default font size. This argument is only</span>
<span class="sd">            used if `prop` is not specified.</span>

<span class="sd">        numpoints : None or int</span>
<span class="sd">            The number of marker points in the legend when creating a legend</span>
<span class="sd">            entry for a line/:class:`matplotlib.lines.Line2D`.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.numpoints`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        scatterpoints : None or int</span>
<span class="sd">            The number of marker points in the legend when creating a legend</span>
<span class="sd">            entry for a scatter plot/</span>
<span class="sd">            :class:`matplotlib.collections.PathCollection`.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.scatterpoints`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        scatteryoffsets : iterable of floats</span>
<span class="sd">            The vertical offset (relative to the font size) for the markers</span>
<span class="sd">            created for a scatter plot legend entry. 0.0 is at the base the</span>
<span class="sd">            legend text, and 1.0 is at the top. To draw all markers at the</span>
<span class="sd">            same height, set to ``[0.5]``. Default ``[0.375, 0.5, 0.3125]``.</span>

<span class="sd">        markerscale : None or int or float</span>
<span class="sd">            The relative size of legend markers compared with the originally</span>
<span class="sd">            drawn ones. Default is ``None`` which will take the value from</span>
<span class="sd">            the ``legend.markerscale`` :data:`rcParam &lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        *markerfirst*: [ *True* | *False* ]</span>
<span class="sd">            if *True*, legend marker is placed to the left of the legend label</span>
<span class="sd">            if *False*, legend marker is placed to the right of the legend</span>
<span class="sd">            label</span>

<span class="sd">        frameon : None or bool</span>
<span class="sd">            Control whether a frame should be drawn around the legend.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.frameon`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        fancybox : None or bool</span>
<span class="sd">            Control whether round edges should be enabled around</span>
<span class="sd">            the :class:`~matplotlib.patches.FancyBboxPatch` which</span>
<span class="sd">            makes up the legend&#39;s background.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.fancybox`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        shadow : None or bool</span>
<span class="sd">            Control whether to draw a shadow behind the legend.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.shadow`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        framealpha : None or float</span>
<span class="sd">            Control the alpha transparency of the legend&#39;s frame.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.framealpha`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        mode : {&quot;expand&quot;, None}</span>
<span class="sd">            If `mode` is set to ``&quot;expand&quot;`` the legend will be horizontally</span>
<span class="sd">            expanded to fill the axes area (or `bbox_to_anchor` if defines</span>
<span class="sd">            the legend&#39;s size).</span>

<span class="sd">        bbox_transform : None or :class:`matplotlib.transforms.Transform`</span>
<span class="sd">            The transform for the bounding box (`bbox_to_anchor`). For a value</span>
<span class="sd">            of ``None`` (default) the Axes&#39;</span>
<span class="sd">            :data:`~matplotlib.axes.Axes.transAxes` transform will be used.</span>

<span class="sd">        title : str or None</span>
<span class="sd">            The legend&#39;s title. Default is no title (``None``).</span>

<span class="sd">        borderpad : float or None</span>
<span class="sd">            The fractional whitespace inside the legend border.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.borderpad`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        labelspacing : float or None</span>
<span class="sd">            The vertical space between the legend entries.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.labelspacing`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        handlelength : float or None</span>
<span class="sd">            The length of the legend handles.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.handlelength`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        handletextpad : float or None</span>
<span class="sd">            The pad between the legend handle and text.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.handletextpad`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        borderaxespad : float or None</span>
<span class="sd">            The pad between the axes and legend border.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.borderaxespad`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        columnspacing : float or None</span>
<span class="sd">            The spacing between columns.</span>
<span class="sd">            Measured in font-size units.</span>
<span class="sd">            Default is ``None`` which will take the value from the</span>
<span class="sd">            ``legend.columnspacing`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        handler_map : dict or None</span>
<span class="sd">            The custom dictionary mapping instances or types to a legend</span>
<span class="sd">            handler. This `handler_map` updates the default handler map</span>
<span class="sd">            found at :func:`matplotlib.legend.Legend.get_legend_handler_map`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Not all kinds of artist are supported by the legend command.</span>
<span class="sd">        See :ref:`plotting-guide-legend` for details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: mpl_examples/api/legend_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">handlers</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;handler_map&#39;</span><span class="p">,</span> <span class="p">{})</span> <span class="ow">or</span> <span class="p">{}</span>

        <span class="c1"># Support handles and labels being passed as keywords.</span>
        <span class="n">handles</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;handles&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">handles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;You have mixed positional and keyword &quot;</span>
                          <span class="s2">&quot;arguments, some input will be &quot;</span>
                          <span class="s2">&quot;discarded.&quot;</span><span class="p">)</span>

        <span class="c1"># if got both handles and labels as kwargs, make same length</span>
        <span class="k">if</span> <span class="n">handles</span> <span class="ow">and</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">zip</span><span class="p">(</span><span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">))</span>

        <span class="k">elif</span> <span class="n">handles</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">handle</span><span class="o">.</span><span class="n">get_label</span><span class="p">()</span> <span class="k">for</span> <span class="n">handle</span> <span class="ow">in</span> <span class="n">handles</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">handle</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">labels</span><span class="p">[:],</span> <span class="n">handles</span><span class="p">[:]):</span>
                <span class="k">if</span> <span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">):</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;The handle {!r} has a label of {!r} which &#39;</span>
                                  <span class="s1">&#39;cannot be automatically added to the &#39;</span>
                                  <span class="s1">&#39;legend.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">label</span><span class="p">))</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                    <span class="n">handles</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">handle</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">handles</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Get as many handles as there are labels.</span>
            <span class="n">handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">handle</span> <span class="k">for</span> <span class="n">handle</span><span class="p">,</span> <span class="n">label</span>
                       <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_legend_handles</span><span class="p">(</span><span class="n">handlers</span><span class="p">),</span> <span class="n">labels</span><span class="p">)]</span>

        <span class="c1"># No arguments - automatically detect labels and handles.</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_legend_handles_labels</span><span class="p">(</span><span class="n">handlers</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">handles</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No labelled objects found. &quot;</span>
                              <span class="s2">&quot;Use label=&#39;...&#39; kwarg on individual plots.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">None</span>

        <span class="c1"># One argument. User defined labels - automatic handle detection.</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">labels</span><span class="p">,</span> <span class="o">=</span> <span class="n">args</span>
            <span class="c1"># Get as many handles as there are labels.</span>
            <span class="n">handles</span> <span class="o">=</span> <span class="p">[</span><span class="n">handle</span> <span class="k">for</span> <span class="n">handle</span><span class="p">,</span> <span class="n">label</span>
                       <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_legend_handles</span><span class="p">(</span><span class="n">handlers</span><span class="p">),</span> <span class="n">labels</span><span class="p">)]</span>

        <span class="c1"># Two arguments:</span>
        <span class="c1">#   * user defined handles and labels</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span> <span class="o">=</span> <span class="n">args</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Invalid arguments to legend.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span> <span class="o">=</span> <span class="n">mlegend</span><span class="o">.</span><span class="n">Legend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">handles</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span><span class="o">.</span><span class="n">_remove_method</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">h</span><span class="p">:</span> <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;legend_&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">legend_</span></div>

<div class="viewcode-block" id="Axes.text"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.text.html#mpl.axes.Axes.text">[docs]</a>    <span class="k">def</span> <span class="nf">text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">fontdict</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">withdash</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add text to the axes.</span>

<span class="sd">        Add text in string `s` to axis at location `x`, `y`, data</span>
<span class="sd">        coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : scalars</span>
<span class="sd">            data coordinates</span>

<span class="sd">        s : string</span>
<span class="sd">            text</span>

<span class="sd">        fontdict : dictionary, optional, default: None</span>
<span class="sd">            A dictionary to override the default text properties. If fontdict</span>
<span class="sd">            is None, the defaults are determined by your rc parameters.</span>

<span class="sd">        withdash : boolean, optional, default: False</span>
<span class="sd">            Creates a `~matplotlib.text.TextWithDash` instance instead of a</span>
<span class="sd">            `~matplotlib.text.Text` instance.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs : `~matplotlib.text.Text` properties.</span>
<span class="sd">            Other miscellaneous text parameters.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Individual keyword arguments can be used to override any given</span>
<span class="sd">        parameter::</span>

<span class="sd">            &gt;&gt;&gt; text(x, y, s, fontsize=12)</span>

<span class="sd">        The default transform specifies that text is in data coords,</span>
<span class="sd">        alternatively, you can specify text in axis coords (0,0 is</span>
<span class="sd">        lower-left and 1,1 is upper-right).  The example below places</span>
<span class="sd">        text in the center of the axes::</span>

<span class="sd">            &gt;&gt;&gt; text(0.5, 0.5,&#39;matplotlib&#39;, horizontalalignment=&#39;center&#39;,</span>
<span class="sd">            ...      verticalalignment=&#39;center&#39;,</span>
<span class="sd">            ...      transform=ax.transAxes)</span>

<span class="sd">        You can put a rectangular box around the text instance (e.g., to</span>
<span class="sd">        set a background color) by using the keyword `bbox`.  `bbox` is</span>
<span class="sd">        a dictionary of `~matplotlib.patches.Rectangle`</span>
<span class="sd">        properties.  For example::</span>

<span class="sd">            &gt;&gt;&gt; text(x, y, s, bbox=dict(facecolor=&#39;red&#39;, alpha=0.5))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">default</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;verticalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;baseline&#39;</span><span class="p">,</span>
            <span class="s1">&#39;horizontalalignment&#39;</span><span class="p">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span>
            <span class="s1">&#39;transform&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">,</span>
            <span class="s1">&#39;clip_on&#39;</span><span class="p">:</span> <span class="bp">False</span><span class="p">}</span>

        <span class="c1"># At some point if we feel confident that TextWithDash</span>
        <span class="c1"># is robust as a drop-in replacement for Text and that</span>
        <span class="c1"># the performance impact of the heavier-weight class</span>
        <span class="c1"># isn&#39;t too significant, it may make sense to eliminate</span>
        <span class="c1"># the withdash kwarg and simply delegate whether there&#39;s</span>
        <span class="c1"># a dash to TextWithDash and dashlength.</span>
        <span class="k">if</span> <span class="n">withdash</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">TextWithDash</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span>
                <span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="n">s</span><span class="p">)</span>

        <span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">default</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fontdict</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">fontdict</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">t</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_text</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span></div>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.annotate"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.annotate.html#mpl.axes.Axes.annotate">[docs]</a>    <span class="k">def</span> <span class="nf">annotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create an annotation: a piece of text referring to a data</span>
<span class="sd">        point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        s : string</span>
<span class="sd">            label</span>

<span class="sd">        xy : (x, y)</span>
<span class="sd">            position of element to annotate. See *xycoords* to control what</span>
<span class="sd">            coordinate system this value is interpretated in.</span>

<span class="sd">        xytext : (x, y) , optional, default: None</span>
<span class="sd">            position of the label `s`. See *textcoords* to control what</span>
<span class="sd">            coordinate system this value is interpreted in.</span>

<span class="sd">        xycoords : string, optional, default: &quot;data&quot;</span>
<span class="sd">            string that indicates what type of coordinates `xy` is. Examples:</span>
<span class="sd">            &quot;figure points&quot;, &quot;figure pixels&quot;, &quot;figure fraction&quot;, &quot;axes</span>
<span class="sd">            points&quot;, .... See `matplotlib.text.Annotation` for more details.</span>

<span class="sd">        textcoords : string, optional, default: None</span>
<span class="sd">            string that indicates what type of coordinates `text` is. Examples:</span>
<span class="sd">            &quot;figure points&quot;, &quot;figure pixels&quot;, &quot;figure fraction&quot;, &quot;axes</span>
<span class="sd">            points&quot;, .... See `matplotlib.text.Annotation` for more details.</span>

<span class="sd">        arrowprops : `matplotlib.lines.Line2D` properties, optional</span>
<span class="sd">            Dictionary of line properties for the arrow that connects</span>
<span class="sd">            the annotation to the point. If the dictionnary has a key</span>
<span class="sd">            `arrowstyle`, a `~matplotlib.patches.FancyArrowPatch`</span>
<span class="sd">            instance is created and drawn.  See</span>
<span class="sd">            `matplotlib.text.Annotation` for more details on valid</span>
<span class="sd">            options. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        a : `~matplotlib.text.Annotation`</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        %(Annotation)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/annotation_demo2.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">mtext</span><span class="o">.</span><span class="n">Annotation</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="k">if</span> <span class="s1">&#39;clip_on&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_text</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span></div>

    <span class="c1">#### Lines and spans</span>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.axhline"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.axhline.html#mpl.axes.Axes.axhline">[docs]</a>    <span class="k">def</span> <span class="nf">axhline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a horizontal line across the axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : scalar, optional, default: 0</span>
<span class="sd">            y position in data coordinates of the horizontal line.</span>

<span class="sd">        xmin : scalar, optional, default: 0</span>
<span class="sd">            Should be between 0 and 1, 0 being the far left of the plot, 1 the</span>
<span class="sd">            far right of the plot.</span>

<span class="sd">        xmax : scalar, optional, default: 1</span>
<span class="sd">            Should be between 0 and 1, 0 being the far left of the plot, 1 the</span>
<span class="sd">            far right of the plot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~matplotlib.lines.Line2D`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        kwargs are passed to :class:`~matplotlib.lines.Line2D` and can be used</span>
<span class="sd">        to control the line properties.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        * draw a thick red hline at &#39;y&#39; = 0 that spans the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(linewidth=4, color=&#39;r&#39;)</span>

<span class="sd">        * draw a default hline at &#39;y&#39; = 1 that spans the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(y=1)</span>

<span class="sd">        * draw a default hline at &#39;y&#39; = .5 that spans the middle half of</span>
<span class="sd">          the xrange::</span>

<span class="sd">            &gt;&gt;&gt; axhline(y=.5, xmin=0.25, xmax=0.75)</span>

<span class="sd">        Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,</span>
<span class="sd">        with the exception of &#39;transform&#39;:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        axhspan : for example plot and source code</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;transform&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;transform&#39; is not allowed as a kwarg;&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;axhline generates its own transform.&quot;</span><span class="p">)</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ybound</span><span class="p">()</span>

        <span class="c1"># We need to strip away the units for comparison with</span>
        <span class="c1"># non-unitized bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">yy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">scaley</span> <span class="o">=</span> <span class="p">(</span><span class="n">yy</span> <span class="o">&lt;</span> <span class="n">ymin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">yy</span> <span class="o">&gt;</span> <span class="n">ymax</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="n">scaley</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span></div>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.axvline"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.axvline.html#mpl.axes.Axes.axvline">[docs]</a>    <span class="k">def</span> <span class="nf">axvline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertical line across the axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : scalar, optional, default: 0</span>
<span class="sd">            x position in data coordinates of the vertical line.</span>

<span class="sd">        ymin : scalar, optional, default: 0</span>
<span class="sd">            Should be between 0 and 1, 0 being the bottom of the plot, 1 the</span>
<span class="sd">            top of the plot.</span>

<span class="sd">        ymax : scalar, optional, default: 1</span>
<span class="sd">            Should be between 0 and 1, 0 being the bottom of the plot, 1 the</span>
<span class="sd">            top of the plot.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :class:`~matplotlib.lines.Line2D`</span>


<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        * draw a thick red vline at *x* = 0 that spans the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(linewidth=4, color=&#39;r&#39;)</span>

<span class="sd">        * draw a default vline at *x* = 1 that spans the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(x=1)</span>

<span class="sd">        * draw a default vline at *x* = .5 that spans the middle half of</span>
<span class="sd">          the yrange::</span>

<span class="sd">            &gt;&gt;&gt; axvline(x=.5, ymin=0.25, ymax=0.75)</span>

<span class="sd">        Valid kwargs are :class:`~matplotlib.lines.Line2D` properties,</span>
<span class="sd">        with the exception of &#39;transform&#39;:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        axhspan : for example plot and source code</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;transform&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;transform&#39; is not allowed as a kwarg;&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;axvline generates its own transform.&quot;</span><span class="p">)</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xbound</span><span class="p">()</span>

        <span class="c1"># We need to strip away the units for comparison with</span>
        <span class="c1"># non-unitized bounds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">scalex</span> <span class="o">=</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&lt;</span> <span class="n">xmin</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">xx</span> <span class="o">&gt;</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="n">scalex</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">l</span></div>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.axhspan"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.axhspan.html#mpl.axes.Axes.axhspan">[docs]</a>    <span class="k">def</span> <span class="nf">axhspan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">xmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a horizontal span (rectangle) across the axis.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          axhspan(ymin, ymax, xmin=0, xmax=1, **kwargs)</span>

<span class="sd">        *y* coords are in data units and *x* coords are in axes (relative</span>
<span class="sd">        0-1) units.</span>

<span class="sd">        Draw a horizontal span (rectangle) from *ymin* to *ymax*.</span>
<span class="sd">        With the default values of *xmin* = 0 and *xmax* = 1, this</span>
<span class="sd">        always spans the xrange, regardless of the xlim settings, even</span>
<span class="sd">        if you change them, e.g., with the :meth:`set_xlim` command.</span>
<span class="sd">        That is, the horizontal extent is in axes coords: 0=left,</span>
<span class="sd">        0.5=middle, 1.0=right but the *y* location is in data</span>
<span class="sd">        coordinates.</span>

<span class="sd">        Return value is a :class:`matplotlib.patches.Polygon`</span>
<span class="sd">        instance.</span>

<span class="sd">       Examples:</span>

<span class="sd">        * draw a gray rectangle from *y* = 0.25-0.75 that spans the</span>
<span class="sd">          horizontal extent of the axes::</span>

<span class="sd">            &gt;&gt;&gt; axhspan(0.25, 0.75, facecolor=&#39;0.5&#39;, alpha=0.5)</span>

<span class="sd">        Valid kwargs are :class:`~matplotlib.patches.Polygon` properties:</span>

<span class="sd">        %(Polygon)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/axhspan_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>

        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># first we need to strip away the units</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.axvspan"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.axvspan.html#mpl.axes.Axes.axvspan">[docs]</a>    <span class="k">def</span> <span class="nf">axvspan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a vertical span (rectangle) across the axes.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          axvspan(xmin, xmax, ymin=0, ymax=1, **kwargs)</span>

<span class="sd">        *x* coords are in data units and *y* coords are in axes (relative</span>
<span class="sd">        0-1) units.</span>

<span class="sd">        Draw a vertical span (rectangle) from *xmin* to *xmax*.  With</span>
<span class="sd">        the default values of *ymin* = 0 and *ymax* = 1, this always</span>
<span class="sd">        spans the yrange, regardless of the ylim settings, even if you</span>
<span class="sd">        change them, e.g., with the :meth:`set_ylim` command.  That is,</span>
<span class="sd">        the vertical extent is in axes coords: 0=bottom, 0.5=middle,</span>
<span class="sd">        1.0=top but the *y* location is in data coordinates.</span>

<span class="sd">        Return value is the :class:`matplotlib.patches.Polygon`</span>
<span class="sd">        instance.</span>

<span class="sd">        Examples:</span>

<span class="sd">        * draw a vertical green translucent rectangle from x=1.25 to 1.55 that</span>
<span class="sd">          spans the yrange of the axes::</span>

<span class="sd">            &gt;&gt;&gt; axvspan(1.25, 1.55, facecolor=&#39;g&#39;, alpha=0.5)</span>

<span class="sd">        Valid kwargs are :class:`~matplotlib.patches.Polygon`</span>
<span class="sd">        properties:</span>

<span class="sd">        %(Polygon)s</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`axhspan`</span>
<span class="sd">                for example plot and source code</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>

        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># first we need to strip away the units</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">])</span>
        <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">([</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">])</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scaley</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">p</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;xmin&#39;</span><span class="p">,</span> <span class="s1">&#39;xmax&#39;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent</span>
<div class="viewcode-block" id="Axes.hlines"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.hlines.html#mpl.axes.Axes.hlines">[docs]</a>    <span class="k">def</span> <span class="nf">hlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
               <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot horizontal lines at each `y` from `xmin` to `xmax`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : scalar or sequence of scalar</span>
<span class="sd">            y-indexes where to plot the lines.</span>

<span class="sd">        xmin, xmax : scalar or 1D array_like</span>
<span class="sd">            Respective beginning and end of each line. If scalars are</span>
<span class="sd">            provided, all lines will have same length.</span>

<span class="sd">        colors : array_like of colors, optional, default: &#39;k&#39;</span>

<span class="sd">        linestyles : [&#39;solid&#39; | &#39;dashed&#39; | &#39;dashdot&#39; | &#39;dotted&#39;], optional</span>

<span class="sd">        label : string, optional, default: &#39;&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : `~matplotlib.collections.LineCollection`</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs :  `~matplotlib.collections.LineCollection` properties.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        vlines : vertical lines</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot:: mpl_examples/pylab_examples/vline_hline_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">],</span> <span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xmin</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xmax</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">xmin</span><span class="p">):</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmin</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">xmax</span><span class="p">):</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="p">[</span><span class="n">xmax</span><span class="p">]</span>

        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[((</span><span class="n">thisxmin</span><span class="p">,</span> <span class="n">thisy</span><span class="p">),</span> <span class="p">(</span><span class="n">thisxmax</span><span class="p">,</span> <span class="n">thisy</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">thisxmin</span><span class="p">,</span> <span class="n">thisxmax</span><span class="p">,</span> <span class="n">thisy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
        <span class="n">coll</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                                    <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">coll</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">coll</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">xmax</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmin</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">xmax</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">miny</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">coll</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;ymin&quot;</span><span class="p">,</span> <span class="s2">&quot;ymax&quot;</span><span class="p">,</span> <span class="s2">&quot;colors&quot;</span><span class="p">],</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.vlines"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.vlines.html#mpl.axes.Axes.vlines">[docs]</a>    <span class="k">def</span> <span class="nf">vlines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span>
               <span class="n">label</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot vertical lines.</span>

<span class="sd">        Plot vertical lines at each `x` from `ymin` to `ymax`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : scalar or 1D array_like</span>
<span class="sd">            x-indexes where to plot the lines.</span>

<span class="sd">        ymin, ymax : scalar or 1D array_like</span>
<span class="sd">            Respective beginning and end of each line. If scalars are</span>
<span class="sd">            provided, all lines will have same length.</span>

<span class="sd">        colors : array_like of colors, optional, default: &#39;k&#39;</span>

<span class="sd">        linestyles : [&#39;solid&#39; | &#39;dashed&#39; | &#39;dashdot&#39; | &#39;dotted&#39;], optional</span>

<span class="sd">        label : string, optional, default: &#39;&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lines : `~matplotlib.collections.LineCollection`</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs : `~matplotlib.collections.LineCollection` properties.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hlines : horizontal lines</span>

<span class="sd">        Examples</span>
<span class="sd">        ---------</span>
<span class="sd">        .. plot:: mpl_examples/pylab_examples/vline_hline_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="p">[</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">],</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">ymin</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">ymax</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">ymin</span><span class="p">):</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymin</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">ymax</span><span class="p">):</span>
            <span class="n">ymax</span> <span class="o">=</span> <span class="p">[</span><span class="n">ymax</span><span class="p">]</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">ymax</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="n">verts</span> <span class="o">=</span> <span class="p">[((</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thisymin</span><span class="p">),</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thisymax</span><span class="p">))</span>
                 <span class="k">for</span> <span class="n">thisx</span><span class="p">,</span> <span class="n">thisymin</span><span class="p">,</span> <span class="n">thisymax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)]</span>
        <span class="c1">#print &#39;creating line collection&#39;</span>
        <span class="n">coll</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                                    <span class="n">linestyles</span><span class="o">=</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">coll</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">coll</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ymin</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">ymax</span><span class="p">))</span>
            <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">ymin</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymax</span><span class="p">))</span>

            <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">coll</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;positions&quot;</span><span class="p">,</span> <span class="s2">&quot;lineoffsets&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;linelengths&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidths&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;colors&quot;</span><span class="p">,</span> <span class="s2">&quot;linestyles&quot;</span><span class="p">],</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.eventplot"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.eventplot.html#mpl.axes.Axes.eventplot">[docs]</a>    <span class="k">def</span> <span class="nf">eventplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="n">lineoffsets</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                  <span class="n">linelengths</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                  <span class="n">linestyles</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot identical parallel lines at specific positions.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          eventplot(positions, orientation=&#39;horizontal&#39;, lineoffsets=0,</span>
<span class="sd">                    linelengths=1, linewidths=None, color =None,</span>
<span class="sd">                    linestyles=&#39;solid&#39;</span>

<span class="sd">        Plot parallel lines at the given positions.  positions should be a 1D</span>
<span class="sd">        or 2D array-like object, with each row corresponding to a row or column</span>
<span class="sd">        of lines.</span>

<span class="sd">        This type of plot is commonly used in neuroscience for representing</span>
<span class="sd">        neural events, where it is commonly called a spike raster, dot raster,</span>
<span class="sd">        or raster plot.</span>

<span class="sd">        However, it is useful in any situation where you wish to show the</span>
<span class="sd">        timing or position of multiple sets of discrete events, such as the</span>
<span class="sd">        arrival times of people to a business on each day of the month or the</span>
<span class="sd">        date of hurricanes each year of the last century.</span>

<span class="sd">        *orientation* : [ &#39;horizonal&#39; | &#39;vertical&#39; ]</span>
<span class="sd">          &#39;horizonal&#39; : the lines will be vertical and arranged in rows</span>
<span class="sd">          &quot;vertical&#39; : lines will be horizontal and arranged in columns</span>

<span class="sd">        *lineoffsets* :</span>
<span class="sd">          A float or array-like containing floats.</span>

<span class="sd">        *linelengths* :</span>
<span class="sd">          A float or array-like containing floats.</span>

<span class="sd">        *linewidths* :</span>
<span class="sd">          A float or array-like containing floats.</span>

<span class="sd">        *colors*</span>
<span class="sd">          must be a sequence of RGBA tuples (e.g., arbitrary color</span>
<span class="sd">          strings, etc, not allowed) or a list of such sequences</span>

<span class="sd">        *linestyles* :</span>
<span class="sd">          [ &#39;solid&#39; | &#39;dashed&#39; | &#39;dashdot&#39; | &#39;dotted&#39; ] or an array of these</span>
<span class="sd">          values</span>

<span class="sd">        For linelengths, linewidths, colors, and linestyles, if only a single</span>
<span class="sd">        value is given, that value is applied to all lines.  If an array-like</span>
<span class="sd">        is given, it must have the same length as positions, and each value</span>
<span class="sd">        will be applied to the corresponding row or column in positions.</span>

<span class="sd">        Returns a list of :class:`matplotlib.collections.EventCollection`</span>
<span class="sd">        objects that were added.</span>

<span class="sd">        kwargs are :class:`~matplotlib.collections.LineCollection` properties:</span>

<span class="sd">        %(LineCollection)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/eventplot_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span>
                                <span class="n">ydata</span><span class="o">=</span><span class="p">[</span><span class="n">lineoffsets</span><span class="p">,</span> <span class="n">linelengths</span><span class="p">],</span>
                                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># We do the conversion first since not all unitized data is uniform</span>
        <span class="n">positions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="n">lineoffsets</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="n">linelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">positions</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="n">iterable</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">):</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">position</span><span class="p">)</span> <span class="k">for</span> <span class="n">position</span> <span class="ow">in</span> <span class="n">positions</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">positions</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># prevent &#39;singular&#39; keys from **kwargs dict from overriding the effect</span>
        <span class="c1"># of &#39;plural&#39; keyword arguments (e.g. &#39;color&#39; overriding &#39;colors&#39;)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">local_over_kwdict</span><span class="p">(</span><span class="n">colors</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">)</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">local_over_kwdict</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;linewidth&#39;</span><span class="p">)</span>
        <span class="n">linestyles</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">local_over_kwdict</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">):</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="n">lineoffsets</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">linelengths</span><span class="p">):</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linelengths</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linewidths</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">colors</span><span class="p">):</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="n">colors</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">linestyles</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">linestyles</span><span class="p">):</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span>

        <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="n">linelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
            <span class="n">lineoffsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">lineoffsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">linelengths</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linewidths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">linewidths</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">linestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lineoffsets</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;lineoffsets and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linelengths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;linelengths and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;linewidths and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;colors and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;linestyles and positions are unequal sized &#39;</span>
                             <span class="s1">&#39;sequences&#39;</span><span class="p">)</span>

        <span class="n">colls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">position</span><span class="p">,</span> <span class="n">lineoffset</span><span class="p">,</span> <span class="n">linelength</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">linestyle</span> <span class="ow">in</span> \
            <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">lineoffsets</span><span class="p">,</span> <span class="n">linelengths</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">,</span>
                           <span class="n">colors</span><span class="p">,</span> <span class="n">linestyles</span><span class="p">):</span>
            <span class="n">coll</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">EventCollection</span><span class="p">(</span><span class="n">position</span><span class="p">,</span>
                                         <span class="n">orientation</span><span class="o">=</span><span class="n">orientation</span><span class="p">,</span>
                                         <span class="n">lineoffset</span><span class="o">=</span><span class="n">lineoffset</span><span class="p">,</span>
                                         <span class="n">linelength</span><span class="o">=</span><span class="n">linelength</span><span class="p">,</span>
                                         <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
                                         <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                         <span class="n">linestyle</span><span class="o">=</span><span class="n">linestyle</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">coll</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">coll</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">colls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coll</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># try to get min/max</span>
            <span class="n">min_max</span> <span class="o">=</span> <span class="p">[(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">_p</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">_p</span><span class="p">))</span> <span class="k">for</span> <span class="n">_p</span> <span class="ow">in</span> <span class="n">positions</span>
                       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">_p</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
            <span class="c1"># if we have any non-empty positions, try to autoscale</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_max</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mins</span><span class="p">,</span> <span class="n">maxes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">min_max</span><span class="p">)</span>
                <span class="n">minpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">mins</span><span class="p">)</span>
                <span class="n">maxpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">maxes</span><span class="p">)</span>

                <span class="n">minline</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffsets</span> <span class="o">-</span> <span class="n">linelengths</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                <span class="n">maxline</span> <span class="o">=</span> <span class="p">(</span><span class="n">lineoffsets</span> <span class="o">+</span> <span class="n">linelengths</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">colls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_horizontal</span><span class="p">():</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minpos</span><span class="p">,</span> <span class="n">minline</span><span class="p">),</span> <span class="p">(</span><span class="n">maxpos</span><span class="p">,</span> <span class="n">maxline</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minline</span><span class="p">,</span> <span class="n">minpos</span><span class="p">),</span> <span class="p">(</span><span class="n">maxline</span><span class="p">,</span> <span class="n">maxpos</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">colls</span></div>

    <span class="c1"># ### Basic plotting</span>
    <span class="c1"># The label_naming happens in `matplotlib.axes._base._plot_args`</span>
    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span>
                         <span class="n">positional_parameter_names</span><span class="o">=</span><span class="n">_plot_args_replacer</span><span class="p">,</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.plot"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.plot.html#mpl.axes.Axes.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot lines and/or markers to the</span>
<span class="sd">        :class:`~matplotlib.axes.Axes`.  *args* is a variable length</span>
<span class="sd">        argument, allowing for multiple *x*, *y* pairs with an</span>
<span class="sd">        optional format string.  For example, each of the following is</span>
<span class="sd">        legal::</span>

<span class="sd">            plot(x, y)        # plot x and y using default line style and color</span>
<span class="sd">            plot(x, y, &#39;bo&#39;)  # plot x and y using blue circle markers</span>
<span class="sd">            plot(y)           # plot y using x as index array 0..N-1</span>
<span class="sd">            plot(y, &#39;r+&#39;)     # ditto, but with red plusses</span>

<span class="sd">        If *x* and/or *y* is 2-dimensional, then the corresponding columns</span>
<span class="sd">        will be plotted.</span>

<span class="sd">        If used with labeled data, make sure that the color spec is not</span>
<span class="sd">        included as an element in data, as otherwise the last case</span>
<span class="sd">        ``plot(&quot;v&quot;,&quot;r&quot;, data={&quot;v&quot;:..., &quot;r&quot;:...)``</span>
<span class="sd">        can be interpreted as the first case which would do ``plot(v, r)``</span>
<span class="sd">        using the default line style and color.</span>

<span class="sd">        If not used with labeled data (i.e., without a data argument),</span>
<span class="sd">        an arbitrary number of *x*, *y*, *fmt* groups can be specified, as in::</span>

<span class="sd">            a.plot(x1, y1, &#39;g^&#39;, x2, y2, &#39;g-&#39;)</span>

<span class="sd">        Return value is a list of lines that were added.</span>

<span class="sd">        By default, each line is assigned a different style specified by a</span>
<span class="sd">        &#39;style cycle&#39;.  To change this behavior, you can edit the</span>
<span class="sd">        axes.prop_cycle rcParam.</span>

<span class="sd">        The following format string characters are accepted to control</span>
<span class="sd">        the line style or marker:</span>

<span class="sd">        ================    ===============================</span>
<span class="sd">        character           description</span>
<span class="sd">        ================    ===============================</span>
<span class="sd">        ``&#39;-&#39;``             solid line style</span>
<span class="sd">        ``&#39;--&#39;``            dashed line style</span>
<span class="sd">        ``&#39;-.&#39;``            dash-dot line style</span>
<span class="sd">        ``&#39;:&#39;``             dotted line style</span>
<span class="sd">        ``&#39;.&#39;``             point marker</span>
<span class="sd">        ``&#39;,&#39;``             pixel marker</span>
<span class="sd">        ``&#39;o&#39;``             circle marker</span>
<span class="sd">        ``&#39;v&#39;``             triangle_down marker</span>
<span class="sd">        ``&#39;^&#39;``             triangle_up marker</span>
<span class="sd">        ``&#39;&lt;&#39;``             triangle_left marker</span>
<span class="sd">        ``&#39;&gt;&#39;``             triangle_right marker</span>
<span class="sd">        ``&#39;1&#39;``             tri_down marker</span>
<span class="sd">        ``&#39;2&#39;``             tri_up marker</span>
<span class="sd">        ``&#39;3&#39;``             tri_left marker</span>
<span class="sd">        ``&#39;4&#39;``             tri_right marker</span>
<span class="sd">        ``&#39;s&#39;``             square marker</span>
<span class="sd">        ``&#39;p&#39;``             pentagon marker</span>
<span class="sd">        ``&#39;*&#39;``             star marker</span>
<span class="sd">        ``&#39;h&#39;``             hexagon1 marker</span>
<span class="sd">        ``&#39;H&#39;``             hexagon2 marker</span>
<span class="sd">        ``&#39;+&#39;``             plus marker</span>
<span class="sd">        ``&#39;x&#39;``             x marker</span>
<span class="sd">        ``&#39;D&#39;``             diamond marker</span>
<span class="sd">        ``&#39;d&#39;``             thin_diamond marker</span>
<span class="sd">        ``&#39;|&#39;``             vline marker</span>
<span class="sd">        ``&#39;_&#39;``             hline marker</span>
<span class="sd">        ================    ===============================</span>


<span class="sd">        The following color abbreviations are supported:</span>

<span class="sd">        ==========  ========</span>
<span class="sd">        character   color</span>
<span class="sd">        ==========  ========</span>
<span class="sd">        &#39;b&#39;         blue</span>
<span class="sd">        &#39;g&#39;         green</span>
<span class="sd">        &#39;r&#39;         red</span>
<span class="sd">        &#39;c&#39;         cyan</span>
<span class="sd">        &#39;m&#39;         magenta</span>
<span class="sd">        &#39;y&#39;         yellow</span>
<span class="sd">        &#39;k&#39;         black</span>
<span class="sd">        &#39;w&#39;         white</span>
<span class="sd">        ==========  ========</span>

<span class="sd">        In addition, you can specify colors in many weird and</span>
<span class="sd">        wonderful ways, including full names (``&#39;green&#39;``), hex</span>
<span class="sd">        strings (``&#39;#008000&#39;``), RGB or RGBA tuples (``(0,1,0,1)``) or</span>
<span class="sd">        grayscale intensities as a string (``&#39;0.8&#39;``).  Of these, the</span>
<span class="sd">        string specifications can be used in place of a ``fmt`` group,</span>
<span class="sd">        but the tuple forms can be used only as ``kwargs``.</span>

<span class="sd">        Line styles and colors are combined in a single format string, as in</span>
<span class="sd">        ``&#39;bo&#39;`` for blue circles.</span>

<span class="sd">        The *kwargs* can be used to set line properties (any property that has</span>
<span class="sd">        a ``set_*`` method).  You can use this to set a line label (for auto</span>
<span class="sd">        legends), linewidth, anitialising, marker face color, etc.  Here is an</span>
<span class="sd">        example::</span>

<span class="sd">            plot([1,2,3], [1,2,3], &#39;go-&#39;, label=&#39;line 1&#39;, linewidth=2)</span>
<span class="sd">            plot([1,2,3], [1,4,9], &#39;rs&#39;,  label=&#39;line 2&#39;)</span>
<span class="sd">            axis([0, 4, 0, 10])</span>
<span class="sd">            legend()</span>

<span class="sd">        If you make multiple lines with one plot command, the kwargs</span>
<span class="sd">        apply to all those lines, e.g.::</span>

<span class="sd">            plot(x1, y1, x2, y2, antialiased=False)</span>

<span class="sd">        Neither line will be antialiased.</span>

<span class="sd">        You do not need to use format strings, which are just</span>
<span class="sd">        abbreviations.  All of the line properties can be controlled</span>
<span class="sd">        by keyword arguments.  For example, you can set the color,</span>
<span class="sd">        marker, linestyle, and markercolor with::</span>

<span class="sd">            plot(x, y, color=&#39;green&#39;, linestyle=&#39;dashed&#39;, marker=&#39;o&#39;,</span>
<span class="sd">                 markerfacecolor=&#39;blue&#39;, markersize=12).</span>

<span class="sd">        See :class:`~matplotlib.lines.Line2D` for details.</span>

<span class="sd">        The kwargs are :class:`~matplotlib.lines.Line2D` properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        kwargs *scalex* and *scaley*, if defined, are passed on to</span>
<span class="sd">        :meth:`~matplotlib.axes.Axes.autoscale_view` to determine</span>
<span class="sd">        whether the *x* and *y* axes are autoscaled; the default is</span>
<span class="sd">        *True*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scalex</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;scalex&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="n">scaley</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;scaley&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Convert &quot;c&quot; alias to &quot;color&quot; immediately, to avoid</span>
        <span class="c1"># confusion farther on.</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">scalex</span><span class="o">=</span><span class="n">scalex</span><span class="p">,</span> <span class="n">scaley</span><span class="o">=</span><span class="n">scaley</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">lines</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.plot_date"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.plot_date.html#mpl.axes.Axes.plot_date">[docs]</a>    <span class="k">def</span> <span class="nf">plot_date</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">tz</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">xdate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ydate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot with data with dates.</span>

<span class="sd">        Call signature::</span>

<span class="sd">           plot_date(x, y, fmt=&#39;bo&#39;, tz=None, xdate=True,</span>
<span class="sd">                     ydate=False, **kwargs)</span>

<span class="sd">        Similar to the :func:`~matplotlib.pyplot.plot` command, except</span>
<span class="sd">        the *x* or *y* (or both) data is considered to be dates, and the</span>
<span class="sd">        axis is labeled accordingly.</span>

<span class="sd">        *x* and/or *y* can be a sequence of dates represented as float</span>
<span class="sd">        days since 0001-01-01 UTC.</span>

<span class="sd">        Keyword arguments:</span>

<span class="sd">          *fmt*: string</span>
<span class="sd">            The plot format string.</span>

<span class="sd">          *tz*: [ *None* | timezone string | :class:`tzinfo` instance]</span>
<span class="sd">            The time zone to use in labeling dates. If *None*, defaults to rc</span>
<span class="sd">            value.</span>

<span class="sd">          *xdate*: [ *True* | *False* ]</span>
<span class="sd">            If *True*, the *x*-axis will be labeled with dates.</span>

<span class="sd">          *ydate*: [ *False* | *True* ]</span>
<span class="sd">            If *True*, the *y*-axis will be labeled with dates.</span>

<span class="sd">        Note if you are using custom date tickers and formatters, it</span>
<span class="sd">        may be necessary to set the formatters/locators after the call</span>
<span class="sd">        to :meth:`plot_date` since :meth:`plot_date` will set the</span>
<span class="sd">        default tick locator to</span>
<span class="sd">        :class:`matplotlib.dates.AutoDateLocator` (if the tick</span>
<span class="sd">        locator is not already set to a</span>
<span class="sd">        :class:`matplotlib.dates.DateLocator` instance) and the</span>
<span class="sd">        default tick formatter to</span>
<span class="sd">        :class:`matplotlib.dates.AutoDateFormatter` (if the tick</span>
<span class="sd">        formatter is not already set to a</span>
<span class="sd">        :class:`matplotlib.dates.DateFormatter` instance).</span>

<span class="sd">        Valid kwargs are :class:`~matplotlib.lines.Line2D` properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        .. seealso::</span>

<span class="sd">           :mod:`~matplotlib.dates` for helper functions</span>

<span class="sd">           :func:`~matplotlib.dates.date2num`,</span>
<span class="sd">           :func:`~matplotlib.dates.num2date` and</span>
<span class="sd">           :func:`~matplotlib.dates.drange` for help on creating the required</span>
<span class="sd">           floating point dates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xdate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_date</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ydate</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_date</span><span class="p">(</span><span class="n">tz</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="c1"># @unpack_labeled_data() # let &#39;plot&#39; do the unpacking..</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.loglog"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.loglog.html#mpl.axes.Axes.loglog">[docs]</a>    <span class="k">def</span> <span class="nf">loglog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a plot with log scaling on both the *x* and *y* axis.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          loglog(*args, **kwargs)</span>

<span class="sd">        :func:`~matplotlib.pyplot.loglog` supports all the keyword</span>
<span class="sd">        arguments of :func:`~matplotlib.pyplot.plot` and</span>
<span class="sd">        :meth:`matplotlib.axes.Axes.set_xscale` /</span>
<span class="sd">        :meth:`matplotlib.axes.Axes.set_yscale`.</span>

<span class="sd">        Notable keyword arguments:</span>

<span class="sd">          *basex*/*basey*: scalar &gt; 1</span>
<span class="sd">            Base of the *x*/*y* logarithm</span>

<span class="sd">          *subsx*/*subsy*: [ *None* | sequence ]</span>
<span class="sd">            The location of the minor *x*/*y* ticks; *None* defaults</span>
<span class="sd">            to autosubs, which depend on the number of decades in the</span>
<span class="sd">            plot; see :meth:`matplotlib.axes.Axes.set_xscale` /</span>
<span class="sd">            :meth:`matplotlib.axes.Axes.set_yscale` for details</span>

<span class="sd">          *nonposx*/*nonposy*: [&#39;mask&#39; | &#39;clip&#39; ]</span>
<span class="sd">            Non-positive values in *x* or *y* can be masked as</span>
<span class="sd">            invalid, or clipped to a very small positive number</span>

<span class="sd">        The remaining valid kwargs are</span>
<span class="sd">        :class:`~matplotlib.lines.Line2D` properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/log_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">dx</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;basex&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;basex&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
              <span class="s1">&#39;subsx&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;subsx&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
              <span class="s1">&#39;nonposx&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nonposx&#39;</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">),</span>
              <span class="p">}</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;basey&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;basey&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
              <span class="s1">&#39;subsy&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;subsy&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
              <span class="s1">&#39;nonposy&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nonposy&#39;</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">),</span>
              <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">dx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">dy</span><span class="p">)</span>

        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># we&#39;ve already processed the hold</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># restore the hold</span>

        <span class="k">return</span> <span class="n">l</span></div>

    <span class="c1"># @unpack_labeled_data() # let &#39;plot&#39; do the unpacking..</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.semilogx"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.semilogx.html#mpl.axes.Axes.semilogx">[docs]</a>    <span class="k">def</span> <span class="nf">semilogx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a plot with log scaling on the *x* axis.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          semilogx(*args, **kwargs)</span>

<span class="sd">        :func:`semilogx` supports all the keyword arguments of</span>
<span class="sd">        :func:`~matplotlib.pyplot.plot` and</span>
<span class="sd">        :meth:`matplotlib.axes.Axes.set_xscale`.</span>

<span class="sd">        Notable keyword arguments:</span>

<span class="sd">          *basex*: scalar &gt; 1</span>
<span class="sd">            Base of the *x* logarithm</span>

<span class="sd">          *subsx*: [ *None* | sequence ]</span>
<span class="sd">            The location of the minor xticks; *None* defaults to</span>
<span class="sd">            autosubs, which depend on the number of decades in the</span>
<span class="sd">            plot; see :meth:`~matplotlib.axes.Axes.set_xscale` for</span>
<span class="sd">            details.</span>

<span class="sd">          *nonposx*: [ &#39;mask&#39; | &#39;clip&#39; ]</span>
<span class="sd">            Non-positive values in *x* can be masked as</span>
<span class="sd">            invalid, or clipped to a very small positive number</span>

<span class="sd">        The remaining valid kwargs are</span>
<span class="sd">        :class:`~matplotlib.lines.Line2D` properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`loglog`</span>
<span class="sd">                For example code and figure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;basex&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;basex&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
             <span class="s1">&#39;subsx&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;subsx&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
             <span class="s1">&#39;nonposx&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nonposx&#39;</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">),</span>
             <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># we&#39;ve already processed the hold</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># restore the hold</span>
        <span class="k">return</span> <span class="n">l</span></div>

    <span class="c1"># @unpack_labeled_data() # let &#39;plot&#39; do the unpacking..</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.semilogy"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.semilogy.html#mpl.axes.Axes.semilogy">[docs]</a>    <span class="k">def</span> <span class="nf">semilogy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a plot with log scaling on the *y* axis.</span>

<span class="sd">        call signature::</span>

<span class="sd">          semilogy(*args, **kwargs)</span>

<span class="sd">        :func:`semilogy` supports all the keyword arguments of</span>
<span class="sd">        :func:`~matplotlib.pylab.plot` and</span>
<span class="sd">        :meth:`matplotlib.axes.Axes.set_yscale`.</span>

<span class="sd">        Notable keyword arguments:</span>

<span class="sd">          *basey*: scalar &gt; 1</span>
<span class="sd">            Base of the *y* logarithm</span>

<span class="sd">          *subsy*: [ *None* | sequence ]</span>
<span class="sd">            The location of the minor yticks; *None* defaults to</span>
<span class="sd">            autosubs, which depend on the number of decades in the</span>
<span class="sd">            plot; see :meth:`~matplotlib.axes.Axes.set_yscale` for</span>
<span class="sd">            details.</span>

<span class="sd">          *nonposy*: [ &#39;mask&#39; | &#39;clip&#39; ]</span>
<span class="sd">            Non-positive values in *y* can be masked as</span>
<span class="sd">            invalid, or clipped to a very small positive number</span>

<span class="sd">        The remaining valid kwargs are</span>
<span class="sd">        :class:`~matplotlib.lines.Line2D` properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :meth:`loglog`</span>
<span class="sd">                For example code and figure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;basey&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;basey&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span>
             <span class="s1">&#39;subsy&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;subsy&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
             <span class="s1">&#39;nonposy&#39;</span><span class="p">:</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;nonposy&#39;</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">),</span>
             <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="bp">True</span>  <span class="c1"># we&#39;ve already processed the hold</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">b</span>  <span class="c1"># restore the hold</span>

        <span class="k">return</span> <span class="n">l</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.acorr"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.acorr.html#mpl.axes.Axes.acorr">[docs]</a>    <span class="k">def</span> <span class="nf">acorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the autocorrelation of `x`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        x : sequence of scalar</span>

<span class="sd">        hold : boolean, optional, default: True</span>

<span class="sd">        detrend : callable, optional, default: `mlab.detrend_none`</span>
<span class="sd">            x is detrended by the `detrend` callable. Default is no</span>
<span class="sd">            normalization.</span>

<span class="sd">        normed : boolean, optional, default: True</span>
<span class="sd">            if True, normalize the data by the autocorrelation at the 0-th</span>
<span class="sd">            lag.</span>

<span class="sd">        usevlines : boolean, optional, default: True</span>
<span class="sd">            if True, Axes.vlines is used to plot the vertical lines from the</span>
<span class="sd">            origin to the acorr. Otherwise, Axes.plot is used.</span>

<span class="sd">        maxlags : integer, optional, default: 10</span>
<span class="sd">            number of lags to show. If None, will return all 2 * len(x) - 1</span>
<span class="sd">            lags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (lags, c, line, b) : where:</span>

<span class="sd">          - `lags` are a length 2`maxlags+1 lag vector.</span>
<span class="sd">          - `c` is the 2`maxlags+1 auto correlation vectorI</span>
<span class="sd">          - `line` is a `~matplotlib.lines.Line2D` instance returned by</span>
<span class="sd">            `plot`.</span>
<span class="sd">          - `b` is the x-axis.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        -----------------</span>
<span class="sd">        linestyle : `~matplotlib.lines.Line2D` prop, optional, default: None</span>
<span class="sd">            Only used if usevlines is False.</span>

<span class="sd">        marker : string, optional, default: &#39;o&#39;</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cross correlation is performed with :func:`numpy.correlate` with</span>
<span class="sd">        `mode` = 2.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        `~matplotlib.pyplot.xcorr` is top graph, and</span>
<span class="sd">        `~matplotlib.pyplot.acorr` is bottom graph.</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/xcorr_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xcorr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.xcorr"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.xcorr.html#mpl.axes.Axes.xcorr">[docs]</a>    <span class="k">def</span> <span class="nf">xcorr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
              <span class="n">usevlines</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">maxlags</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the cross correlation between *x* and *y*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        x : sequence of scalars of length n</span>

<span class="sd">        y : sequence of scalars of length n</span>

<span class="sd">        hold : boolean, optional, default: True</span>

<span class="sd">        detrend : callable, optional, default: `mlab.detrend_none`</span>
<span class="sd">            x is detrended by the `detrend` callable. Default is no</span>
<span class="sd">            normalization.</span>

<span class="sd">        normed : boolean, optional, default: True</span>
<span class="sd">            if True, normalize the data by the autocorrelation at the 0-th</span>
<span class="sd">            lag.</span>

<span class="sd">        usevlines : boolean, optional, default: True</span>
<span class="sd">            if True, Axes.vlines is used to plot the vertical lines from the</span>
<span class="sd">            origin to the acorr. Otherwise, Axes.plot is used.</span>

<span class="sd">        maxlags : integer, optional, default: 10</span>
<span class="sd">            number of lags to show. If None, will return all 2 * len(x) - 1</span>
<span class="sd">            lags.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        (lags, c, line, b) : where:</span>

<span class="sd">          - `lags` are a length 2`maxlags+1 lag vector.</span>
<span class="sd">          - `c` is the 2`maxlags+1 auto correlation vectorI</span>
<span class="sd">          - `line` is a `~matplotlib.lines.Line2D` instance returned by</span>
<span class="sd">            `plot`.</span>
<span class="sd">          - `b` is the x-axis (none, if plot is used).</span>

<span class="sd">        Other parameters</span>
<span class="sd">        -----------------</span>
<span class="sd">        linestyle : `~matplotlib.lines.Line2D` prop, optional, default: None</span>
<span class="sd">            Only used if usevlines is False.</span>

<span class="sd">        marker : string, optional, default: &#39;o&#39;</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The cross correlation is performed with :func:`numpy.correlate` with</span>
<span class="sd">        `mode` = 2.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">Nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nx</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;x and y must be equal length&#39;</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">detrend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>

        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normed</span><span class="p">:</span>
            <span class="n">c</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">maxlags</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">maxlags</span> <span class="o">=</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">maxlags</span> <span class="o">&gt;=</span> <span class="n">Nx</span> <span class="ow">or</span> <span class="n">maxlags</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;maglags must be None or strictly &#39;</span>
                             <span class="s1">&#39;positive &lt; </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Nx</span><span class="p">)</span>

        <span class="n">lags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="n">maxlags</span><span class="p">,</span> <span class="n">maxlags</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">maxlags</span><span class="p">:</span><span class="n">Nx</span> <span class="o">+</span> <span class="n">maxlags</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">usevlines</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;marker&#39;</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linestyle&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">)</span>
            <span class="n">a</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lags</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">b</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">lags</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span></div>

    <span class="c1">#### Specialized plotting</span>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<div class="viewcode-block" id="Axes.step"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.step.html#mpl.axes.Axes.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a step plot.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          step(x, y, *args, **kwargs)</span>

<span class="sd">        Additional keyword args to :func:`step` are the same as those</span>
<span class="sd">        for :func:`~matplotlib.pyplot.plot`.</span>

<span class="sd">        *x* and *y* must be 1-D sequences, and it is assumed, but not checked,</span>
<span class="sd">        that *x* is uniformly increasing.</span>

<span class="sd">        Keyword arguments:</span>

<span class="sd">        *where*: [ &#39;pre&#39; | &#39;post&#39; | &#39;mid&#39;  ]</span>
<span class="sd">          If &#39;pre&#39; (the default), the interval from x[i] to x[i+1] has level</span>
<span class="sd">          y[i+1].</span>

<span class="sd">          If &#39;post&#39;, that interval has level y[i].</span>

<span class="sd">          If &#39;mid&#39;, the jumps in *y* occur half-way between the</span>
<span class="sd">          *x*-values.</span>

<span class="sd">        Return value is a list of lines that were added.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">where</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;where&#39;</span><span class="p">,</span> <span class="s1">&#39;pre&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">where</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;pre&#39;</span><span class="p">,</span> <span class="s1">&#39;post&#39;</span><span class="p">,</span> <span class="s1">&#39;mid&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;where&#39; argument to step must be &quot;</span>
                             <span class="s2">&quot;&#39;pre&#39;, &#39;post&#39; or &#39;mid&#39;&quot;</span><span class="p">)</span>
        <span class="n">usr_linestyle</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linestyle&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;linestyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;steps-&#39;</span> <span class="o">+</span> <span class="n">where</span> <span class="o">+</span> <span class="n">usr_linestyle</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">,</span> <span class="s2">&quot;bottom&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;color&quot;</span><span class="p">,</span> <span class="s2">&quot;edgecolor&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidth&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;tick_label&quot;</span><span class="p">,</span> <span class="s2">&quot;xerr&quot;</span><span class="p">,</span> <span class="s2">&quot;yerr&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;ecolor&quot;</span><span class="p">],</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.bar"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.bar.html#mpl.axes.Axes.bar">[docs]</a>    <span class="k">def</span> <span class="nf">bar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a bar plot.</span>

<span class="sd">        Make a bar plot with rectangles bounded by:</span>

<span class="sd">          `left`, `left` + `width`, `bottom`, `bottom` + `height`</span>
<span class="sd">                (left, right, bottom and top edges)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        left : sequence of scalars</span>
<span class="sd">            the x coordinates of the left sides of the bars</span>

<span class="sd">        height : sequence of scalars</span>
<span class="sd">            the heights of the bars</span>

<span class="sd">        width : scalar or array-like, optional</span>
<span class="sd">            the width(s) of the bars</span>
<span class="sd">            default: 0.8</span>

<span class="sd">        bottom : scalar or array-like, optional</span>
<span class="sd">            the y coordinate(s) of the bars</span>
<span class="sd">            default: None</span>

<span class="sd">        color : scalar or array-like, optional</span>
<span class="sd">            the colors of the bar faces</span>

<span class="sd">        edgecolor : scalar or array-like, optional</span>
<span class="sd">            the colors of the bar edges</span>

<span class="sd">        linewidth : scalar or array-like, optional</span>
<span class="sd">            width of bar edge(s). If None, use default</span>
<span class="sd">            linewidth; If 0, don&#39;t draw edges.</span>
<span class="sd">            default: None</span>

<span class="sd">        tick_label : string or array-like, optional</span>
<span class="sd">            the tick labels of the bars</span>
<span class="sd">            default: None</span>

<span class="sd">        xerr : scalar or array-like, optional</span>
<span class="sd">            if not None, will be used to generate errorbar(s) on the bar chart</span>
<span class="sd">            default: None</span>

<span class="sd">        yerr : scalar or array-like, optional</span>
<span class="sd">            if not None, will be used to generate errorbar(s) on the bar chart</span>
<span class="sd">            default: None</span>

<span class="sd">        ecolor : scalar or array-like, optional</span>
<span class="sd">            specifies the color of errorbar(s)</span>
<span class="sd">            default: None</span>

<span class="sd">        capsize : scalar, optional</span>
<span class="sd">           determines the length in points of the error bar caps</span>
<span class="sd">           default: None, which will take the value from the</span>
<span class="sd">           ``errorbar.capsize`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        error_kw : dict, optional</span>
<span class="sd">            dictionary of kwargs to be passed to errorbar method. *ecolor* and</span>
<span class="sd">            *capsize* may be specified here rather than as independent kwargs.</span>

<span class="sd">        align : {&#39;edge&#39;,  &#39;center&#39;}, optional</span>
<span class="sd">            If &#39;edge&#39;, aligns bars by their left edges (for vertical bars) and</span>
<span class="sd">            by their bottom edges (for horizontal bars). If &#39;center&#39;, interpret</span>
<span class="sd">            the `left` argument as the coordinates of the centers of the bars.</span>
<span class="sd">            To align on the align bars on the right edge pass a negative</span>
<span class="sd">            `width`.</span>

<span class="sd">        orientation : {&#39;vertical&#39;,  &#39;horizontal&#39;}, optional</span>
<span class="sd">            The orientation of the bars.</span>

<span class="sd">        log : boolean, optional</span>
<span class="sd">            If true, sets the axis to be log scale.</span>
<span class="sd">            default: False</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bars : matplotlib.container.BarContainer</span>
<span class="sd">            Container with all of the bars + errorbars</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The optional arguments `color`, `edgecolor`, `linewidth`,</span>
<span class="sd">        `xerr`, and `yerr` can be either scalars or sequences of</span>
<span class="sd">        length equal to the number of bars.  This enables you to use</span>
<span class="sd">        bar as the basis for stacked bar charts, or candlestick plots.</span>
<span class="sd">        Detail: `xerr` and `yerr` are passed directly to</span>
<span class="sd">        :meth:`errorbar`, so they can also have shape 2xN for</span>
<span class="sd">        independent specification of lower and upper errors.</span>

<span class="sd">        Other optional kwargs:</span>

<span class="sd">        %(Rectangle)s</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        barh: Plot a horizontal bar plot.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        **Example:** A stacked bar chart.</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/bar_stacked.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">color</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">edgecolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">linewidth</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="c1"># Because xerr and yerr will be passed to errorbar,</span>
        <span class="c1"># most dimension checking and processing will be left</span>
        <span class="c1"># to the errorbar method.</span>
        <span class="n">xerr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;xerr&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">yerr</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;yerr&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">error_kw</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;error_kw&#39;</span><span class="p">,</span> <span class="nb">dict</span><span class="p">())</span>
        <span class="n">ecolor</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;ecolor&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">capsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;capsize&#39;</span><span class="p">,</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;errorbar.capsize&quot;</span><span class="p">])</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;ecolor&#39;</span><span class="p">,</span> <span class="n">ecolor</span><span class="p">)</span>
        <span class="n">error_kw</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;capsize&#39;</span><span class="p">,</span> <span class="n">capsize</span><span class="p">)</span>

        <span class="n">align</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;align&#39;</span><span class="p">,</span> <span class="s1">&#39;edge&#39;</span><span class="p">)</span>
        <span class="n">orientation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;orientation&#39;</span><span class="p">,</span> <span class="s1">&#39;vertical&#39;</span><span class="p">)</span>
        <span class="n">log</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">tick_labels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;tick_label&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">make_iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">x</span>

        <span class="c1"># make them safe to take len() of</span>
        <span class="n">_left</span> <span class="o">=</span> <span class="n">left</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">make_iterable</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">make_iterable</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">make_iterable</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
        <span class="n">_bottom</span> <span class="o">=</span> <span class="n">bottom</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">make_iterable</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
        <span class="n">linewidth</span> <span class="o">=</span> <span class="n">make_iterable</span><span class="p">(</span><span class="n">linewidth</span><span class="p">)</span>

        <span class="n">adjust_ylim</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">adjust_xlim</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonposy</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
            <span class="c1"># size width and bottom according to length of left</span>
            <span class="k">if</span> <span class="n">_bottom</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yscale</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                    <span class="n">adjust_ylim</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">nbars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">*=</span> <span class="n">nbars</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bottom</span> <span class="o">*=</span> <span class="n">nbars</span>

            <span class="n">tick_label_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span>
            <span class="n">tick_label_position</span> <span class="o">=</span> <span class="n">left</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">width</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">bottom</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonposx</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
            <span class="c1"># size left and height according to length of bottom</span>
            <span class="k">if</span> <span class="n">_left</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xscale</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                    <span class="n">adjust_xlim</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="n">nbars</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">*=</span> <span class="n">nbars</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">height</span> <span class="o">*=</span> <span class="n">nbars</span>

            <span class="n">tick_label_axis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span>
            <span class="n">tick_label_position</span> <span class="o">=</span> <span class="n">bottom</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid orientation: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidth</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nbars</span><span class="p">:</span>
            <span class="n">linewidth</span> <span class="o">*=</span> <span class="n">nbars</span>

        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">colorConverter</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">color</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># until to_rgba_array is changed</span>
                <span class="n">color</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nbars</span><span class="p">:</span>
                <span class="n">color</span> <span class="o">*=</span> <span class="n">nbars</span>

        <span class="k">if</span> <span class="n">edgecolor</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbars</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edgecolor</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mcolors</span><span class="o">.</span><span class="n">colorConverter</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">edgecolor</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgecolor</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>     <span class="c1"># until to_rgba_array is changed</span>
                <span class="n">edgecolor</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgecolor</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nbars</span><span class="p">:</span>
                <span class="n">edgecolor</span> <span class="o">*=</span> <span class="n">nbars</span>

        <span class="c1"># input validation</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nbars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;incompatible sizes: argument &#39;left&#39; must &quot;</span>
                             <span class="s2">&quot;be length </span><span class="si">%d</span><span class="s2"> or scalar&quot;</span> <span class="o">%</span> <span class="n">nbars</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">height</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nbars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;incompatible sizes: argument &#39;height&#39; &quot;</span>
                              <span class="s2">&quot;must be length </span><span class="si">%d</span><span class="s2"> or scalar&quot;</span> <span class="o">%</span> <span class="n">nbars</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">width</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nbars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;incompatible sizes: argument &#39;width&#39; &quot;</span>
                             <span class="s2">&quot;must be length </span><span class="si">%d</span><span class="s2"> or scalar&quot;</span> <span class="o">%</span> <span class="n">nbars</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nbars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;incompatible sizes: argument &#39;bottom&#39; &quot;</span>
                             <span class="s2">&quot;must be length </span><span class="si">%d</span><span class="s2"> or scalar&quot;</span> <span class="o">%</span> <span class="n">nbars</span><span class="p">)</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># lets do some conversions now since some types cannot be</span>
        <span class="c1"># subtracted uniformly</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
            <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">xerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
            <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">yerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">left</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">width</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">left</span><span class="p">))]</span>
            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="p">[</span><span class="n">bottom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">height</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2.</span>
                          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bottom</span><span class="p">))]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid alignment: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">align</span><span class="p">)</span>

        <span class="n">args</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">edgecolor</span><span class="p">,</span> <span class="n">linewidth</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">lw</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">b</span> <span class="o">+=</span> <span class="n">h</span>
                <span class="n">h</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">+=</span> <span class="n">w</span>
                <span class="n">w</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">width</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">h</span><span class="p">,</span>
                <span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                <span class="n">edgecolor</span><span class="o">=</span><span class="n">e</span><span class="p">,</span>
                <span class="n">linewidth</span><span class="o">=</span><span class="n">lw</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="s1">&#39;_nolegend_&#39;</span>
                <span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">r</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">_interpolation_steps</span> <span class="o">=</span> <span class="mi">100</span>
            <span class="c1">#print r.get_label(), label, &#39;label&#39; in kwargs</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="n">holdstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># ensure hold is on before plotting errorbars</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="c1"># using list comps rather than arrays to preserve unit info</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="n">h</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">height</span><span class="p">)]</span>

            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="c1"># using list comps rather than arrays to preserve unit info</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">w</span> <span class="k">for</span> <span class="n">l</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">width</span><span class="p">)]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span> <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bottom</span><span class="p">,</span> <span class="n">height</span><span class="p">)]</span>

            <span class="k">if</span> <span class="s2">&quot;label&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">error_kw</span><span class="p">:</span>
                <span class="n">error_kw</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;_nolegend_&#39;</span>

            <span class="n">errorbar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errorbar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                                     <span class="n">yerr</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="n">xerr</span><span class="p">,</span>
                                     <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">error_kw</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">errorbar</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="n">holdstate</span><span class="p">)</span>  <span class="c1"># restore previous hold state</span>

        <span class="k">if</span> <span class="n">adjust_xlim</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervalx</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">width</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="n">xmin</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmin</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1e-100</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervalx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">adjust_ylim</span><span class="p">:</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervaly</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">([</span><span class="n">h</span> <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">height</span> <span class="k">if</span> <span class="n">h</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="n">ymin</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span>
            <span class="n">ymin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymin</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mf">1e-100</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervaly</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="n">bar_container</span> <span class="o">=</span> <span class="n">BarContainer</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">errorbar</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_container</span><span class="p">(</span><span class="n">bar_container</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">tick_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">tick_labels</span> <span class="o">=</span> <span class="n">make_iterable</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
                <span class="n">tick_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">tick_labels</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">tick_labels</span> <span class="o">*=</span> <span class="n">nbars</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nbars</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;incompatible sizes: argument &#39;tick_label&#39; &quot;</span>
                                 <span class="s2">&quot;must be length </span><span class="si">%d</span><span class="s2"> or string&quot;</span> <span class="o">%</span> <span class="n">nbars</span><span class="p">)</span>

            <span class="n">tick_label_axis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">tick_label_position</span><span class="p">)</span>
            <span class="n">tick_label_axis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="n">tick_labels</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bar_container</span></div>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.barh"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.barh.html#mpl.axes.Axes.barh">[docs]</a>    <span class="k">def</span> <span class="nf">barh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a horizontal bar plot.</span>

<span class="sd">        Make a horizontal bar plot with rectangles bounded by:</span>

<span class="sd">          `left`, `left` + `width`, `bottom`, `bottom` + `height`</span>
<span class="sd">                (left, right, bottom and top edges)</span>

<span class="sd">        `bottom`, `width`, `height`, and `left` can be either scalars</span>
<span class="sd">        or sequences</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bottom : scalar or array-like</span>
<span class="sd">            the y coordinate(s) of the bars</span>

<span class="sd">        width : scalar or array-like</span>
<span class="sd">            the width(s) of the bars</span>

<span class="sd">        height : sequence of scalars, optional, default: 0.8</span>
<span class="sd">            the heights of the bars</span>

<span class="sd">        left : sequence of scalars</span>
<span class="sd">            the x coordinates of the left sides of the bars</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        `matplotlib.patches.Rectangle` instances.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        color : scalar or array-like, optional</span>
<span class="sd">            the colors of the bars</span>

<span class="sd">        edgecolor : scalar or array-like, optional</span>
<span class="sd">            the colors of the bar edges</span>

<span class="sd">        linewidth : scalar or array-like, optional, default: None</span>
<span class="sd">            width of bar edge(s). If None, use default</span>
<span class="sd">            linewidth; If 0, don&#39;t draw edges.</span>

<span class="sd">        tick_label : string or array-like, optional, default: None</span>
<span class="sd">            the tick labels of the bars</span>

<span class="sd">        xerr : scalar or array-like, optional, default: None</span>
<span class="sd">            if not None, will be used to generate errorbar(s) on the bar chart</span>

<span class="sd">        yerr : scalar or array-like, optional, default: None</span>
<span class="sd">            if not None, will be used to generate errorbar(s) on the bar chart</span>

<span class="sd">        ecolor : scalar or array-like, optional, default: None</span>
<span class="sd">            specifies the color of errorbar(s)</span>

<span class="sd">        capsize : scalar, optional</span>
<span class="sd">           determines the length in points of the error bar caps</span>
<span class="sd">           default: None, which will take the value from the</span>
<span class="sd">           ``errorbar.capsize`` :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">        error_kw :</span>
<span class="sd">            dictionary of kwargs to be passed to errorbar method. `ecolor` and</span>
<span class="sd">            `capsize` may be specified here rather than as independent kwargs.</span>

<span class="sd">        align : [&#39;edge&#39; | &#39;center&#39;], optional, default: &#39;edge&#39;</span>
<span class="sd">            If `edge`, aligns bars by their left edges (for vertical bars) and</span>
<span class="sd">            by their bottom edges (for horizontal bars). If `center`, interpret</span>
<span class="sd">            the `left` argument as the coordinates of the centers of the bars.</span>

<span class="sd">        log : boolean, optional, default: False</span>
<span class="sd">            If true, sets the axis to be log scale</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The optional arguments `color`, `edgecolor`, `linewidth`,</span>
<span class="sd">        `xerr`, and `yerr` can be either scalars or sequences of</span>
<span class="sd">        length equal to the number of bars.  This enables you to use</span>
<span class="sd">        bar as the basis for stacked bar charts, or candlestick plots.</span>
<span class="sd">        Detail: `xerr` and `yerr` are passed directly to</span>
<span class="sd">        :meth:`errorbar`, so they can also have shape 2xN for</span>
<span class="sd">        independent specification of lower and upper errors.</span>

<span class="sd">        Other optional kwargs:</span>

<span class="sd">        %(Rectangle)s</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        bar: Plot a vertical bar plot.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                           <span class="n">bottom</span><span class="o">=</span><span class="n">bottom</span><span class="p">,</span> <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">patches</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.broken_barh"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.broken_barh.html#mpl.axes.Axes.broken_barh">[docs]</a>    <span class="k">def</span> <span class="nf">broken_barh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xranges</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot horizontal bars.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          broken_barh(self, xranges, yrange, **kwargs)</span>

<span class="sd">        A collection of horizontal bars spanning *yrange* with a sequence of</span>
<span class="sd">        *xranges*.</span>

<span class="sd">        Required arguments:</span>

<span class="sd">          =========   ==============================</span>
<span class="sd">          Argument    Description</span>
<span class="sd">          =========   ==============================</span>
<span class="sd">          *xranges*   sequence of (*xmin*, *xwidth*)</span>
<span class="sd">          *yrange*    sequence of (*ymin*, *ywidth*)</span>
<span class="sd">          =========   ==============================</span>

<span class="sd">        kwargs are</span>
<span class="sd">        :class:`matplotlib.collections.BrokenBarHCollection`</span>
<span class="sd">        properties:</span>

<span class="sd">        %(BrokenBarHCollection)s</span>

<span class="sd">        these can either be a single argument, i.e.,::</span>

<span class="sd">          facecolors = &#39;black&#39;</span>

<span class="sd">        or a sequence of arguments for the various bars, i.e.,::</span>

<span class="sd">          facecolors = (&#39;black&#39;, &#39;red&#39;, &#39;green&#39;)</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/broken_barh.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># process the unit information</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xranges</span><span class="p">):</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">xranges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xdata</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">yrange</span><span class="p">):</span>
            <span class="n">ydata</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">yrange</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ydata</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">xdata</span><span class="p">,</span>
                                <span class="n">ydata</span><span class="o">=</span><span class="n">ydata</span><span class="p">,</span>
                                <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">xranges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">xranges</span><span class="p">)</span>
        <span class="n">yrange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">yrange</span><span class="p">)</span>

        <span class="n">col</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">BrokenBarHCollection</span><span class="p">(</span><span class="n">xranges</span><span class="p">,</span> <span class="n">yrange</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">col</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_all_args</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<div class="viewcode-block" id="Axes.stem"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.stem.html#mpl.axes.Axes.stem">[docs]</a>    <span class="k">def</span> <span class="nf">stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a stem plot.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">          stem(y, linefmt=&#39;b-&#39;, markerfmt=&#39;bo&#39;, basefmt=&#39;r-&#39;)</span>
<span class="sd">          stem(x, y, linefmt=&#39;b-&#39;, markerfmt=&#39;bo&#39;, basefmt=&#39;r-&#39;)</span>

<span class="sd">        A stem plot plots vertical lines (using *linefmt*) at each *x*</span>
<span class="sd">        location from the baseline to *y*, and places a marker there</span>
<span class="sd">        using *markerfmt*.  A horizontal line at 0 is is plotted using</span>
<span class="sd">        *basefmt*.</span>

<span class="sd">        If no *x* values are provided, the default is (0, 1, ..., len(y) - 1)</span>

<span class="sd">        Return value is a tuple (*markerline*, *stemlines*,</span>
<span class="sd">        *baseline*).</span>

<span class="sd">        .. seealso::</span>
<span class="sd">            This</span>
<span class="sd">            `document &lt;http://www.mathworks.com/help/techdoc/ref/stem.html&gt;`_</span>
<span class="sd">            for details.</span>


<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/stem_plot.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">remember_hold</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="c1"># Assume there&#39;s at least one data array</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Try a second one</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">second</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="c1"># The second array doesn&#39;t make sense, or it doesn&#39;t exist</span>
            <span class="n">second</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">second</span>

        <span class="c1"># Popping some defaults</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">linefmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linefmt&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">linefmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linefmt&#39;</span><span class="p">,</span> <span class="s1">&#39;b-&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">markerfmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;markerfmt&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">markerfmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;markerfmt&#39;</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">basefmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;basefmt&#39;</span><span class="p">,</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">basefmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;basefmt&#39;</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>

        <span class="n">bottom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="n">markerline</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">markerfmt</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">bottom</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">stemlines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">thisx</span><span class="p">,</span> <span class="n">thisy</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
            <span class="n">l</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thisx</span><span class="p">],</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">thisy</span><span class="p">],</span> <span class="n">linefmt</span><span class="p">,</span>
                           <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>
            <span class="n">stemlines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="n">baseline</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)],</span> <span class="p">[</span><span class="n">bottom</span><span class="p">,</span> <span class="n">bottom</span><span class="p">],</span>
                              <span class="n">basefmt</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="n">remember_hold</span><span class="p">)</span>

        <span class="n">stem_container</span> <span class="o">=</span> <span class="n">StemContainer</span><span class="p">((</span><span class="n">markerline</span><span class="p">,</span> <span class="n">stemlines</span><span class="p">,</span> <span class="n">baseline</span><span class="p">),</span>
                                       <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_container</span><span class="p">(</span><span class="n">stem_container</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">stem_container</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;explode&#39;</span><span class="p">,</span> <span class="s1">&#39;labels&#39;</span><span class="p">,</span> <span class="s1">&#39;colors&#39;</span><span class="p">],</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<div class="viewcode-block" id="Axes.pie"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.pie.html#mpl.axes.Axes.pie">[docs]</a>    <span class="k">def</span> <span class="nf">pie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">explode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">autopct</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pctdistance</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span> <span class="n">shadow</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">labeldistance</span><span class="o">=</span><span class="mf">1.1</span><span class="p">,</span>
            <span class="n">startangle</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">counterclock</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">wedgeprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">textprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">frame</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Plot a pie chart.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          pie(x, explode=None, labels=None,</span>
<span class="sd">              colors=(&#39;b&#39;, &#39;g&#39;, &#39;r&#39;, &#39;c&#39;, &#39;m&#39;, &#39;y&#39;, &#39;k&#39;, &#39;w&#39;),</span>
<span class="sd">              autopct=None, pctdistance=0.6, shadow=False,</span>
<span class="sd">              labeldistance=1.1, startangle=None, radius=None,</span>
<span class="sd">              counterclock=True, wedgeprops=None, textprops=None,</span>
<span class="sd">              center = (0, 0), frame = False )</span>

<span class="sd">        Make a pie chart of array *x*.  The fractional area of each</span>
<span class="sd">        wedge is given by x/sum(x).  If sum(x) &lt;= 1, then the values</span>
<span class="sd">        of x give the fractional area directly and the array will not</span>
<span class="sd">        be normalized.  The wedges are plotted counterclockwise,</span>
<span class="sd">        by default starting from the x-axis.</span>

<span class="sd">        Keyword arguments:</span>

<span class="sd">          *explode*: [ *None* | len(x) sequence ]</span>
<span class="sd">            If not *None*, is a ``len(x)`` array which specifies the</span>
<span class="sd">            fraction of the radius with which to offset each wedge.</span>

<span class="sd">          *colors*: [ *None* | color sequence ]</span>
<span class="sd">            A sequence of matplotlib color args through which the pie chart</span>
<span class="sd">            will cycle.</span>

<span class="sd">          *labels*: [ *None* | len(x) sequence of strings ]</span>
<span class="sd">            A sequence of strings providing the labels for each wedge</span>

<span class="sd">          *autopct*: [ *None* | format string | format function ]</span>
<span class="sd">            If not *None*, is a string or function used to label the wedges</span>
<span class="sd">            with their numeric value.  The label will be placed inside the</span>
<span class="sd">            wedge.  If it is a format string, the label will be ``fmt%pct``.</span>
<span class="sd">            If it is a function, it will be called.</span>

<span class="sd">          *pctdistance*: scalar</span>
<span class="sd">            The ratio between the center of each pie slice and the</span>
<span class="sd">            start of the text generated by *autopct*.  Ignored if</span>
<span class="sd">            *autopct* is *None*; default is 0.6.</span>

<span class="sd">          *labeldistance*: scalar</span>
<span class="sd">            The radial distance at which the pie labels are drawn</span>

<span class="sd">          *shadow*: [ *False* | *True* ]</span>
<span class="sd">            Draw a shadow beneath the pie.</span>

<span class="sd">          *startangle*: [ *None* | Offset angle ]</span>
<span class="sd">            If not *None*, rotates the start of the pie chart by *angle*</span>
<span class="sd">            degrees counterclockwise from the x-axis.</span>

<span class="sd">          *radius*: [ *None* | scalar ]</span>
<span class="sd">          The radius of the pie, if *radius* is *None* it will be set to 1.</span>

<span class="sd">          *counterclock*: [ *False* | *True* ]</span>
<span class="sd">            Specify fractions direction, clockwise or counterclockwise.</span>

<span class="sd">          *wedgeprops*: [ *None* | dict of key value pairs ]</span>
<span class="sd">            Dict of arguments passed to the wedge objects making the pie.</span>
<span class="sd">            For example, you can pass in wedgeprops = { &#39;linewidth&#39; : 3 }</span>
<span class="sd">            to set the width of the wedge border lines equal to 3.</span>
<span class="sd">            For more details, look at the doc/arguments of the wedge object.</span>
<span class="sd">            By default `clip_on=False`.</span>

<span class="sd">          *textprops*: [ *None* | dict of key value pairs ]</span>
<span class="sd">            Dict of arguments to pass to the text objects.</span>

<span class="sd">          *center*: [ (0,0) | sequence of 2 scalars ]</span>
<span class="sd">          Center position of the chart.</span>

<span class="sd">          *frame*: [ *False* | *True* ]</span>
<span class="sd">            Plot axes frame with the chart.</span>

<span class="sd">        The pie chart will probably look best if the figure and axes are</span>
<span class="sd">        square, or the Axes aspect is equal.  e.g.::</span>

<span class="sd">          figure(figsize=(8,8))</span>
<span class="sd">          ax = axes([0.1, 0.1, 0.8, 0.8])</span>

<span class="sd">        or::</span>

<span class="sd">          axes(aspect=1)</span>

<span class="sd">        Return value:</span>
<span class="sd">          If *autopct* is *None*, return the tuple (*patches*, *texts*):</span>

<span class="sd">            - *patches* is a sequence of</span>
<span class="sd">              :class:`matplotlib.patches.Wedge` instances</span>

<span class="sd">            - *texts* is a list of the label</span>
<span class="sd">              :class:`matplotlib.text.Text` instances.</span>

<span class="sd">          If *autopct* is not *None*, return the tuple (*patches*,</span>
<span class="sd">          *texts*, *autotexts*), where *patches* and *texts* are as</span>
<span class="sd">          above, and *autotexts* is a list of</span>
<span class="sd">          :class:`~matplotlib.text.Text` instances for the numeric</span>
<span class="sd">          labels.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="n">sx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">sx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">sx</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">labels</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">explode</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">explode</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;label&#39; must be of length &#39;x&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">explode</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;explode&#39; must be of length &#39;x&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">radius</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Starting theta1 is the start fraction of the circle</span>
        <span class="k">if</span> <span class="n">startangle</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">theta1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">theta1</span> <span class="o">=</span> <span class="n">startangle</span> <span class="o">/</span> <span class="mf">360.0</span>

        <span class="c1"># set default values in wedge_prop</span>
        <span class="k">if</span> <span class="n">wedgeprops</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wedgeprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;clip_on&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">wedgeprops</span><span class="p">:</span>
            <span class="n">wedgeprops</span><span class="p">[</span><span class="s1">&#39;clip_on&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">textprops</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">textprops</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s1">&#39;clip_on&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">textprops</span><span class="p">:</span>
            <span class="n">textprops</span><span class="p">[</span><span class="s1">&#39;clip_on&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">texts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">autotexts</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">frac</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">expl</span> <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">explode</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">center</span>
            <span class="n">theta2</span> <span class="o">=</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">+</span> <span class="n">frac</span><span class="p">)</span> <span class="k">if</span> <span class="n">counterclock</span> <span class="k">else</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">-</span> <span class="n">frac</span><span class="p">)</span>
            <span class="n">thetam</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">theta1</span> <span class="o">+</span> <span class="n">theta2</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="n">expl</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">+=</span> <span class="n">expl</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Wedge</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span> <span class="mf">360.</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">),</span>
                            <span class="mf">360.</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">),</span>
                            <span class="n">facecolor</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">colors</span><span class="p">)],</span>
                            <span class="o">**</span><span class="n">wedgeprops</span><span class="p">)</span>
            <span class="n">slices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">w</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">shadow</span><span class="p">:</span>
                <span class="c1"># make sure to add a shadow after the call to</span>
                <span class="c1"># add_patch so the figure and transform props will be</span>
                <span class="c1"># set</span>
                <span class="n">shad</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Shadow</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.02</span><span class="p">)</span>
                <span class="n">shad</span><span class="o">.</span><span class="n">set_zorder</span><span class="p">(</span><span class="mf">0.9</span> <span class="o">*</span> <span class="n">w</span><span class="o">.</span><span class="n">get_zorder</span><span class="p">())</span>
                <span class="n">shad</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">shad</span><span class="p">)</span>

            <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">labeldistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
            <span class="n">yt</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">labeldistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
            <span class="n">label_alignment</span> <span class="o">=</span> <span class="n">xt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s1">&#39;left&#39;</span> <span class="ow">or</span> <span class="s1">&#39;right&#39;</span>

            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span>
                          <span class="n">size</span><span class="o">=</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;xtick.labelsize&#39;</span><span class="p">],</span>
                          <span class="n">horizontalalignment</span><span class="o">=</span><span class="n">label_alignment</span><span class="p">,</span>
                          <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">textprops</span><span class="p">)</span>

            <span class="n">texts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">autopct</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">xt</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">pctdistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="n">yt</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="n">pctdistance</span> <span class="o">*</span> <span class="n">radius</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetam</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">is_string_like</span><span class="p">(</span><span class="n">autopct</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">autopct</span> <span class="o">%</span> <span class="p">(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">autopct</span><span class="p">):</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">autopct</span><span class="p">(</span><span class="mf">100.</span> <span class="o">*</span> <span class="n">frac</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s1">&#39;autopct must be callable or a format string&#39;</span><span class="p">)</span>

                <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span>
                              <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                              <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">textprops</span><span class="p">)</span>

                <span class="n">autotexts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

            <span class="n">theta1</span> <span class="o">=</span> <span class="n">theta2</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">frame</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_frame_on</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="o">-</span><span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                            <span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="o">-</span><span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                            <span class="mf">1.25</span> <span class="o">+</span> <span class="n">center</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>

        <span class="k">if</span> <span class="n">autopct</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">texts</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">slices</span><span class="p">,</span> <span class="n">texts</span><span class="p">,</span> <span class="n">autotexts</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;xerr&quot;</span><span class="p">,</span> <span class="s2">&quot;yerr&quot;</span><span class="p">],</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.errorbar"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.errorbar.html#mpl.axes.Axes.errorbar">[docs]</a>    <span class="k">def</span> <span class="nf">errorbar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">xerr</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ecolor</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">elinewidth</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">capsize</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">barsabove</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">lolims</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">uplims</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">xlolims</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">xuplims</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">errorevery</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">capthick</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot an errorbar graph.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          errorbar(x, y, yerr=None, xerr=None,</span>
<span class="sd">                   fmt=&#39;&#39;, ecolor=None, elinewidth=None, capsize=None,</span>
<span class="sd">                   barsabove=False, lolims=False, uplims=False,</span>
<span class="sd">                   xlolims=False, xuplims=False, errorevery=1,</span>
<span class="sd">                   capthick=None)</span>

<span class="sd">        Plot *x* versus *y* with error deltas in *yerr* and *xerr*.</span>
<span class="sd">        Vertical errorbars are plotted if *yerr* is not *None*.</span>
<span class="sd">        Horizontal errorbars are plotted if *xerr* is not *None*.</span>

<span class="sd">        *x*, *y*, *xerr*, and *yerr* can all be scalars, which plots a</span>
<span class="sd">        single error bar at *x*, *y*.</span>

<span class="sd">        Optional keyword arguments:</span>

<span class="sd">          *xerr*/*yerr*: [ scalar | N, Nx1, or 2xN array-like ]</span>
<span class="sd">            If a scalar number, len(N) array-like object, or an Nx1</span>
<span class="sd">            array-like object, errorbars are drawn at +/-value relative</span>
<span class="sd">            to the data.</span>

<span class="sd">            If a sequence of shape 2xN, errorbars are drawn at -row1</span>
<span class="sd">            and +row2 relative to the data.</span>

<span class="sd">          *fmt*: [ &#39;&#39; | &#39;none&#39; | plot format string ]</span>
<span class="sd">            The plot format symbol. If *fmt* is &#39;none&#39; (case-insensitive),</span>
<span class="sd">            only the errorbars are plotted.  This is used for adding</span>
<span class="sd">            errorbars to a bar plot, for example.  Default is &#39;&#39;,</span>
<span class="sd">            an empty plot format string; properties are</span>
<span class="sd">            then identical to the defaults for :meth:`plot`.</span>

<span class="sd">          *ecolor*: [ *None* | mpl color ]</span>
<span class="sd">            A matplotlib color arg which gives the color the errorbar lines;</span>
<span class="sd">            if *None*, use the color of the line connecting the markers.</span>

<span class="sd">          *elinewidth*: scalar</span>
<span class="sd">            The linewidth of the errorbar lines. If *None*, use the linewidth.</span>

<span class="sd">          *capsize*: scalar</span>
<span class="sd">            The length of the error bar caps in points; if *None*, it will</span>
<span class="sd">            take the value from ``errorbar.capsize``</span>
<span class="sd">            :data:`rcParam&lt;matplotlib.rcParams&gt;`.</span>

<span class="sd">          *capthick*: scalar</span>
<span class="sd">            An alias kwarg to *markeredgewidth* (a.k.a. - *mew*). This</span>
<span class="sd">            setting is a more sensible name for the property that</span>
<span class="sd">            controls the thickness of the error bar cap in points. For</span>
<span class="sd">            backwards compatibility, if *mew* or *markeredgewidth* are given,</span>
<span class="sd">            then they will over-ride *capthick*.  This may change in future</span>
<span class="sd">            releases.</span>

<span class="sd">          *barsabove*: [ *True* | *False* ]</span>
<span class="sd">            if *True*, will plot the errorbars above the plot</span>
<span class="sd">            symbols. Default is below.</span>

<span class="sd">          *lolims* / *uplims* / *xlolims* / *xuplims*: [ *False* | *True* ]</span>
<span class="sd">            These arguments can be used to indicate that a value gives</span>
<span class="sd">            only upper/lower limits. In that case a caret symbol is</span>
<span class="sd">            used to indicate this. lims-arguments may be of the same</span>
<span class="sd">            type as *xerr* and *yerr*.  To use limits with inverted</span>
<span class="sd">            axes, :meth:`set_xlim` or :meth:`set_ylim` must be called</span>
<span class="sd">            before :meth:`errorbar`.</span>

<span class="sd">          *errorevery*: positive integer</span>
<span class="sd">            subsamples the errorbars. e.g., if errorevery=5, errorbars for</span>
<span class="sd">            every 5-th datapoint will be plotted. The data plot itself still</span>
<span class="sd">            shows all data points.</span>

<span class="sd">        All other keyword arguments are passed on to the plot command for the</span>
<span class="sd">        markers. For example, this code makes big red squares with</span>
<span class="sd">        thick green edges::</span>

<span class="sd">          x,y,yerr = rand(3,10)</span>
<span class="sd">          errorbar(x, y, yerr, marker=&#39;s&#39;,</span>
<span class="sd">                   mfc=&#39;red&#39;, mec=&#39;green&#39;, ms=20, mew=4)</span>

<span class="sd">        where *mfc*, *mec*, *ms* and *mew* are aliases for the longer</span>
<span class="sd">        property names, *markerfacecolor*, *markeredgecolor*, *markersize*</span>
<span class="sd">        and *markeredgewith*.</span>

<span class="sd">        valid kwargs for the marker properties are</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        Returns (*plotline*, *caplines*, *barlinecols*):</span>

<span class="sd">            *plotline*: :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">                *x*, *y* plot markers and/or line</span>

<span class="sd">            *caplines*: list of error bar cap</span>
<span class="sd">                :class:`~matplotlib.lines.Line2D` instances</span>
<span class="sd">            *barlinecols*: list of</span>
<span class="sd">                :class:`~matplotlib.collections.LineCollection` instances for</span>
<span class="sd">                the horizontal and vertical error ranges.</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/statistics/errorbar_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">errorevery</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;errorevery has to be a strictly positive integer&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">holdstate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">fmt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fmt</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Use of None object as fmt keyword argument to &#39;</span>
                   <span class="o">+</span> <span class="s1">&#39;suppress plotting of data values is deprecated &#39;</span>
                   <span class="o">+</span> <span class="s1">&#39;since 1.4; use the string &quot;none&quot; instead.&#39;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">mplDeprecation</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">plot_line</span> <span class="o">=</span> <span class="p">(</span><span class="n">fmt</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;none&#39;</span><span class="p">)</span>

        <span class="n">label</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="c1"># make sure all the args are iterable; use lists not arrays to</span>
        <span class="c1"># preserve units</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">xerr</span><span class="p">):</span>
                <span class="n">xerr</span> <span class="o">=</span> <span class="p">[</span><span class="n">xerr</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">yerr</span><span class="p">):</span>
                <span class="n">yerr</span> <span class="o">=</span> <span class="p">[</span><span class="n">yerr</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">l0</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c1"># Instead of using zorder, the line plot is being added</span>
        <span class="c1"># either here, or after all the errorbar plot elements.</span>
        <span class="k">if</span> <span class="n">barsabove</span> <span class="ow">and</span> <span class="n">plot_line</span><span class="p">:</span>
            <span class="n">l0</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;_nolegend_&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">barcols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">caplines</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">lines_kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;_nolegend_&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">elinewidth</span><span class="p">:</span>
            <span class="n">lines_kw</span><span class="p">[</span><span class="s1">&#39;linewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">elinewidth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">,</span> <span class="s1">&#39;lw&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="n">lines_kw</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="s1">&#39;rasterized&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">lines_kw</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1"># arrays fine here, they are booleans and hence not units</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">lolims</span><span class="p">):</span>
            <span class="n">lolims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">lolims</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lolims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">lolims</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">uplims</span><span class="p">):</span>
            <span class="n">uplims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">uplims</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">uplims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">uplims</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">xlolims</span><span class="p">):</span>
            <span class="n">xlolims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xlolims</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xlolims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xlolims</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">xuplims</span><span class="p">):</span>
            <span class="n">xuplims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xuplims</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xuplims</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xuplims</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>

        <span class="n">everymask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">%</span> <span class="n">errorevery</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="k">def</span> <span class="nf">xywhere</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            return xs[mask], ys[mask] where mask is True but xs and</span>
<span class="sd">            ys are not arrays</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ys</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="k">for</span> <span class="n">thisx</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">]</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisy</span> <span class="k">for</span> <span class="n">thisy</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ys</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span> <span class="k">if</span> <span class="n">b</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span>

        <span class="n">plot_kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">:</span> <span class="s1">&#39;_nolegend_&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">capsize</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">capsize</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s2">&quot;errorbar.capsize&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">plot_kw</span><span class="p">[</span><span class="s1">&#39;ms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.</span> <span class="o">*</span> <span class="n">capsize</span>
        <span class="k">if</span> <span class="n">capthick</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># &#39;mew&#39; has higher priority, I believe,</span>
            <span class="c1"># if both &#39;mew&#39; and &#39;markeredgewidth&#39; exists.</span>
            <span class="c1"># So, save capthick to markeredgewidth so that</span>
            <span class="c1"># explicitly setting mew or markeredgewidth will</span>
            <span class="c1"># over-write capthick.</span>
            <span class="n">plot_kw</span><span class="p">[</span><span class="s1">&#39;markeredgewidth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">capthick</span>
        <span class="c1"># For backwards-compat, allow explicit setting of</span>
        <span class="c1"># &#39;mew&#39; or &#39;markeredgewidth&#39; to over-ride capthick.</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;markeredgewidth&#39;</span><span class="p">,</span> <span class="s1">&#39;mew&#39;</span><span class="p">,</span> <span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="s1">&#39;rasterized&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">plot_kw</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iterable</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                    <span class="n">iterable</span><span class="p">(</span><span class="n">xerr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">iterable</span><span class="p">(</span><span class="n">xerr</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="c1"># using list comps rather than arrays to preserve units</span>
                <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="o">-</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                        <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xerr</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="o">+</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                         <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xerr</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if xerr is scalar or symmetric. Asymmetric is handled</span>
                <span class="c1"># above. This prevents Nx2 arrays from accidentally</span>
                <span class="c1"># being accepted, when the user meant the 2xN transpose.</span>
                <span class="c1"># special case for empty lists</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">xerr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                        <span class="n">iterable</span><span class="p">(</span><span class="n">xerr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">xerr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xerr must be a scalar, the same &quot;</span>
                                     <span class="s2">&quot;dimensions as x, or 2xN.&quot;</span><span class="p">)</span>
                <span class="c1"># using list comps rather than arrays to preserve units</span>
                <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="o">-</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                        <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xerr</span><span class="p">)]</span>
                <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisx</span> <span class="o">+</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisx</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                         <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xerr</span><span class="p">)]</span>

            <span class="c1"># select points without upper/lower limits in x and</span>
            <span class="c1"># draw normal errorbars for these points</span>
            <span class="n">noxlims</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">xlolims</span> <span class="o">|</span> <span class="n">xuplims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">noxlims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">yo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">noxlims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">noxlims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">lines_kw</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="s1">&#39;k|&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ro</span><span class="p">,</span> <span class="n">yo</span><span class="p">,</span> <span class="s1">&#39;k|&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">xlolims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">yo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">lines_kw</span><span class="p">))</span>
                <span class="n">rightup</span><span class="p">,</span> <span class="n">yup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETLEFT</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETRIGHT</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">rightup</span><span class="p">,</span> <span class="n">yup</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xlolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span><span class="p">,</span> <span class="s1">&#39;k|&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">xuplims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">yo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hlines</span><span class="p">(</span><span class="n">yo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">lines_kw</span><span class="p">))</span>
                <span class="n">leftlo</span><span class="p">,</span> <span class="n">ylo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETRIGHT</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETLEFT</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">leftlo</span><span class="p">,</span>  <span class="n">ylo</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xup</span><span class="p">,</span> <span class="n">yup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">xuplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xup</span><span class="p">,</span> <span class="n">yup</span><span class="p">,</span> <span class="s1">&#39;k|&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">iterable</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                    <span class="n">iterable</span><span class="p">(</span><span class="n">yerr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">iterable</span><span class="p">(</span><span class="n">yerr</span><span class="p">[</span><span class="mi">1</span><span class="p">])):</span>
                <span class="c1"># using list comps rather than arrays to preserve units</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisy</span> <span class="o">-</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisy</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                         <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisy</span> <span class="o">+</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisy</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                         <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check for scalar or symmetric, as in xerr.</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">yerr</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span>
                        <span class="n">iterable</span><span class="p">(</span><span class="n">yerr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">yerr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;yerr must be a scalar, the same &quot;</span>
                                     <span class="s2">&quot;dimensions as y, or 2xN.&quot;</span><span class="p">)</span>
                <span class="c1"># using list comps rather than arrays to preserve units</span>
                <span class="n">lower</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisy</span> <span class="o">-</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisy</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                         <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="p">)]</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="p">[</span><span class="n">thisy</span> <span class="o">+</span> <span class="n">thiserr</span> <span class="k">for</span> <span class="p">(</span><span class="n">thisy</span><span class="p">,</span> <span class="n">thiserr</span><span class="p">)</span>
                         <span class="ow">in</span> <span class="n">cbook</span><span class="o">.</span><span class="n">safezip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">yerr</span><span class="p">)]</span>

            <span class="c1"># select points without upper/lower limits in y and</span>
            <span class="c1"># draw normal errorbars for these points</span>
            <span class="n">noylims</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">lolims</span> <span class="o">|</span> <span class="n">uplims</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">noylims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">xo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">noylims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">noylims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="o">**</span><span class="n">lines_kw</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="s1">&#39;k_&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="s1">&#39;k_&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">lolims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">xo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="o">**</span><span class="n">lines_kw</span><span class="p">))</span>
                <span class="n">xup</span><span class="p">,</span> <span class="n">upperup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETDOWN</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETUP</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xup</span><span class="p">,</span> <span class="n">upperup</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lolims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">ylo</span><span class="p">,</span> <span class="s1">&#39;k_&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">uplims</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">xo</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="n">barcols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vlines</span><span class="p">(</span><span class="n">xo</span><span class="p">,</span> <span class="n">lo</span><span class="p">,</span> <span class="n">uo</span><span class="p">,</span> <span class="o">**</span><span class="n">lines_kw</span><span class="p">))</span>
                <span class="n">xlo</span><span class="p">,</span> <span class="n">lowerlo</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis_inverted</span><span class="p">():</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETUP</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">marker</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">CARETDOWN</span>
                <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xlo</span><span class="p">,</span> <span class="n">lowerlo</span><span class="p">,</span> <span class="n">ls</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span>
                              <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">capsize</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xup</span><span class="p">,</span> <span class="n">yup</span> <span class="o">=</span> <span class="n">xywhere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">uplims</span> <span class="o">&amp;</span> <span class="n">everymask</span><span class="p">)</span>
                    <span class="n">caplines</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xup</span><span class="p">,</span> <span class="n">yup</span><span class="p">,</span> <span class="s1">&#39;k_&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kw</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">barsabove</span> <span class="ow">and</span> <span class="n">plot_line</span><span class="p">:</span>
            <span class="n">l0</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ecolor</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l0</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">_prop_keys</span><span class="p">:</span>
                <span class="n">ecolor</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">prop_cycler</span><span class="p">)[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ecolor</span> <span class="o">=</span> <span class="n">l0</span><span class="o">.</span><span class="n">get_color</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">barcols</span><span class="p">:</span>
            <span class="n">l</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ecolor</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">caplines</span><span class="p">:</span>
            <span class="n">l</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">ecolor</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span> <span class="o">=</span> <span class="n">holdstate</span>

        <span class="n">errorbar_container</span> <span class="o">=</span> <span class="n">ErrorbarContainer</span><span class="p">((</span><span class="n">l0</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">caplines</span><span class="p">),</span>
                                                <span class="nb">tuple</span><span class="p">(</span><span class="n">barcols</span><span class="p">)),</span>
                                               <span class="n">has_xerr</span><span class="o">=</span><span class="p">(</span><span class="n">xerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">),</span>
                                               <span class="n">has_yerr</span><span class="o">=</span><span class="p">(</span><span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">),</span>
                                               <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">containers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">errorbar_container</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">errorbar_container</span>  <span class="c1"># (l0, caplines, barcols)</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<div class="viewcode-block" id="Axes.boxplot"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.boxplot.html#mpl.axes.Axes.boxplot">[docs]</a>    <span class="k">def</span> <span class="nf">boxplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">notch</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">whis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">positions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">bootstrap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">usermedians</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">conf_intervals</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">meanline</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">showcaps</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">showbox</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">boxprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">flierprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">medianprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">meanprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">capprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">manage_xticks</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a box and whisker plot.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          boxplot(self, x, notch=None, sym=None, vert=None, whis=None,</span>
<span class="sd">                  positions=None, widths=None, patch_artist=False,</span>
<span class="sd">                  bootstrap=None, usermedians=None, conf_intervals=None,</span>
<span class="sd">                  meanline=False, showmeans=False, showcaps=True,</span>
<span class="sd">                  showbox=True, showfliers=True, boxprops=None, labels=None,</span>
<span class="sd">                  flierprops=None, medianprops=None, meanprops=None,</span>
<span class="sd">                  capprops=None, whiskerprops=None, manage_xticks=True):</span>

<span class="sd">        Make a box and whisker plot for each column of *x* or each</span>
<span class="sd">        vector in sequence *x*.  The box extends from the lower to</span>
<span class="sd">        upper quartile values of the data, with a line at the median.</span>
<span class="sd">        The whiskers extend from the box to show the range of the</span>
<span class="sd">        data.  Flier points are those past the end of the whiskers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : Array or a sequence of vectors.</span>
<span class="sd">           The input data.</span>

<span class="sd">        notch : bool, default = False</span>
<span class="sd">           If False, produces a rectangular box plot.</span>
<span class="sd">           If True, will produce a notched box plot</span>

<span class="sd">        sym : str or None, default = None</span>
<span class="sd">           The default symbol for flier points.</span>
<span class="sd">           Enter an empty string (&#39;&#39;) if you don&#39;t want to show fliers.</span>
<span class="sd">           If `None`, then the fliers default to &#39;b+&#39;  If you want more</span>
<span class="sd">           control use the flierprops kwarg.</span>

<span class="sd">        vert : bool, default = True</span>
<span class="sd">           If True (default), makes the boxes vertical.</span>
<span class="sd">           If False, makes horizontal boxes.</span>

<span class="sd">        whis : float, sequence (default = 1.5) or string</span>
<span class="sd">           As a float, determines the reach of the whiskers past the first</span>
<span class="sd">           and third quartiles (e.g., Q3 + whis*IQR, IQR = interquartile</span>
<span class="sd">           range, Q3-Q1). Beyond the whiskers, data are considered outliers</span>
<span class="sd">           and are plotted as individual points. Set this to an unreasonably</span>
<span class="sd">           high value to force the whiskers to show the min and max values.</span>
<span class="sd">           Alternatively, set this to an ascending sequence of percentile</span>
<span class="sd">           (e.g., [5, 95]) to set the whiskers at specific percentiles of</span>
<span class="sd">           the data. Finally, *whis* can be the string &#39;range&#39; to force the</span>
<span class="sd">           whiskers to the min and max of the data. In the edge case that</span>
<span class="sd">           the 25th and 75th percentiles are equivalent, *whis* will be</span>
<span class="sd">           automatically set to &#39;range&#39;.</span>

<span class="sd">        bootstrap : None (default) or integer</span>
<span class="sd">           Specifies whether to bootstrap the confidence intervals</span>
<span class="sd">           around the median for notched boxplots. If bootstrap==None,</span>
<span class="sd">           no bootstrapping is performed, and notches are calculated</span>
<span class="sd">           using a Gaussian-based asymptotic approximation  (see McGill, R.,</span>
<span class="sd">           Tukey, J.W., and Larsen, W.A., 1978, and Kendall and Stuart,</span>
<span class="sd">           1967). Otherwise, bootstrap specifies the number of times to</span>
<span class="sd">           bootstrap the median to determine it&#39;s 95% confidence intervals.</span>
<span class="sd">           Values between 1000 and 10000 are recommended.</span>

<span class="sd">        usermedians : array-like or None (default)</span>
<span class="sd">           An array or sequence whose first dimension (or length) is</span>
<span class="sd">           compatible with *x*. This overrides the medians computed by</span>
<span class="sd">           matplotlib for each element of *usermedians* that is not None.</span>
<span class="sd">           When an element of *usermedians* == None, the median will be</span>
<span class="sd">           computed by matplotlib as normal.</span>

<span class="sd">        conf_intervals : array-like or None (default)</span>
<span class="sd">           Array or sequence whose first dimension (or length) is compatible</span>
<span class="sd">           with *x* and whose second dimension is 2. When the current element</span>
<span class="sd">           of *conf_intervals* is not None, the notch locations computed by</span>
<span class="sd">           matplotlib are overridden (assuming notch is True). When an</span>
<span class="sd">           element of *conf_intervals* is None, boxplot compute notches the</span>
<span class="sd">           method specified by the other kwargs (e.g., *bootstrap*).</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">           Sets the positions of the boxes. The ticks and limits</span>
<span class="sd">           are automatically set to match the positions.</span>

<span class="sd">        widths : array-like, default = 0.5</span>
<span class="sd">           Either a scalar or a vector and sets the width of each box. The</span>
<span class="sd">           default is 0.5, or ``0.15*(distance between extreme positions)``</span>
<span class="sd">           if that is smaller.</span>

<span class="sd">        labels : sequence or None (default)</span>
<span class="sd">           Labels for each dataset. Length must be compatible with</span>
<span class="sd">           dimensions  of *x*</span>

<span class="sd">        patch_artist : bool, default = False</span>
<span class="sd">           If False produces boxes with the Line2D artist</span>
<span class="sd">           If True produces boxes with the Patch artist</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">           If True, will toggle one the rendering of the means</span>

<span class="sd">        showcaps : bool, default = True</span>
<span class="sd">           If True, will toggle one the rendering of the caps</span>

<span class="sd">        showbox : bool, default = True</span>
<span class="sd">           If True, will toggle one the rendering of box</span>

<span class="sd">        showfliers : bool, default = True</span>
<span class="sd">           If True, will toggle one the rendering of the fliers</span>

<span class="sd">        boxprops : dict or None (default)</span>
<span class="sd">           If provided, will set the plotting style of the boxes</span>

<span class="sd">        whiskerprops : dict or None (default)</span>
<span class="sd">           If provided, will set the plotting style of the whiskers</span>

<span class="sd">        capprops : dict or None (default)</span>
<span class="sd">           If provided, will set the plotting style of the caps</span>

<span class="sd">        flierprops : dict or None (default)</span>
<span class="sd">           If provided, will set the plotting style of the fliers</span>

<span class="sd">        medianprops : dict or None (default)</span>
<span class="sd">           If provided, will set the plotting style of the medians</span>

<span class="sd">        meanprops : dict or None (default)</span>
<span class="sd">            If provided, will set the plotting style of the means</span>

<span class="sd">        meanline : bool, default = False</span>
<span class="sd">            If True (and *showmeans* is True), will try to render the mean</span>
<span class="sd">            as a line spanning the full width of the box according to</span>
<span class="sd">            *meanprops*. Not recommended if *shownotches* is also True.</span>
<span class="sd">            Otherwise, means will be shown as points.</span>

<span class="sd">        manage_xticks : bool, default = True</span>
<span class="sd">            If the function should adjust the xlim and xtick locations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        result : dict</span>
<span class="sd">            A dictionary mapping each component of the boxplot</span>
<span class="sd">            to a list of the :class:`matplotlib.lines.Line2D`</span>
<span class="sd">            instances created. That dictionary has the following keys</span>
<span class="sd">            (assuming vertical boxplots):</span>

<span class="sd">            - boxes: the main body of the boxplot showing the quartiles</span>
<span class="sd">              and the median&#39;s confidence intervals if enabled.</span>
<span class="sd">            - medians: horizonal lines at the median of each box.</span>
<span class="sd">            - whiskers: the vertical lines extending to the most extreme,</span>
<span class="sd">              n-outlier data points.</span>
<span class="sd">            - caps: the horizontal lines at the ends of the whiskers.</span>
<span class="sd">            - fliers: points representing data that extend beyond the</span>
<span class="sd">              whiskers (outliers).</span>
<span class="sd">            - means: points or lines representing the means.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: mpl_examples/statistics/boxplot_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If defined in matplotlibrc, apply the value from rc file</span>
        <span class="c1"># Overridden if argument is passed</span>
        <span class="k">if</span> <span class="n">whis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">whis</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.whiskers&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">bootstrap</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">bootstrap</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.bootstrap&#39;</span><span class="p">]</span>
        <span class="n">bxpstats</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">boxplot_stats</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">whis</span><span class="o">=</span><span class="n">whis</span><span class="p">,</span> <span class="n">bootstrap</span><span class="o">=</span><span class="n">bootstrap</span><span class="p">,</span>
                                       <span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">notch</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">notch</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.notch&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">vert</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">vert</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.vertical&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">patch_artist</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">patch_artist</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.patchartist&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">meanline</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">meanline</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.meanline&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showmeans</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">showmeans</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showmeans&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showcaps</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">showcaps</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showcaps&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showbox</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">showbox</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showbox&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">showfliers</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">showfliers</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;boxplot.showfliers&#39;</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">_update_dict</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">rc_name</span><span class="p">,</span> <span class="n">properties</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot; Loads properties in the dictionary from rc file if not already</span>
<span class="sd">            in the dictionary&quot;&quot;&quot;</span>
            <span class="n">rc_str</span> <span class="o">=</span> <span class="s1">&#39;boxplot.{0}.{1}&#39;</span>
            <span class="k">if</span> <span class="n">dictionary</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">dictionary</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">prop_dict</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                <span class="n">dictionary</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">prop_dict</span><span class="p">,</span>
                                <span class="n">rcParams</span><span class="p">[</span><span class="n">rc_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rc_name</span><span class="p">,</span> <span class="n">prop_dict</span><span class="p">)])</span>
            <span class="k">return</span> <span class="n">dictionary</span>

        <span class="c1"># Common property dictionnaries loading from rc</span>
        <span class="n">flier_props</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;marker&#39;</span><span class="p">,</span> <span class="s1">&#39;markerfacecolor&#39;</span><span class="p">,</span> <span class="s1">&#39;markeredgecolor&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;markersize&#39;</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">,</span> <span class="s1">&#39;linewidth&#39;</span><span class="p">]</span>
        <span class="n">default_props</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="s1">&#39;linewidth&#39;</span><span class="p">,</span> <span class="s1">&#39;linestyle&#39;</span><span class="p">]</span>

        <span class="n">boxprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">boxprops</span><span class="p">,</span> <span class="s1">&#39;boxprops&#39;</span><span class="p">,</span> <span class="n">default_props</span><span class="p">)</span>
        <span class="n">whiskerprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">whiskerprops</span><span class="p">,</span> <span class="s1">&#39;whiskerprops&#39;</span><span class="p">,</span>
                                                            <span class="n">default_props</span><span class="p">)</span>
        <span class="n">capprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">capprops</span><span class="p">,</span> <span class="s1">&#39;capprops&#39;</span><span class="p">,</span> <span class="n">default_props</span><span class="p">)</span>
        <span class="n">medianprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">medianprops</span><span class="p">,</span> <span class="s1">&#39;medianprops&#39;</span><span class="p">,</span> <span class="n">default_props</span><span class="p">)</span>
        <span class="n">meanprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">meanprops</span><span class="p">,</span> <span class="s1">&#39;meanprops&#39;</span><span class="p">,</span> <span class="n">default_props</span><span class="p">)</span>
        <span class="n">flierprops</span> <span class="o">=</span> <span class="n">_update_dict</span><span class="p">(</span><span class="n">flierprops</span><span class="p">,</span> <span class="s1">&#39;flierprops&#39;</span><span class="p">,</span> <span class="n">flier_props</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
            <span class="n">boxprops</span><span class="p">[</span><span class="s1">&#39;linestyle&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;solid&#39;</span>
            <span class="n">boxprops</span><span class="p">[</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">boxprops</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">)</span>

        <span class="c1"># if non-default sym value, put it into the flier dictionary</span>
        <span class="c1"># the logic for providing the default symbol (&#39;b+&#39;) now lives</span>
        <span class="c1"># in bxp in the initial value of final_flierprops</span>
        <span class="c1"># handle all of the `sym` related logic here so we only have to pass</span>
        <span class="c1"># on the flierprops dict.</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># no-flier case, which should really be done with</span>
            <span class="c1"># &#39;showfliers=False&#39; but none-the-less deal with it to keep back</span>
            <span class="c1"># compatibility</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="c1"># blow away existing dict and make one for invisible markers</span>
                <span class="n">flierprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
                <span class="c1"># turn the fliers off just to be safe</span>
                <span class="n">showfliers</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="c1"># now process the symbol string</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># process the symbol string</span>
                <span class="c1"># discarded linestyle</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">marker</span><span class="p">,</span> <span class="n">color</span> <span class="o">=</span> <span class="n">_process_plot_format</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
                <span class="c1"># if we have a marker, use it</span>
                <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;marker&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">marker</span>
                <span class="c1"># if we have a color, use it</span>
                <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># assume that if color is passed in the user want</span>
                    <span class="c1"># filled symbol, if the users want more control use</span>
                    <span class="c1"># flierprops</span>
                    <span class="n">flierprops</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>

        <span class="c1"># replace medians if necessary:</span>
        <span class="k">if</span> <span class="n">usermedians</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">usermedians</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">usermedians</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)):</span>
                <span class="n">medmsg</span> <span class="o">=</span> <span class="s1">&#39;usermedians length not compatible with x&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">medmsg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># reassign medians as necessary</span>
                <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">med</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">usermedians</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">med</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">med</span>

        <span class="k">if</span> <span class="n">conf_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">conf_intervals</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">):</span>
                <span class="n">err_mess</span> <span class="o">=</span> <span class="s1">&#39;conf_intervals length not compatible with x&#39;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_mess</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">ci</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">conf_intervals</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">ci</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ci</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;each confidence interval must &#39;</span>
                                             <span class="s1">&#39;have two values&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cilo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">ci</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                                <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cihi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ci</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">artists</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bxp</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span>
                           <span class="n">vert</span><span class="o">=</span><span class="n">vert</span><span class="p">,</span> <span class="n">patch_artist</span><span class="o">=</span><span class="n">patch_artist</span><span class="p">,</span>
                           <span class="n">shownotches</span><span class="o">=</span><span class="n">notch</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="n">showmeans</span><span class="p">,</span>
                           <span class="n">showcaps</span><span class="o">=</span><span class="n">showcaps</span><span class="p">,</span> <span class="n">showbox</span><span class="o">=</span><span class="n">showbox</span><span class="p">,</span>
                           <span class="n">boxprops</span><span class="o">=</span><span class="n">boxprops</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="n">flierprops</span><span class="p">,</span>
                           <span class="n">medianprops</span><span class="o">=</span><span class="n">medianprops</span><span class="p">,</span> <span class="n">meanprops</span><span class="o">=</span><span class="n">meanprops</span><span class="p">,</span>
                           <span class="n">meanline</span><span class="o">=</span><span class="n">meanline</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="n">showfliers</span><span class="p">,</span>
                           <span class="n">capprops</span><span class="o">=</span><span class="n">capprops</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="n">whiskerprops</span><span class="p">,</span>
                           <span class="n">manage_xticks</span><span class="o">=</span><span class="n">manage_xticks</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">artists</span></div>

<div class="viewcode-block" id="Axes.bxp"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.bxp.html#mpl.axes.Axes.bxp">[docs]</a>    <span class="k">def</span> <span class="nf">bxp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bxpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">patch_artist</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">shownotches</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">showcaps</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">showbox</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">showfliers</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
            <span class="n">boxprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">whiskerprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">flierprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">medianprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">capprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">meanprops</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">meanline</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">manage_xticks</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drawing function for box and whisker plots.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          bxp(self, bxpstats, positions=None, widths=None, vert=True,</span>
<span class="sd">              patch_artist=False, shownotches=False, showmeans=False,</span>
<span class="sd">              showcaps=True, showbox=True, showfliers=True,</span>
<span class="sd">              boxprops=None, whiskerprops=None, flierprops=None,</span>
<span class="sd">              medianprops=None, capprops=None, meanprops=None,</span>
<span class="sd">              meanline=False, manage_xticks=True):</span>

<span class="sd">        Make a box and whisker plot for each column of *x* or each</span>
<span class="sd">        vector in sequence *x*.  The box extends from the lower to</span>
<span class="sd">        upper quartile values of the data, with a line at the median.</span>
<span class="sd">        The whiskers extend from the box to show the range of the</span>
<span class="sd">        data.  Flier points are those past the end of the whiskers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        bxpstats : list of dicts</span>
<span class="sd">          A list of dictionaries containing stats for each boxplot.</span>
<span class="sd">          Required keys are:</span>

<span class="sd">          - ``med``: The median (scalar float).</span>

<span class="sd">          - ``q1``: The first quartile (25th percentile) (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          - ``q3``: The third quartile (75th percentile) (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          - ``whislo``: Lower bound of the lower whisker (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          - ``whishi``: Upper bound of the upper whisker (scalar</span>
<span class="sd">            float).</span>

<span class="sd">          Optional keys are:</span>

<span class="sd">          - ``mean``: The mean (scalar float). Needed if</span>
<span class="sd">            ``showmeans=True``.</span>

<span class="sd">          - ``fliers``: Data beyond the whiskers (sequence of floats).</span>
<span class="sd">            Needed if ``showfliers=True``.</span>

<span class="sd">          - ``cilo`` &amp; ``cihi``: Lower and upper confidence intervals</span>
<span class="sd">            about the median. Needed if ``shownotches=True``.</span>

<span class="sd">          - ``label``: Name of the dataset (string). If available,</span>
<span class="sd">            this will be used a tick label for the boxplot</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">          Sets the positions of the boxes. The ticks and limits</span>
<span class="sd">          are automatically set to match the positions.</span>

<span class="sd">        widths : array-like, default = 0.5</span>
<span class="sd">          Either a scalar or a vector and sets the width of each</span>
<span class="sd">          box. The default is 0.5, or ``0.15*(distance between extreme</span>
<span class="sd">          positions)`` if that is smaller.</span>

<span class="sd">        vert : bool, default = False</span>
<span class="sd">          If `True` (default), makes the boxes vertical.  If `False`,</span>
<span class="sd">          makes horizontal boxes.</span>

<span class="sd">        patch_artist : bool, default = False</span>
<span class="sd">          If `False` produces boxes with the</span>
<span class="sd">          `~matplotlib.lines.Line2D` artist.  If `True` produces boxes</span>
<span class="sd">          with the `~matplotlib.patches.Patch` artist.</span>

<span class="sd">        shownotches : bool, default = False</span>
<span class="sd">          If `False` (default), produces a rectangular box plot.</span>
<span class="sd">          If `True`, will produce a notched box plot</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">          If `True`, will toggle one the rendering of the means</span>

<span class="sd">        showcaps  : bool, default = True</span>
<span class="sd">          If `True`, will toggle one the rendering of the caps</span>

<span class="sd">        showbox  : bool, default = True</span>
<span class="sd">          If `True`, will toggle one the rendering of box</span>

<span class="sd">        showfliers : bool, default = True</span>
<span class="sd">          If `True`, will toggle one the rendering of the fliers</span>

<span class="sd">        boxprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the boxes</span>

<span class="sd">        whiskerprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the whiskers</span>

<span class="sd">        capprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the caps</span>

<span class="sd">        flierprops : dict or None (default)</span>
<span class="sd">          If provided will set the plotting style of the fliers</span>

<span class="sd">        medianprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the medians</span>

<span class="sd">        meanprops : dict or None (default)</span>
<span class="sd">          If provided, will set the plotting style of the means</span>

<span class="sd">        meanline : bool, default = False</span>
<span class="sd">          If `True` (and *showmeans* is `True`), will try to render the mean</span>
<span class="sd">          as a line spanning the full width of the box according to</span>
<span class="sd">          *meanprops*. Not recommended if *shownotches* is also True.</span>
<span class="sd">          Otherwise, means will be shown as points.</span>

<span class="sd">        manage_xticks : bool, default = True</span>
<span class="sd">          If the function should adjust the xlim and xtick locations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the boxplot to a list</span>
<span class="sd">          of the :class:`matplotlib.lines.Line2D` instances</span>
<span class="sd">          created. That dictionary has the following keys (assuming</span>
<span class="sd">          vertical boxplots):</span>

<span class="sd">          - ``boxes``: the main body of the boxplot showing the</span>
<span class="sd">            quartiles and the median&#39;s confidence intervals if</span>
<span class="sd">            enabled.</span>

<span class="sd">          - ``medians``: horizonal lines at the median of each box.</span>

<span class="sd">          - ``whiskers``: the vertical lines extending to the most</span>
<span class="sd">            extreme, n-outlier data points.</span>

<span class="sd">          - ``caps``: the horizontal lines at the ends of the</span>
<span class="sd">            whiskers.</span>

<span class="sd">          - ``fliers``: points representing data that extend beyond</span>
<span class="sd">            the whiskers (fliers).</span>

<span class="sd">          - ``means``: points or lines representing the means.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: mpl_examples/statistics/bxp_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># lists of artists to be output</span>
        <span class="n">whiskers</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">caps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fliers</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># empty list of xticklabels</span>
        <span class="n">datalabels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># translates between line2D and patch linestyles</span>
        <span class="n">linestyle_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;solid&#39;</span><span class="p">:</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span>
            <span class="s1">&#39;dashed&#39;</span><span class="p">:</span> <span class="s1">&#39;--&#39;</span><span class="p">,</span>
            <span class="s1">&#39;dashdot&#39;</span><span class="p">:</span> <span class="s1">&#39;-.&#39;</span><span class="p">,</span>
            <span class="s1">&#39;dotted&#39;</span><span class="p">:</span> <span class="s1">&#39;:&#39;</span>
        <span class="p">}</span>

        <span class="c1"># box properties</span>
        <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
            <span class="n">final_boxprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
                                  <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_boxprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">boxprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">final_boxprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">boxprops</span><span class="p">)</span>

        <span class="c1"># other (cap, whisker) properties</span>
        <span class="n">final_whiskerprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">final_capprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span>
            <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">capprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">final_capprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">capprops</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">whiskerprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">final_whiskerprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">whiskerprops</span><span class="p">)</span>

        <span class="c1"># set up the default flier properties</span>
        <span class="n">final_flierprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">)</span>

        <span class="c1"># flier (outlier) properties</span>
        <span class="k">if</span> <span class="n">flierprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">final_flierprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">flierprops</span><span class="p">)</span>

        <span class="c1"># median line properties</span>
        <span class="n">final_medianprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">medianprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">final_medianprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">medianprops</span><span class="p">)</span>

        <span class="c1"># mean (line or point) properties</span>
        <span class="k">if</span> <span class="n">meanline</span><span class="p">:</span>
            <span class="n">final_meanprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">final_meanprops</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">markerfacecolor</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span>
                                   <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meanprops</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">final_meanprops</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">meanprops</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">to_vc</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
            <span class="c1"># convert arguments to verts and codes</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c1">#codes = []</span>
            <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">):</span>
                <span class="n">verts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">))</span>
            <span class="n">verts</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1"># ignored</span>
            <span class="n">codes</span> <span class="o">=</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">MOVETO</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">LINETO</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> \
                    <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="o">.</span><span class="n">CLOSEPOLY</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">verts</span><span class="p">,</span> <span class="n">codes</span>

        <span class="k">def</span> <span class="nf">patch_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">verts</span><span class="p">,</span> <span class="n">codes</span> <span class="o">=</span> <span class="n">to_vc</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">codes</span><span class="p">)</span>
            <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">PathPatch</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">patch</span><span class="p">]</span>

        <span class="c1"># vertical or horizontal plot?</span>
        <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">doplot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">dopatch</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">patch_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">doplot</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">shuffled</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">shuffled</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">shuffled</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">dopatch</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">ys</span><span class="p">,</span> <span class="n">xs</span>  <span class="c1"># flip X, Y</span>
                <span class="k">return</span> <span class="n">patch_list</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># input validation</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bxpstats</span><span class="p">)</span>
        <span class="n">datashape_message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;List of boxplot statistics and `{0}` &quot;</span>
                             <span class="s2">&quot;values must have same the length&quot;</span><span class="p">)</span>
        <span class="c1"># check position</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;positions&quot;</span><span class="p">))</span>

        <span class="c1"># width</span>
        <span class="k">if</span> <span class="n">widths</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">-</span> <span class="nb">min</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="mf">0.15</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">)]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">widths</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;widths&quot;</span><span class="p">))</span>

        <span class="c1"># check and save the `hold` state of the current axes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">holdStatus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span>
        <span class="k">for</span> <span class="n">pos</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">stats</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">,</span> <span class="n">bxpstats</span><span class="p">):</span>
            <span class="c1"># try to find a new label</span>
            <span class="n">datalabels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
            <span class="c1"># fliers coords</span>
            <span class="n">flier_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;fliers&#39;</span><span class="p">]))</span> <span class="o">*</span> <span class="n">pos</span>
            <span class="n">flier_y</span> <span class="o">=</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;fliers&#39;</span><span class="p">]</span>

            <span class="c1"># whisker coords</span>
            <span class="n">whisker_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">pos</span>
            <span class="n">whiskerlo_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whislo&#39;</span><span class="p">]])</span>
            <span class="n">whiskerhi_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whishi&#39;</span><span class="p">]])</span>

            <span class="c1"># cap coords</span>
            <span class="n">cap_left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.25</span>
            <span class="n">cap_right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.25</span>
            <span class="n">cap_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">cap_left</span><span class="p">,</span> <span class="n">cap_right</span><span class="p">])</span>
            <span class="n">cap_lo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whislo&#39;</span><span class="p">]</span>
            <span class="n">cap_hi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;whishi&#39;</span><span class="p">]</span>

            <span class="c1"># box and median coords</span>
            <span class="n">box_left</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">box_right</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">width</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">med_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">]]</span>

            <span class="c1"># notched boxes</span>
            <span class="k">if</span> <span class="n">shownotches</span><span class="p">:</span>
                <span class="n">box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">cap_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span>
                         <span class="n">box_right</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">cap_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span>
                         <span class="n">box_left</span><span class="p">]</span>
                <span class="n">box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cilo&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cihi&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cihi&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;med&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;cilo&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">]]</span>
                <span class="n">med_x</span> <span class="o">=</span> <span class="n">cap_x</span>

            <span class="c1"># plain boxes</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">box_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_right</span><span class="p">,</span> <span class="n">box_left</span><span class="p">,</span> <span class="n">box_left</span><span class="p">]</span>
                <span class="n">box_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q3&#39;</span><span class="p">],</span>
                         <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;q1&#39;</span><span class="p">]]</span>
                <span class="n">med_x</span> <span class="o">=</span> <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">]</span>

            <span class="c1"># maybe draw the box:</span>
            <span class="k">if</span> <span class="n">showbox</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">patch_artist</span><span class="p">:</span>
                    <span class="n">boxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">dopatch</span><span class="p">(</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_boxprops</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">boxes</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">box_x</span><span class="p">,</span> <span class="n">box_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_boxprops</span><span class="p">))</span>

            <span class="c1"># draw the whiskers</span>
            <span class="n">whiskers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                <span class="n">whisker_x</span><span class="p">,</span> <span class="n">whiskerlo_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_whiskerprops</span>
            <span class="p">))</span>
            <span class="n">whiskers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                <span class="n">whisker_x</span><span class="p">,</span> <span class="n">whiskerhi_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_whiskerprops</span>
            <span class="p">))</span>

            <span class="c1"># maybe draw the caps:</span>
            <span class="k">if</span> <span class="n">showcaps</span><span class="p">:</span>
                <span class="n">caps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">cap_x</span><span class="p">,</span> <span class="n">cap_lo</span><span class="p">,</span> <span class="o">**</span><span class="n">final_capprops</span><span class="p">))</span>
                <span class="n">caps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">cap_x</span><span class="p">,</span> <span class="n">cap_hi</span><span class="p">,</span> <span class="o">**</span><span class="n">final_capprops</span><span class="p">))</span>

            <span class="c1"># draw the medians</span>
            <span class="n">medians</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span><span class="n">med_x</span><span class="p">,</span> <span class="n">med_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_medianprops</span><span class="p">))</span>

            <span class="c1"># maybe draw the means</span>
            <span class="k">if</span> <span class="n">showmeans</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">meanline</span><span class="p">:</span>
                    <span class="n">means</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">box_left</span><span class="p">,</span> <span class="n">box_right</span><span class="p">],</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">],</span> <span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]],</span>
                        <span class="o">**</span><span class="n">final_meanprops</span>
                    <span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">means</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                        <span class="p">[</span><span class="n">pos</span><span class="p">],</span> <span class="p">[</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">]],</span> <span class="o">**</span><span class="n">final_meanprops</span>
                    <span class="p">))</span>

            <span class="c1"># maybe draw the fliers</span>
            <span class="k">if</span> <span class="n">showfliers</span><span class="p">:</span>
                <span class="n">fliers</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">doplot</span><span class="p">(</span>
                    <span class="n">flier_x</span><span class="p">,</span> <span class="n">flier_y</span><span class="p">,</span> <span class="o">**</span><span class="n">final_flierprops</span>
                <span class="p">))</span>

        <span class="c1"># fix our axes/ticks up a little</span>
        <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
            <span class="n">setticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_xticks</span>
            <span class="n">setlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span>
            <span class="n">setlabels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_xticklabels</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">setticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span>
            <span class="n">setlim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span>
            <span class="n">setlabels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">set_yticklabels</span>

        <span class="k">if</span> <span class="n">manage_xticks</span><span class="p">:</span>
            <span class="n">newlimits</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="n">setlim</span><span class="p">(</span><span class="n">newlimits</span><span class="p">)</span>
            <span class="n">setticks</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span>
            <span class="n">setlabels</span><span class="p">(</span><span class="n">datalabels</span><span class="p">)</span>

        <span class="c1"># reset hold status</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hold</span><span class="p">(</span><span class="n">holdStatus</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">whiskers</span><span class="o">=</span><span class="n">whiskers</span><span class="p">,</span> <span class="n">caps</span><span class="o">=</span><span class="n">caps</span><span class="p">,</span> <span class="n">boxes</span><span class="o">=</span><span class="n">boxes</span><span class="p">,</span>
                    <span class="n">medians</span><span class="o">=</span><span class="n">medians</span><span class="p">,</span> <span class="n">fliers</span><span class="o">=</span><span class="n">fliers</span><span class="p">,</span> <span class="n">means</span><span class="o">=</span><span class="n">means</span><span class="p">)</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;linewidths&quot;</span><span class="p">,</span>
                                        <span class="s2">&quot;edgecolors&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s1">&#39;facecolor&#39;</span><span class="p">,</span>
                                        <span class="s1">&#39;facecolors&#39;</span><span class="p">,</span> <span class="s1">&#39;color&#39;</span><span class="p">],</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.scatter"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.scatter.html#mpl.axes.Axes.scatter">[docs]</a>    <span class="k">def</span> <span class="nf">scatter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">vmin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">verts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a scatter plot of x vs y, where x and y are sequence like objects</span>
<span class="sd">        of the same lengths.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y : array_like, shape (n, )</span>
<span class="sd">            Input data</span>

<span class="sd">        s : scalar or array_like, shape (n, ), optional, default: 20</span>
<span class="sd">            size in points^2.</span>

<span class="sd">        c : color or sequence of color, optional, default : &#39;b&#39;</span>
<span class="sd">            `c` can be a single color format string, or a sequence of color</span>
<span class="sd">            specifications of length `N`, or a sequence of `N` numbers to be</span>
<span class="sd">            mapped to colors using the `cmap` and `norm` specified via kwargs</span>
<span class="sd">            (see below). Note that `c` should not be a single numeric RGB or</span>
<span class="sd">            RGBA sequence because that is indistinguishable from an array of</span>
<span class="sd">            values to be colormapped.  `c` can be a 2-D array in which the</span>
<span class="sd">            rows are RGB or RGBA, however, including the case of a single</span>
<span class="sd">            row to specify the same color for all points.</span>

<span class="sd">        marker : `~matplotlib.markers.MarkerStyle`, optional, default: &#39;o&#39;</span>
<span class="sd">            See `~matplotlib.markers` for more information on the different</span>
<span class="sd">            styles of markers scatter supports. `marker` can be either</span>
<span class="sd">            an instance of the class or the text shorthand for a particular</span>
<span class="sd">            marker.</span>

<span class="sd">        cmap : `~matplotlib.colors.Colormap`, optional, default: None</span>
<span class="sd">            A `~matplotlib.colors.Colormap` instance or registered name.</span>
<span class="sd">            `cmap` is only used if `c` is an array of floats. If None,</span>
<span class="sd">            defaults to rc `image.cmap`.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional, default: None</span>
<span class="sd">            A `~matplotlib.colors.Normalize` instance is used to scale</span>
<span class="sd">            luminance data to 0, 1. `norm` is only used if `c` is an array of</span>
<span class="sd">            floats. If `None`, use the default :func:`normalize`.</span>

<span class="sd">        vmin, vmax : scalar, optional, default: None</span>
<span class="sd">            `vmin` and `vmax` are used in conjunction with `norm` to normalize</span>
<span class="sd">            luminance data.  If either are `None`, the min and max of the</span>
<span class="sd">            color array is used.  Note if you pass a `norm` instance, your</span>
<span class="sd">            settings for `vmin` and `vmax` will be ignored.</span>

<span class="sd">        alpha : scalar, optional, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque)</span>

<span class="sd">        linewidths : scalar or array_like, optional, default: None</span>
<span class="sd">            If None, defaults to (lines.linewidth,).</span>

<span class="sd">        edgecolors : color or sequence of color, optional, default: None</span>
<span class="sd">            If None, defaults to (patch.edgecolor).</span>
<span class="sd">            If &#39;face&#39;, the edge color will always be the same as</span>
<span class="sd">            the face color.  If it is &#39;none&#39;, the patch boundary will not</span>
<span class="sd">            be drawn.  For non-filled markers, the `edgecolors` kwarg</span>
<span class="sd">            is ignored; color is determined by `c`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        paths : `~matplotlib.collections.PathCollection`</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs : `~matplotlib.collections.Collection` properties</span>

<span class="sd">        Notes</span>
<span class="sd">        ------</span>
<span class="sd">        Any or all of `x`, `y`, `s`, and `c` may be masked arrays, in</span>
<span class="sd">        which case all masks will be combined and only unmasked points</span>
<span class="sd">        will be plotted.</span>

<span class="sd">        Fundamentally, scatter works with 1-D arrays; `x`, `y`, `s`,</span>
<span class="sd">        and `c` may be input as 2-D arrays, but within scatter</span>
<span class="sd">        they will be flattened. The exception is `c`, which</span>
<span class="sd">        will be flattened only if its size matches the size of `x`</span>
<span class="sd">        and `y`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot:: mpl_examples/shapes_and_collections/scatter_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="c1"># Process **kwargs to handle aliases, conflicts with explicit kwargs:</span>

        <span class="n">facecolors</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">ec</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">ec</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;facecolor&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">facecolors</span> <span class="o">=</span> <span class="n">fc</span>
        <span class="n">fc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;facecolors&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">facecolors</span> <span class="o">=</span> <span class="n">fc</span>
        <span class="c1"># &#39;color&#39; should be deprecated in scatter, or clearly defined;</span>
        <span class="c1"># since it isn&#39;t, I am giving it low priority.</span>
        <span class="n">co</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;color&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">co</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">edgecolors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">edgecolors</span> <span class="o">=</span> <span class="n">co</span>
            <span class="k">if</span> <span class="n">facecolors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">facecolors</span> <span class="o">=</span> <span class="n">co</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">facecolors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">facecolors</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="s1">&#39;b&#39;</span>  <span class="c1"># The original default</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># np.ma.ravel yields an ndarray, not a masked array,</span>
        <span class="c1"># unless its argument is a masked array.</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x and y must be the same size&quot;</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>  <span class="c1"># This doesn&#39;t have to match x, y in size.</span>

        <span class="c1"># After this block, c_array will be None unless</span>
        <span class="c1"># c is an array for mapping.  The potential ambiguity</span>
        <span class="c1"># with a sequence of 3 or 4 numbers is resolved in</span>
        <span class="c1"># favor of mapping, not rgb or rgba.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">c_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">c_array</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">c_array</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Wrong size; it must not be intended for mapping.</span>
                <span class="n">c_array</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># Failed to make a floating-point array; c must be color specs.</span>
            <span class="n">c_array</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">c_array</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">c</span>     <span class="c1"># must be acceptable as PathCollection facecolors</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># use cmap, norm after collection is created</span>

        <span class="c1"># c will be unchanged unless it is the same length as x:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

        <span class="n">scales</span> <span class="o">=</span> <span class="n">s</span>   <span class="c1"># Renamed for readability below.</span>

        <span class="c1"># to be API compatible</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">verts</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">verts</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">marker</span><span class="p">,</span> <span class="n">mmarkers</span><span class="o">.</span><span class="n">MarkerStyle</span><span class="p">):</span>
            <span class="n">marker_obj</span> <span class="o">=</span> <span class="n">marker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">marker_obj</span> <span class="o">=</span> <span class="n">mmarkers</span><span class="o">.</span><span class="n">MarkerStyle</span><span class="p">(</span><span class="n">marker</span><span class="p">)</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">marker_obj</span><span class="o">.</span><span class="n">get_path</span><span class="p">()</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span>
            <span class="n">marker_obj</span><span class="o">.</span><span class="n">get_transform</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marker_obj</span><span class="o">.</span><span class="n">is_filled</span><span class="p">():</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;face&#39;</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PathCollection</span><span class="p">(</span>
                <span class="p">(</span><span class="n">path</span><span class="p">,),</span> <span class="n">scales</span><span class="p">,</span>
                <span class="n">facecolors</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
                <span class="n">transOffset</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">),</span>
                <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span>
                <span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_transform</span><span class="p">(</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">())</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">colors</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="c1"># The margin adjustment is a hack to deal with the fact that we don&#39;t</span>
        <span class="c1"># want to transform all the symbols whose scales are in points</span>
        <span class="c1"># to data coords to get the exact bounding box for efficiency</span>
        <span class="c1"># reasons.  It can be done right if this is deemed important.</span>
        <span class="c1"># Also, only bother with this padding if there is anything to draw.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xmargin</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xmargin</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ymargin</span> <span class="o">&lt;</span> <span class="mf">0.05</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_ymargin</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">collection</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.hexbin"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.hexbin.html#mpl.axes.Axes.hexbin">[docs]</a>    <span class="k">def</span> <span class="nf">hexbin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">gridsize</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">xscale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">yscale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">cmap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">alpha</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
               <span class="n">reduce_C_function</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">mincnt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">marginals</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a hexagonal binning plot.</span>

<span class="sd">        Call signature::</span>

<span class="sd">           hexbin(x, y, C = None, gridsize = 100, bins = None,</span>
<span class="sd">                  xscale = &#39;linear&#39;, yscale = &#39;linear&#39;,</span>
<span class="sd">                  cmap=None, norm=None, vmin=None, vmax=None,</span>
<span class="sd">                  alpha=None, linewidths=None, edgecolors=&#39;none&#39;</span>
<span class="sd">                  reduce_C_function = np.mean, mincnt=None, marginals=True</span>
<span class="sd">                  **kwargs)</span>

<span class="sd">        Make a hexagonal binning plot of *x* versus *y*, where *x*,</span>
<span class="sd">        *y* are 1-D sequences of the same length, *N*. If *C* is *None*</span>
<span class="sd">        (the default), this is a histogram of the number of occurences</span>
<span class="sd">        of the observations at (x[i],y[i]).</span>

<span class="sd">        If *C* is specified, it specifies values at the coordinate</span>
<span class="sd">        (x[i],y[i]). These values are accumulated for each hexagonal</span>
<span class="sd">        bin and then reduced according to *reduce_C_function*, which</span>
<span class="sd">        defaults to numpy&#39;s mean function (np.mean). (If *C* is</span>
<span class="sd">        specified, it must also be a 1-D sequence of the same length</span>
<span class="sd">        as *x* and *y*.)</span>

<span class="sd">        *x*, *y* and/or *C* may be masked arrays, in which case only</span>
<span class="sd">        unmasked points will be plotted.</span>

<span class="sd">        Optional keyword arguments:</span>

<span class="sd">        *gridsize*: [ 100 | integer ]</span>
<span class="sd">           The number of hexagons in the *x*-direction, default is</span>
<span class="sd">           100. The corresponding number of hexagons in the</span>
<span class="sd">           *y*-direction is chosen such that the hexagons are</span>
<span class="sd">           approximately regular. Alternatively, gridsize can be a</span>
<span class="sd">           tuple with two elements specifying the number of hexagons</span>
<span class="sd">           in the *x*-direction and the *y*-direction.</span>

<span class="sd">        *bins*: [ *None* | &#39;log&#39; | integer | sequence ]</span>
<span class="sd">           If *None*, no binning is applied; the color of each hexagon</span>
<span class="sd">           directly corresponds to its count value.</span>

<span class="sd">           If &#39;log&#39;, use a logarithmic scale for the color</span>
<span class="sd">           map. Internally, :math:`log_{10}(i+1)` is used to</span>
<span class="sd">           determine the hexagon color.</span>

<span class="sd">           If an integer, divide the counts in the specified number</span>
<span class="sd">           of bins, and color the hexagons accordingly.</span>

<span class="sd">           If a sequence of values, the values of the lower bound of</span>
<span class="sd">           the bins to be used.</span>

<span class="sd">        *xscale*: [ &#39;linear&#39; | &#39;log&#39; ]</span>
<span class="sd">           Use a linear or log10 scale on the horizontal axis.</span>

<span class="sd">        *scale*: [ &#39;linear&#39; | &#39;log&#39; ]</span>
<span class="sd">           Use a linear or log10 scale on the vertical axis.</span>

<span class="sd">        *mincnt*: [ *None* | a positive integer ]</span>
<span class="sd">           If not *None*, only display cells with more than *mincnt*</span>
<span class="sd">           number of points in the cell</span>

<span class="sd">        *marginals*: [ *True* | *False* ]</span>
<span class="sd">           if marginals is *True*, plot the marginal density as</span>
<span class="sd">           colormapped rectagles along the bottom of the x-axis and</span>
<span class="sd">           left of the y-axis</span>

<span class="sd">        *extent*: [ *None* | scalars (left, right, bottom, top) ]</span>
<span class="sd">           The limits of the bins. The default assigns the limits</span>
<span class="sd">           based on gridsize, x, y, xscale and yscale.</span>

<span class="sd">        Other keyword arguments controlling color mapping and normalization</span>
<span class="sd">        arguments:</span>

<span class="sd">        *cmap*: [ *None* | Colormap ]</span>
<span class="sd">           a :class:`matplotlib.colors.Colormap` instance. If *None*,</span>
<span class="sd">           defaults to rc ``image.cmap``.</span>

<span class="sd">        *norm*: [ *None* | Normalize ]</span>
<span class="sd">           :class:`matplotlib.colors.Normalize` instance is used to</span>
<span class="sd">           scale luminance data to 0,1.</span>

<span class="sd">        *vmin* / *vmax*: scalar</span>
<span class="sd">           *vmin* and *vmax* are used in conjunction with *norm* to normalize</span>
<span class="sd">           luminance data.  If either are *None*, the min and max of the color</span>
<span class="sd">           array *C* is used.  Note if you pass a norm instance, your settings</span>
<span class="sd">           for *vmin* and *vmax* will be ignored.</span>

<span class="sd">        *alpha*: scalar between 0 and 1, or *None*</span>
<span class="sd">           the alpha value for the patches</span>

<span class="sd">        *linewidths*: [ *None* | scalar ]</span>
<span class="sd">           If *None*, defaults to rc lines.linewidth. Note that this</span>
<span class="sd">           is a tuple, and if you set the linewidths argument you</span>
<span class="sd">           must set it as a sequence of floats, as required by</span>
<span class="sd">           :class:`~matplotlib.collections.RegularPolyCollection`.</span>

<span class="sd">        Other keyword arguments controlling the Collection properties:</span>

<span class="sd">        *edgecolors*: [ *None* | ``&#39;none&#39;`` | mpl color | color sequence ]</span>
<span class="sd">           If ``&#39;none&#39;``, draws the edges in the same color as the fill color.</span>
<span class="sd">           This is the default, as it avoids unsightly unpainted pixels</span>
<span class="sd">           between the hexagons.</span>

<span class="sd">           If *None*, draws the outlines in the default color.</span>

<span class="sd">           If a matplotlib color arg or sequence of rgba tuples, draws the</span>
<span class="sd">           outlines in the specified color.</span>

<span class="sd">        Here are the standard descriptions of all the</span>
<span class="sd">        :class:`~matplotlib.collections.Collection` kwargs:</span>

<span class="sd">        %(Collection)s</span>

<span class="sd">        The return value is a</span>
<span class="sd">        :class:`~matplotlib.collections.PolyCollection` instance; use</span>
<span class="sd">        :meth:`~matplotlib.collections.PolyCollection.get_array` on</span>
<span class="sd">        this :class:`~matplotlib.collections.PolyCollection` to get</span>
<span class="sd">        the counts in each hexagon. If *marginals* is *True*, horizontal</span>
<span class="sd">        bar and vertical bar (both PolyCollections) will be attached</span>
<span class="sd">        to the return collection as attributes *hbar* and *vbar*.</span>


<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/hexbin_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">delete_masked_points</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

        <span class="c1"># Set the size of the hexagon grid</span>
        <span class="k">if</span> <span class="n">iterable</span><span class="p">(</span><span class="n">gridsize</span><span class="p">):</span>
            <span class="n">nx</span><span class="p">,</span> <span class="n">ny</span> <span class="o">=</span> <span class="n">gridsize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nx</span> <span class="o">=</span> <span class="n">gridsize</span>
            <span class="n">ny</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nx</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
        <span class="c1"># Count the number of data in each hexagon</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x contains non-positive values, so can not&quot;</span>
                                 <span class="s2">&quot; be log-scaled&quot;</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y contains non-positive values, so can not&quot;</span>
                                 <span class="s2">&quot; be log-scaled&quot;</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">extent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># to avoid issues with singular data, expand the min/max pairs</span>
            <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">mtrans</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
            <span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="n">mtrans</span><span class="o">.</span><span class="n">nonsingular</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

        <span class="c1"># In the x-direction, the hexagons exactly cover the region from</span>
        <span class="c1"># xmin to xmax. Need some padding to avoid roundoff errors.</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="mf">1.e-9</span> <span class="o">*</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span>
        <span class="n">xmin</span> <span class="o">-=</span> <span class="n">padding</span>
        <span class="n">xmax</span> <span class="o">+=</span> <span class="n">padding</span>
        <span class="n">sx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">nx</span>
        <span class="n">sy</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">ny</span>

        <span class="k">if</span> <span class="n">marginals</span><span class="p">:</span>
            <span class="n">xorig</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">yorig</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">/</span> <span class="n">sx</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">/</span> <span class="n">sy</span>
        <span class="n">ix1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">iy1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ix2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">iy2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">nx1</span> <span class="o">=</span> <span class="n">nx</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">ny1</span> <span class="o">=</span> <span class="n">ny</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nx2</span> <span class="o">=</span> <span class="n">nx</span>
        <span class="n">ny2</span> <span class="o">=</span> <span class="n">ny</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span> <span class="o">+</span> <span class="n">nx2</span> <span class="o">*</span> <span class="n">ny2</span>

        <span class="n">d1</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">ix1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">iy1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">ix2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="mf">3.0</span> <span class="o">*</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">iy2</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="n">bdist</span> <span class="o">=</span> <span class="p">(</span><span class="n">d1</span> <span class="o">&lt;</span> <span class="n">d2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="c1"># Create appropriate views into &quot;accum&quot; array.</span>
            <span class="n">lattice1</span> <span class="o">=</span> <span class="n">accum</span><span class="p">[:</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">]</span>
            <span class="n">lattice2</span> <span class="o">=</span> <span class="n">accum</span><span class="p">[</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">:]</span>
            <span class="n">lattice1</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx1</span><span class="p">,</span> <span class="n">ny1</span><span class="p">)</span>
            <span class="n">lattice2</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx2</span><span class="p">,</span> <span class="n">ny2</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">bdist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nx1</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ny1</span><span class="p">)):</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nx2</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ny2</span><span class="p">)):</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># threshold</span>
            <span class="k">if</span> <span class="n">mincnt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nx1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">ny1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mincnt</span><span class="p">:</span>
                            <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nx2</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">ny2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mincnt</span><span class="p">:</span>
                            <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">lattice1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                               <span class="n">lattice2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="n">good_idxs</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mincnt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">mincnt</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># create accumulation arrays</span>
            <span class="n">lattice1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nx1</span><span class="p">,</span> <span class="n">ny1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nx1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">ny1</span><span class="p">):</span>
                    <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">lattice2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nx2</span><span class="p">,</span> <span class="n">ny2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nx2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">ny2</span><span class="p">):</span>
                    <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">bdist</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nx1</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ny1</span><span class="p">)):</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">ix1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">iy1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">((</span><span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nx2</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="p">(</span><span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">ny2</span><span class="p">)):</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">ix2</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">iy2</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nx1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">ny1</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mincnt</span><span class="p">:</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lattice1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nx2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">ny2</span><span class="p">):</span>
                    <span class="n">vals</span> <span class="o">=</span> <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">mincnt</span><span class="p">:</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lattice2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">lattice1</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                               <span class="n">lattice2</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="n">good_idxs</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="n">offsets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[:</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx1</span><span class="p">),</span> <span class="n">ny1</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[:</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny1</span><span class="p">),</span> <span class="n">nx1</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ny2</span><span class="p">)</span>
        <span class="n">offsets</span><span class="p">[</span><span class="n">nx1</span> <span class="o">*</span> <span class="n">ny1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny2</span><span class="p">),</span> <span class="n">nx2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sx</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">sy</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xmin</span>
        <span class="n">offsets</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">ymin</span>
        <span class="c1"># remove accumulation bins with no data</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">accum</span> <span class="o">=</span> <span class="n">accum</span><span class="p">[</span><span class="n">good_idxs</span><span class="p">]</span>

        <span class="n">polygon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">6</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>
        <span class="n">polygon</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sy</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">])</span> <span class="o">/</span> <span class="mf">3.0</span>

        <span class="k">if</span> <span class="n">edgecolors</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;face&#39;</span>

        <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span> <span class="ow">or</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="n">polygons</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">offsets</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">xmin</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">xmax</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="n">xscale</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">yscale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">polygons</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">ymin</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="mf">10.0</span> <span class="o">**</span> <span class="n">ymax</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="n">yscale</span><span class="p">)</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
                <span class="n">polygons</span><span class="p">,</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span>
                <span class="p">[</span><span class="n">polygon</span><span class="p">],</span>
                <span class="n">edgecolors</span><span class="o">=</span><span class="n">edgecolors</span><span class="p">,</span>
                <span class="n">linewidths</span><span class="o">=</span><span class="n">linewidths</span><span class="p">,</span>
                <span class="n">offsets</span><span class="o">=</span><span class="n">offsets</span><span class="p">,</span>
                <span class="n">transOffset</span><span class="o">=</span><span class="n">mtransforms</span><span class="o">.</span><span class="n">IdentityTransform</span><span class="p">(),</span>
                <span class="n">offset_position</span><span class="o">=</span><span class="s2">&quot;data&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">accum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="c1"># make sure we have not zeros</span>
                <span class="n">accum</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># autoscale the norm with curren accum values if it hasn&#39;t</span>
        <span class="c1"># been set</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">norm</span><span class="o">.</span><span class="n">autoscale</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="c1"># Transform accum if needed</span>
        <span class="k">if</span> <span class="n">bins</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">accum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bins</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
                <span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">accum</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>
                <span class="n">bins</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># one less edge than bins</span>
                <span class="n">bins</span> <span class="o">=</span> <span class="n">minimum</span> <span class="o">+</span> <span class="p">(</span><span class="n">maximum</span> <span class="o">-</span> <span class="n">minimum</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">/</span> <span class="n">bins</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="n">accum</span> <span class="o">=</span> <span class="n">bins</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">accum</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="p">((</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">),</span> <span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c1"># add the collection last</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">marginals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">collection</span>

        <span class="k">if</span> <span class="n">C</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">coarse_bin</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">coarse</span><span class="p">):</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">coarse</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">mus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)):</span>
                <span class="n">yi</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">yi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="n">reduce_C_function</span><span class="p">(</span><span class="n">yi</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">mus</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mu</span>
            <span class="k">return</span> <span class="n">mus</span>

        <span class="n">coarse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">gridsize</span><span class="p">)</span>

        <span class="n">xcoarse</span> <span class="o">=</span> <span class="n">coarse_bin</span><span class="p">(</span><span class="n">xorig</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">xcoarse</span><span class="p">)</span>
        <span class="n">verts</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xcoarse</span><span class="p">):</span>
            <span class="n">thismin</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">thismin</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coarse</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>

            <span class="n">verts</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="n">thismin</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">thismin</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">thismax</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">),</span>
                          <span class="p">(</span><span class="n">thismax</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_xaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>

        <span class="n">hbar</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">)</span>

        <span class="n">hbar</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">hbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">hbar</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="n">coarse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="n">gridsize</span><span class="p">)</span>
        <span class="n">ycoarse</span> <span class="o">=</span> <span class="n">coarse_bin</span><span class="p">(</span><span class="n">yorig</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">coarse</span><span class="p">)</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">ycoarse</span><span class="p">)</span>
        <span class="n">verts</span><span class="p">,</span> <span class="n">values</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ycoarse</span><span class="p">):</span>
            <span class="n">thismin</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">coarse</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">coarse</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thismax</span> <span class="o">=</span> <span class="n">thismin</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">coarse</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">valid</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">verts</span><span class="o">.</span><span class="n">append</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">thismin</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">thismax</span><span class="p">),</span>
                          <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">thismax</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">thismin</span><span class="p">)])</span>
            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_yaxis_transform</span><span class="p">(</span><span class="n">which</span><span class="o">=</span><span class="s1">&#39;grid&#39;</span><span class="p">)</span>

        <span class="n">vbar</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="n">trans</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;face&#39;</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">vbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">vbar</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">hbar</span> <span class="o">=</span> <span class="n">hbar</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">vbar</span> <span class="o">=</span> <span class="n">vbar</span>

        <span class="k">def</span> <span class="nf">on_changed</span><span class="p">(</span><span class="n">collection</span><span class="p">):</span>
            <span class="n">hbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">())</span>
            <span class="n">hbar</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_clim</span><span class="p">())</span>
            <span class="n">vbar</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">())</span>
            <span class="n">vbar</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">collection</span><span class="o">.</span><span class="n">get_clim</span><span class="p">())</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">callbacksSM</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;changed&#39;</span><span class="p">,</span> <span class="n">on_changed</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">collection</span></div>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.arrow"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.arrow.html#mpl.axes.Axes.arrow">[docs]</a>    <span class="k">def</span> <span class="nf">arrow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add an arrow to the axes.</span>

<span class="sd">        Call signature::</span>

<span class="sd">           arrow(x, y, dx, dy, **kwargs)</span>

<span class="sd">        Draws arrow on specified axis from (*x*, *y*) to (*x* + *dx*,</span>
<span class="sd">        *y* + *dy*). Uses FancyArrow patch to construct the arrow.</span>

<span class="sd">        The resulting arrow is affected by the axes aspect ratio and limits.</span>
<span class="sd">        This may produce an arrow whose head is not square with its stem. To</span>
<span class="sd">        create an arrow whose head is square with its stem, use</span>
<span class="sd">        :meth:`annotate` for example::</span>

<span class="sd">            ax.annotate(&quot;&quot;, xy=(0.5, 0.5), xytext=(0, 0),</span>
<span class="sd">                arrowprops=dict(arrowstyle=&quot;-&gt;&quot;))</span>

<span class="sd">        Optional kwargs control the arrow construction and properties:</span>

<span class="sd">        %(FancyArrow)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/arrow_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Strip away units for the underlying patch since units</span>
        <span class="c1"># do not make sense to most patch-like code</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">FancyArrow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Axes.quiverkey"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.quiverkey.html#mpl.axes.Axes.quiverkey">[docs]</a>    <span class="k">def</span> <span class="nf">quiverkey</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="n">qk</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">QuiverKey</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">qk</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">qk</span></div>
    <span class="n">quiverkey</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">QuiverKey</span><span class="o">.</span><span class="n">quiverkey_doc</span>

    <span class="c1"># args can by a combination if X, Y, U, V, C and all should be replaced</span>
    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_all_args</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<div class="viewcode-block" id="Axes.quiver"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.quiver.html#mpl.axes.Axes.quiver">[docs]</a>    <span class="k">def</span> <span class="nf">quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Quiver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">q</span></div>
    <span class="n">quiver</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Quiver</span><span class="o">.</span><span class="n">quiver_doc</span>

    <span class="c1"># args can by either Y or y1,y2,... and all should be replaced</span>
    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_all_args</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<div class="viewcode-block" id="Axes.stackplot"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.stackplot.html#mpl.axes.Axes.stackplot">[docs]</a>    <span class="k">def</span> <span class="nf">stackplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mstack</span><span class="o">.</span><span class="n">stackplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">stackplot</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mstack</span><span class="o">.</span><span class="n">stackplot</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">,</span> <span class="s2">&quot;v&quot;</span><span class="p">,</span> <span class="s2">&quot;start_points&quot;</span><span class="p">],</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<div class="viewcode-block" id="Axes.streamplot"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.streamplot.html#mpl.axes.Axes.streamplot">[docs]</a>    <span class="k">def</span> <span class="nf">streamplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                   <span class="n">cmap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">arrowsize</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">arrowstyle</span><span class="o">=</span><span class="s1">&#39;-|&gt;&#39;</span><span class="p">,</span>
                   <span class="n">minlength</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">transform</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">zorder</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">start_points</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">stream_container</span> <span class="o">=</span> <span class="n">mstream</span><span class="o">.</span><span class="n">streamplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span>
                                              <span class="n">density</span><span class="o">=</span><span class="n">density</span><span class="p">,</span>
                                              <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">,</span>
                                              <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">,</span>
                                              <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                                              <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                                              <span class="n">arrowsize</span><span class="o">=</span><span class="n">arrowsize</span><span class="p">,</span>
                                              <span class="n">arrowstyle</span><span class="o">=</span><span class="n">arrowstyle</span><span class="p">,</span>
                                              <span class="n">minlength</span><span class="o">=</span><span class="n">minlength</span><span class="p">,</span>
                                              <span class="n">start_points</span><span class="o">=</span><span class="n">start_points</span><span class="p">,</span>
                                              <span class="n">transform</span><span class="o">=</span><span class="n">transform</span><span class="p">,</span>
                                              <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stream_container</span></div>
    <span class="n">streamplot</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mstream</span><span class="o">.</span><span class="n">streamplot</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="c1"># args can be some combination of X, Y, U, V, C and all should be replaced</span>
    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_all_args</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.barbs"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.barbs.html#mpl.axes.Axes.barbs">[docs]</a>    <span class="k">def</span> <span class="nf">barbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        %(barbs_doc)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/barb_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">mquiver</span><span class="o">.</span><span class="n">Barbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">b</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="n">positional_parameter_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">])</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.fill"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.fill.html#mpl.axes.Axes.fill">[docs]</a>    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot filled polygons.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          fill(*args, **kwargs)</span>

<span class="sd">        *args* is a variable length argument, allowing for multiple</span>
<span class="sd">        *x*, *y* pairs with an optional color format string; see</span>
<span class="sd">        :func:`~matplotlib.pyplot.plot` for details on the argument</span>
<span class="sd">        parsing.  For example, to plot a polygon with vertices at *x*,</span>
<span class="sd">        *y* in blue.::</span>

<span class="sd">          ax.fill(x,y, &#39;b&#39; )</span>

<span class="sd">        An arbitrary number of *x*, *y*, *color* groups can be specified::</span>

<span class="sd">          ax.fill(x1, y1, &#39;g&#39;, x2, y2, &#39;r&#39;)</span>

<span class="sd">        Return value is a list of :class:`~matplotlib.patches.Patch`</span>
<span class="sd">        instances that were added.</span>

<span class="sd">        The same color strings that :func:`~matplotlib.pyplot.plot`</span>
<span class="sd">        supports are supported by the fill format string.</span>

<span class="sd">        If you would like to fill below a curve, e.g., shade a region</span>
<span class="sd">        between 0 and *y* along *x*, use :meth:`fill_between`</span>

<span class="sd">        The *closed* kwarg will close the polygon when *True* (default).</span>

<span class="sd">        kwargs control the :class:`~matplotlib.patches.Polygon` properties:</span>

<span class="sd">        %(Polygon)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/lines_bars_and_markers/fill_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_patches_for_fill</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">poly</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">patches</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y1&quot;</span><span class="p">,</span> <span class="s2">&quot;y2&quot;</span><span class="p">,</span> <span class="s2">&quot;where&quot;</span><span class="p">],</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.fill_between"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.fill_between.html#mpl.axes.Axes.fill_between">[docs]</a>    <span class="k">def</span> <span class="nf">fill_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">interpolate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                     <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make filled polygons between two curves.</span>


<span class="sd">        Create a :class:`~matplotlib.collections.PolyCollection`</span>
<span class="sd">        filling the regions between *y1* and *y2* where</span>
<span class="sd">        ``where==True``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : array</span>
<span class="sd">            An N-length array of the x data</span>

<span class="sd">        y1 : array</span>
<span class="sd">            An N-length array (or scalar) of the y data</span>

<span class="sd">        y2 : array</span>
<span class="sd">            An N-length array (or scalar) of the y data</span>

<span class="sd">        where : array, optional</span>
<span class="sd">            If `None`, default to fill between everywhere.  If not `None`,</span>
<span class="sd">            it is an N-length numpy boolean array and the fill will</span>
<span class="sd">            only happen over the regions where ``where==True``.</span>

<span class="sd">        interpolate : bool, optional</span>
<span class="sd">            If `True`, interpolate between the two lines to find the</span>
<span class="sd">            precise point of intersection.  Otherwise, the start and</span>
<span class="sd">            end points of the filled region will only occur on explicit</span>
<span class="sd">            values in the *x* array.</span>

<span class="sd">        step : {&#39;pre&#39;, &#39;post&#39;, &#39;mid&#39;}, optional</span>
<span class="sd">            If not None, fill with step logic.</span>


<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Additional Keyword args passed on to the</span>
<span class="sd">        :class:`~matplotlib.collections.PolyCollection`.</span>

<span class="sd">        kwargs control the :class:`~matplotlib.patches.Polygon` properties:</span>

<span class="sd">        %(PolyCollection)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/fill_between_demo.py</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">            :meth:`fill_betweenx`</span>
<span class="sd">                for filling between two sets of x-values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle united data, such as dates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y1</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">ydata</span><span class="o">=</span><span class="n">y2</span><span class="p">)</span>

        <span class="c1"># Convert the arrays so we can work with them</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y1</span><span class="p">))</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">y1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">y1</span>
        <span class="k">if</span> <span class="n">y2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="n">y2</span>

        <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">y2</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">where</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument dimensions are incompatible&quot;</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">mask_or</span><span class="p">,</span> <span class="p">[</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">mlab</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">xslice</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">y1slice</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">y2slice</span> <span class="o">=</span> <span class="n">y2</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">step_func</span> <span class="o">=</span> <span class="n">STEP_LOOKUP_MAP</span><span class="p">[</span><span class="n">step</span><span class="p">]</span>
                <span class="n">xslice</span><span class="p">,</span> <span class="n">y1slice</span><span class="p">,</span> <span class="n">y2slice</span> <span class="o">=</span> <span class="n">step_func</span><span class="p">(</span><span class="n">xslice</span><span class="p">,</span> <span class="n">y1slice</span><span class="p">,</span> <span class="n">y2slice</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">xslice</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xslice</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">interpolate</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">get_interp_point</span><span class="p">(</span><span class="n">ind</span><span class="p">):</span>
                    <span class="n">im1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ind</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">x_values</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">diff_values</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y2</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">y1_values</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">im1</span><span class="p">:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">im1</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">im1</span><span class="p">]</span>
                        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">diff_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="n">ind</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

                    <span class="n">diff_order</span> <span class="o">=</span> <span class="n">diff_values</span><span class="o">.</span><span class="n">argsort</span><span class="p">()</span>
                    <span class="n">diff_root_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">diff_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">],</span> <span class="n">x_values</span><span class="p">[</span><span class="n">diff_order</span><span class="p">])</span>
                    <span class="n">diff_root_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">diff_root_x</span><span class="p">,</span> <span class="n">x_values</span><span class="p">,</span> <span class="n">y1_values</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">diff_root_x</span><span class="p">,</span> <span class="n">diff_root_y</span>

                <span class="n">start</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind0</span><span class="p">)</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">get_interp_point</span><span class="p">(</span><span class="n">ind1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># the purpose of the next two lines is for when y2 is a</span>
                <span class="c1"># scalar like 0 and we want the fill to go all the way</span>
                <span class="c1"># down to 0 even if none of the y1 sample points do</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">xslice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y2slice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">xslice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y2slice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">end</span>

            <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xslice</span>
            <span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y1slice</span>
            <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xslice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">X</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y2slice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># now update the datalim and autoscale</span>
        <span class="n">XY1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y1</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">XY2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y2</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">XY1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">XY2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x1&quot;</span><span class="p">,</span> <span class="s2">&quot;x2&quot;</span><span class="p">,</span> <span class="s2">&quot;where&quot;</span><span class="p">],</span>
                         <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.fill_betweenx"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.fill_betweenx.html#mpl.axes.Axes.fill_betweenx">[docs]</a>    <span class="k">def</span> <span class="nf">fill_betweenx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                      <span class="n">step</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make filled polygons between two horizontal curves.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          fill_betweenx(y, x1, x2=0, where=None, **kwargs)</span>

<span class="sd">        Create a :class:`~matplotlib.collections.PolyCollection`</span>
<span class="sd">        filling the regions between *x1* and *x2* where</span>
<span class="sd">        ``where==True``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        y : array</span>
<span class="sd">            An N-length array of the y data</span>

<span class="sd">        x1 : array</span>
<span class="sd">            An N-length array (or scalar) of the x data</span>

<span class="sd">        x2 : array, optional</span>
<span class="sd">            An N-length array (or scalar) of the x data</span>

<span class="sd">        where : array, optional</span>
<span class="sd">            If *None*, default to fill between everywhere.  If not *None*,</span>
<span class="sd">            it is a N length numpy boolean array and the fill will</span>
<span class="sd">            only happen over the regions where ``where==True``</span>

<span class="sd">        step : {&#39;pre&#39;, &#39;post&#39;, &#39;mid&#39;}, optional</span>
<span class="sd">            If not None, fill with step logic.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        keyword args passed on to the</span>
<span class="sd">            :class:`~matplotlib.collections.PolyCollection`</span>

<span class="sd">        kwargs control the :class:`~matplotlib.patches.Polygon` properties:</span>

<span class="sd">        %(PolyCollection)s</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/fill_betweenx_demo.py</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>

<span class="sd">            :meth:`fill_between`</span>
<span class="sd">                for filling between two sets of y-values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Handle united data, such as dates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">xdata</span><span class="o">=</span><span class="n">x1</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x2</span><span class="p">)</span>

        <span class="c1"># Convert the arrays so we can work with them</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x1</span><span class="p">))</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x2</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">x1</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">x1</span>
        <span class="k">if</span> <span class="n">x2</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">x2</span>

        <span class="k">if</span> <span class="n">where</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">where</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x1</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x2</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">where</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument dimensions are incompatible&quot;</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">mask_or</span><span class="p">,</span> <span class="p">[</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">ma</span><span class="o">.</span><span class="n">nomask</span><span class="p">:</span>
            <span class="n">where</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">mask</span>

        <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind0</span><span class="p">,</span> <span class="n">ind1</span> <span class="ow">in</span> <span class="n">mlab</span><span class="o">.</span><span class="n">contiguous_regions</span><span class="p">(</span><span class="n">where</span><span class="p">):</span>
            <span class="n">yslice</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">x1slice</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="n">x2slice</span> <span class="o">=</span> <span class="n">x2</span><span class="p">[</span><span class="n">ind0</span><span class="p">:</span><span class="n">ind1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">step_func</span> <span class="o">=</span> <span class="n">STEP_LOOKUP_MAP</span><span class="p">[</span><span class="n">step</span><span class="p">]</span>
                <span class="n">yslice</span><span class="p">,</span> <span class="n">x1slice</span><span class="p">,</span> <span class="n">x2slice</span> <span class="o">=</span> <span class="n">step_func</span><span class="p">(</span><span class="n">yslice</span><span class="p">,</span> <span class="n">x1slice</span><span class="p">,</span> <span class="n">x2slice</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">yslice</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">yslice</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

            <span class="c1"># the purpose of the next two lines is for when x2 is a</span>
            <span class="c1"># scalar like 0 and we want the fill to go all the way</span>
            <span class="c1"># down to 0 even if none of the x1 sample points do</span>
            <span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2slice</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yslice</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2slice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yslice</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x1slice</span>
            <span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yslice</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x2slice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">Y</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yslice</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">polys</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># now update the datalim and autoscale</span>
        <span class="n">X1Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x1</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="n">X2Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x2</span><span class="p">[</span><span class="n">where</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">where</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">X1Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">X2Y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignore_existing_data_limits</span><span class="p">,</span>
                                         <span class="n">updatex</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collection</span></div>

    <span class="c1">#### plotting z(x,y): imshow, pcolor and relatives, contour</span>
    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.imshow"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.imshow.html#mpl.axes.Axes.imshow">[docs]</a>    <span class="k">def</span> <span class="nf">imshow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">interpolation</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">origin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filternorm</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
               <span class="n">filterrad</span><span class="o">=</span><span class="mf">4.0</span><span class="p">,</span> <span class="n">imlim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">resample</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display an image on the axes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        X : array_like, shape (n, m) or (n, m, 3) or (n, m, 4)</span>
<span class="sd">            Display the image in `X` to current axes.  `X` may be a float</span>
<span class="sd">            array, a uint8 array or a PIL image. If `X` is an array, it</span>
<span class="sd">            can have the following shapes:</span>

<span class="sd">            - MxN -- luminance (grayscale, float array only)</span>
<span class="sd">            - MxNx3 -- RGB (float or uint8 array)</span>
<span class="sd">            - MxNx4 -- RGBA (float or uint8 array)</span>

<span class="sd">            The value for each component of MxNx3 and MxNx4 float arrays</span>
<span class="sd">            should be in the range 0.0 to 1.0; MxN float arrays may be</span>
<span class="sd">            normalised.</span>

<span class="sd">        cmap : `~matplotlib.colors.Colormap`, optional, default: None</span>
<span class="sd">            If None, default to rc `image.cmap` value. `cmap` is ignored when</span>
<span class="sd">            `X` has RGB(A) information</span>

<span class="sd">        aspect : [&#39;auto&#39; | &#39;equal&#39; | scalar], optional, default: None</span>
<span class="sd">            If &#39;auto&#39;, changes the image aspect ratio to match that of the</span>
<span class="sd">            axes.</span>

<span class="sd">            If &#39;equal&#39;, and `extent` is None, changes the axes aspect ratio to</span>
<span class="sd">            match that of the image. If `extent` is not `None`, the axes</span>
<span class="sd">            aspect ratio is changed to match that of the extent.</span>

<span class="sd">            If None, default to rc ``image.aspect`` value.</span>

<span class="sd">        interpolation : string, optional, default: None</span>
<span class="sd">            Acceptable values are &#39;none&#39;, &#39;nearest&#39;, &#39;bilinear&#39;, &#39;bicubic&#39;,</span>
<span class="sd">            &#39;spline16&#39;, &#39;spline36&#39;, &#39;hanning&#39;, &#39;hamming&#39;, &#39;hermite&#39;, &#39;kaiser&#39;,</span>
<span class="sd">            &#39;quadric&#39;, &#39;catrom&#39;, &#39;gaussian&#39;, &#39;bessel&#39;, &#39;mitchell&#39;, &#39;sinc&#39;,</span>
<span class="sd">            &#39;lanczos&#39;</span>

<span class="sd">            If `interpolation` is None, default to rc `image.interpolation`.</span>
<span class="sd">            See also the `filternorm` and `filterrad` parameters.</span>
<span class="sd">            If `interpolation` is &#39;none&#39;, then no interpolation is performed</span>
<span class="sd">            on the Agg, ps and pdf backends. Other backends will fall back to</span>
<span class="sd">            &#39;nearest&#39;.</span>

<span class="sd">        norm : `~matplotlib.colors.Normalize`, optional, default: None</span>
<span class="sd">            A `~matplotlib.colors.Normalize` instance is used to scale</span>
<span class="sd">            luminance data to 0, 1. If `None`, use the default</span>
<span class="sd">            func:`normalize`. `norm` is only used if `X` is an array of</span>
<span class="sd">            floats.</span>

<span class="sd">        vmin, vmax : scalar, optional, default: None</span>
<span class="sd">            `vmin` and `vmax` are used in conjunction with norm to normalize</span>
<span class="sd">            luminance data.  Note if you pass a `norm` instance, your</span>
<span class="sd">            settings for `vmin` and `vmax` will be ignored.</span>

<span class="sd">        alpha : scalar, optional, default: None</span>
<span class="sd">            The alpha blending value, between 0 (transparent) and 1 (opaque)</span>

<span class="sd">        origin : [&#39;upper&#39; | &#39;lower&#39;], optional, default: None</span>
<span class="sd">            Place the [0,0] index of the array in the upper left or lower left</span>
<span class="sd">            corner of the axes. If None, default to rc `image.origin`.</span>

<span class="sd">        extent : scalars (left, right, bottom, top), optional, default: None</span>
<span class="sd">            The location, in data-coordinates, of the lower-left and</span>
<span class="sd">            upper-right corners. If `None`, the image is positioned such that</span>
<span class="sd">            the pixel centers fall on zero-based (row, column) indices.</span>

<span class="sd">        shape : scalars (columns, rows), optional, default: None</span>
<span class="sd">            For raw buffer images</span>

<span class="sd">        filternorm : scalar, optional, default: 1</span>
<span class="sd">            A parameter for the antigrain image resize filter.  From the</span>
<span class="sd">            antigrain documentation, if `filternorm` = 1, the filter</span>
<span class="sd">            normalizes integer values and corrects the rounding errors. It</span>
<span class="sd">            doesn&#39;t do anything with the source floating point values, it</span>
<span class="sd">            corrects only integers according to the rule of 1.0 which means</span>
<span class="sd">            that any sum of pixel weights must be equal to 1.0.  So, the</span>
<span class="sd">            filter function must produce a graph of the proper shape.</span>

<span class="sd">        filterrad : scalar, optional, default: 4.0</span>
<span class="sd">            The filter radius for filters that have a radius parameter, i.e.</span>
<span class="sd">            when interpolation is one of: &#39;sinc&#39;, &#39;lanczos&#39; or &#39;blackman&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        image : `~matplotlib.image.AxesImage`</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs : `~matplotlib.artist.Artist` properties.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        matshow : Plot a matrix or an array as an image.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Unless *extent* is used, pixel centers will be located at integer</span>
<span class="sd">        coordinates. In other words: the origin will coincide with the center</span>
<span class="sd">        of pixel (0, 0).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/image_demo.py</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">aspect</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">aspect</span> <span class="o">=</span> <span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.aspect&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">AxesImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span>
                              <span class="n">filternorm</span><span class="o">=</span><span class="n">filternorm</span><span class="p">,</span> <span class="n">filterrad</span><span class="o">=</span><span class="n">filterrad</span><span class="p">,</span>
                              <span class="n">resample</span><span class="o">=</span><span class="n">resample</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">im</span><span class="o">.</span><span class="n">get_clip_path</span><span class="p">()</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># image does not already have clipping set, clip to axes patch</span>
            <span class="n">im</span><span class="o">.</span><span class="n">set_clip_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">patch</span><span class="p">)</span>
        <span class="c1">#if norm is None and shape is None:</span>
        <span class="c1">#    im.set_clim(vmin, vmax)</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">im</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_url</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>

        <span class="c1"># update ax.dataLim, and, if autoscaling, set viewLim</span>
        <span class="c1"># to tightly fit the image, regardless of dataLim.</span>
        <span class="n">im</span><span class="o">.</span><span class="n">set_extent</span><span class="p">(</span><span class="n">im</span><span class="o">.</span><span class="n">get_extent</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">im</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_pcolorargs</span><span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="c1"># This takes one kwarg, allmatch.</span>
        <span class="c1"># If allmatch is True, then the incoming X, Y, C must</span>
        <span class="c1"># have matching dimensions, taking into account that</span>
        <span class="c1"># X and Y can be 1-D rather than 2-D.  This perfect</span>
        <span class="c1"># match is required for Gouroud shading.  For flat</span>
        <span class="c1"># shading, X and Y specify boundaries, so we need</span>
        <span class="c1"># one more boundary than color in each direction.</span>
        <span class="c1"># For convenience, and consistent with Matlab, we</span>
        <span class="c1"># discard the last row and/or column of C if necessary</span>
        <span class="c1"># to meet this condition.  This is done if allmatch</span>
        <span class="c1"># is False.</span>

        <span class="n">allmatch</span> <span class="o">=</span> <span class="n">kw</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;allmatch&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">numRows</span><span class="p">,</span> <span class="n">numCols</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="n">allmatch</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numCols</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numRows</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numCols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">numRows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">numRows</span><span class="p">,</span> <span class="n">numCols</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Illegal arguments to </span><span class="si">%s</span><span class="s1">; see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">funcname</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>

        <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">Ny</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">Y</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                <span class="s1">&#39;Incompatible X, Y inputs to </span><span class="si">%s</span><span class="s1">; see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">funcname</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">allmatch</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">Nx</span> <span class="o">==</span> <span class="n">numCols</span> <span class="ow">and</span> <span class="n">Ny</span> <span class="o">==</span> <span class="n">numRows</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Dimensions of C </span><span class="si">%s</span><span class="s1"> are incompatible with&#39;</span>
                                <span class="s1">&#39; X (</span><span class="si">%d</span><span class="s1">) and/or Y (</span><span class="si">%d</span><span class="s1">); see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">numCols</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">numRows</span> <span class="ow">in</span> <span class="p">(</span><span class="n">Ny</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Dimensions of C </span><span class="si">%s</span><span class="s1"> are incompatible with&#39;</span>
                                <span class="s1">&#39; X (</span><span class="si">%d</span><span class="s1">) and/or Y (</span><span class="si">%d</span><span class="s1">); see help(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
                                    <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">funcname</span><span class="p">))</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="p">[:</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.pcolor"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.pcolor.html#mpl.axes.Axes.pcolor">[docs]</a>    <span class="k">def</span> <span class="nf">pcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pseudocolor plot of a 2-D array.</span>

<span class="sd">        .. note::</span>

<span class="sd">            pcolor can be very slow for large arrays; consider</span>
<span class="sd">            using the similar but much faster</span>
<span class="sd">            :func:`~matplotlib.pyplot.pcolormesh` instead.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">          pcolor(C, **kwargs)</span>
<span class="sd">          pcolor(X, Y, C, **kwargs)</span>

<span class="sd">        *C* is the array of color values.</span>

<span class="sd">        *X* and *Y*, if given, specify the (*x*, *y*) coordinates of</span>
<span class="sd">        the colored quadrilaterals; the quadrilateral for C[i,j] has</span>
<span class="sd">        corners at::</span>

<span class="sd">          (X[i,   j],   Y[i,   j]),</span>
<span class="sd">          (X[i,   j+1], Y[i,   j+1]),</span>
<span class="sd">          (X[i+1, j],   Y[i+1, j]),</span>
<span class="sd">          (X[i+1, j+1], Y[i+1, j+1]).</span>

<span class="sd">        Ideally the dimensions of *X* and *Y* should be one greater</span>
<span class="sd">        than those of *C*; if the dimensions are the same, then the</span>
<span class="sd">        last row and column of *C* will be ignored.</span>

<span class="sd">        Note that the column index corresponds to the</span>
<span class="sd">        *x*-coordinate, and the row index corresponds to *y*; for</span>
<span class="sd">        details, see the :ref:`Grid Orientation</span>
<span class="sd">        &lt;axes-pcolor-grid-orientation&gt;` section below.</span>

<span class="sd">        If either or both of *X* and *Y* are 1-D arrays or column vectors,</span>
<span class="sd">        they will be expanded as needed into the appropriate 2-D arrays,</span>
<span class="sd">        making a rectangular grid.</span>

<span class="sd">        *X*, *Y* and *C* may be masked arrays.  If either C[i, j], or one</span>
<span class="sd">        of the vertices surrounding C[i,j] (*X* or *Y* at [i, j], [i+1, j],</span>
<span class="sd">        [i, j+1],[i+1, j+1]) is masked, nothing is plotted.</span>

<span class="sd">        Keyword arguments:</span>

<span class="sd">          *cmap*: [ *None* | Colormap ]</span>
<span class="sd">            A :class:`matplotlib.colors.Colormap` instance. If *None*, use</span>
<span class="sd">            rc settings.</span>

<span class="sd">          *norm*: [ *None* | Normalize ]</span>
<span class="sd">            An :class:`matplotlib.colors.Normalize` instance is used</span>
<span class="sd">            to scale luminance data to 0,1. If *None*, defaults to</span>
<span class="sd">            :func:`normalize`.</span>

<span class="sd">          *vmin*/*vmax*: [ *None* | scalar ]</span>
<span class="sd">            *vmin* and *vmax* are used in conjunction with *norm* to</span>
<span class="sd">            normalize luminance data.  If either is *None*, it</span>
<span class="sd">            is autoscaled to the respective min or max</span>
<span class="sd">            of the color array *C*.  If not *None*, *vmin* or</span>
<span class="sd">            *vmax* passed in here override any pre-existing values</span>
<span class="sd">            supplied in the *norm* instance.</span>

<span class="sd">          *shading*: [ &#39;flat&#39; | &#39;faceted&#39; ]</span>
<span class="sd">            If &#39;faceted&#39;, a black grid is drawn around each rectangle; if</span>
<span class="sd">            &#39;flat&#39;, edges are not drawn. Default is &#39;flat&#39;, contrary to</span>
<span class="sd">            MATLAB.</span>

<span class="sd">            This kwarg is deprecated; please use &#39;edgecolors&#39; instead:</span>
<span class="sd">              * shading=&#39;flat&#39; -- edgecolors=&#39;none&#39;</span>
<span class="sd">              * shading=&#39;faceted  -- edgecolors=&#39;k&#39;</span>

<span class="sd">          *edgecolors*: [ *None* | ``&#39;none&#39;`` | color | color sequence]</span>
<span class="sd">            If *None*, the rc setting is used by default.</span>

<span class="sd">            If ``&#39;none&#39;``, edges will not be visible.</span>

<span class="sd">            An mpl color or sequence of colors will set the edge color</span>

<span class="sd">          *alpha*: ``0 &lt;= scalar &lt;= 1``   or *None*</span>
<span class="sd">            the alpha blending value</span>

<span class="sd">          *snap*: bool</span>
<span class="sd">            Whether to snap the mesh to pixel boundaries.</span>

<span class="sd">        Return value is a :class:`matplotlib.collections.Collection`</span>
<span class="sd">        instance.</span>

<span class="sd">        .. _axes-pcolor-grid-orientation:</span>

<span class="sd">        The grid orientation follows the MATLAB convention: an</span>
<span class="sd">        array *C* with shape (*nrows*, *ncolumns*) is plotted with</span>
<span class="sd">        the column number as *X* and the row number as *Y*, increasing</span>
<span class="sd">        up; hence it is plotted the way the array would be printed,</span>
<span class="sd">        except that the *Y* axis is reversed.  That is, *C* is taken</span>
<span class="sd">        as *C*(*y*, *x*).</span>

<span class="sd">        Similarly for :func:`meshgrid`::</span>

<span class="sd">          x = np.arange(5)</span>
<span class="sd">          y = np.arange(3)</span>
<span class="sd">          X, Y = np.meshgrid(x, y)</span>

<span class="sd">        is equivalent to::</span>

<span class="sd">          X = array([[0, 1, 2, 3, 4],</span>
<span class="sd">                     [0, 1, 2, 3, 4],</span>
<span class="sd">                     [0, 1, 2, 3, 4]])</span>

<span class="sd">          Y = array([[0, 0, 0, 0, 0],</span>
<span class="sd">                     [1, 1, 1, 1, 1],</span>
<span class="sd">                     [2, 2, 2, 2, 2]])</span>

<span class="sd">        so if you have::</span>

<span class="sd">          C = rand(len(x), len(y))</span>

<span class="sd">        then you need to transpose C::</span>

<span class="sd">          pcolor(X, Y, C.T)</span>

<span class="sd">        or::</span>

<span class="sd">          pcolor(C.T)</span>

<span class="sd">        MATLAB :func:`pcolor` always discards the last row and column</span>
<span class="sd">        of *C*, but matplotlib displays the last row and column if *X* and</span>
<span class="sd">        *Y* are not specified, or if *X* and *Y* have one more row and</span>
<span class="sd">        column than *C*.</span>

<span class="sd">        kwargs can be used to control the</span>
<span class="sd">        :class:`~matplotlib.collections.PolyCollection` properties:</span>

<span class="sd">        %(PolyCollection)s</span>

<span class="sd">        .. note::</span>

<span class="sd">            The default *antialiaseds* is False if the default</span>
<span class="sd">            *edgecolors*=&quot;none&quot; is used.  This eliminates artificial lines</span>
<span class="sd">            at patch boundaries, and works regardless of the value of</span>
<span class="sd">            alpha.  If *edgecolors* is not &quot;none&quot;, then the default</span>
<span class="sd">            *antialiaseds* is taken from</span>
<span class="sd">            rcParams[&#39;patch.antialiased&#39;], which defaults to *True*.</span>
<span class="sd">            Stroking the edges may be preferred if *alpha* is 1, but</span>
<span class="sd">            will cause artifacts otherwise.</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`~matplotlib.pyplot.pcolormesh`</span>
<span class="sd">                For an explanation of the differences between</span>
<span class="sd">                pcolor and pcolormesh.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;cmap&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vmin&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vmax&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;shading&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">cbook</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span>
                <span class="s1">&#39;1.2&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;shading&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">,</span>
                <span class="n">obj_type</span><span class="o">=</span><span class="s1">&#39;option&#39;</span><span class="p">)</span>
        <span class="n">shading</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;shading&#39;</span><span class="p">,</span> <span class="s1">&#39;flat&#39;</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pcolorargs</span><span class="p">(</span><span class="s1">&#39;pcolor&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allmatch</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># unit conversion allows e.g. datetime objects as axis values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="c1"># convert to MA, if necessary.</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">+</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">xymask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span>
                  <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># don&#39;t plot if C or any of the surrounding vertices are masked.</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">C</span><span class="p">)</span> <span class="o">+</span> <span class="n">xymask</span>

        <span class="n">newaxis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span>
        <span class="n">compress</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span>

        <span class="n">ravelmask</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">X1</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">Y1</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">X2</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">Y2</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">X3</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">Y3</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">X4</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">Y4</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">Y</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">npoly</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X1</span><span class="p">)</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">X1</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y1</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span>
                             <span class="n">X2</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y2</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span>
                             <span class="n">X3</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y3</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span>
                             <span class="n">X4</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y4</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span>
                             <span class="n">X1</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">Y1</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">]),</span>
                            <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="n">xy</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">npoly</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravelmask</span><span class="p">,</span> <span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">C</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="n">linewidths</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.25</span><span class="p">,)</span>
        <span class="k">if</span> <span class="s1">&#39;linewidth&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;linewidths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;linewidth&#39;</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;linewidths&#39;</span><span class="p">,</span> <span class="n">linewidths</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">shading</span> <span class="o">==</span> <span class="s1">&#39;faceted&#39;</span><span class="p">:</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edgecolors</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span>

        <span class="k">if</span> <span class="s1">&#39;edgecolor&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;edgecolor&#39;</span><span class="p">)</span>
        <span class="n">ec</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">,</span> <span class="n">edgecolors</span><span class="p">)</span>

        <span class="c1"># aa setting will default via collections to patch.antialiased</span>
        <span class="c1"># unless the boundary is not stroked, in which case the</span>
        <span class="c1"># default will be False; with unstroked boundaries, aa</span>
        <span class="c1"># makes artifacts that are often disturbing.</span>
        <span class="k">if</span> <span class="s1">&#39;antialiased&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;antialiaseds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;antialiased&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;antialiaseds&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="p">(</span><span class="n">is_string_like</span><span class="p">(</span><span class="n">ec</span><span class="p">)</span> <span class="ow">and</span>
                                             <span class="n">ec</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;antialiaseds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;snap&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PolyCollection</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span>

        <span class="c1"># Transform from native to data coordinates?</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">_transform</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;_as_mpl_transform&#39;</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">)):</span>
            <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">minx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collection</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.pcolormesh"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.pcolormesh.html#mpl.axes.Axes.pcolormesh">[docs]</a>    <span class="k">def</span> <span class="nf">pcolormesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a quadrilateral mesh.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">          pcolormesh(C)</span>
<span class="sd">          pcolormesh(X, Y, C)</span>
<span class="sd">          pcolormesh(C, **kwargs)</span>

<span class="sd">        Create a pseudocolor plot of a 2-D array.</span>

<span class="sd">        pcolormesh is similar to :func:`~matplotlib.pyplot.pcolor`,</span>
<span class="sd">        but uses a different mechanism and returns a different</span>
<span class="sd">        object; pcolor returns a</span>
<span class="sd">        :class:`~matplotlib.collections.PolyCollection` but pcolormesh</span>
<span class="sd">        returns a</span>
<span class="sd">        :class:`~matplotlib.collections.QuadMesh`.  It is much faster,</span>
<span class="sd">        so it is almost always preferred for large arrays.</span>

<span class="sd">        *C* may be a masked array, but *X* and *Y* may not.  Masked</span>
<span class="sd">        array support is implemented via *cmap* and *norm*; in</span>
<span class="sd">        contrast, :func:`~matplotlib.pyplot.pcolor` simply does not</span>
<span class="sd">        draw quadrilaterals with masked colors or vertices.</span>

<span class="sd">        Keyword arguments:</span>

<span class="sd">          *cmap*: [ *None* | Colormap ]</span>
<span class="sd">            A :class:`matplotlib.colors.Colormap` instance. If *None*, use</span>
<span class="sd">            rc settings.</span>

<span class="sd">          *norm*: [ *None* | Normalize ]</span>
<span class="sd">            A :class:`matplotlib.colors.Normalize` instance is used to</span>
<span class="sd">            scale luminance data to 0,1. If *None*, defaults to</span>
<span class="sd">            :func:`normalize`.</span>

<span class="sd">          *vmin*/*vmax*: [ *None* | scalar ]</span>
<span class="sd">            *vmin* and *vmax* are used in conjunction with *norm* to</span>
<span class="sd">            normalize luminance data.  If either is *None*, it</span>
<span class="sd">            is autoscaled to the respective min or max</span>
<span class="sd">            of the color array *C*.  If not *None*, *vmin* or</span>
<span class="sd">            *vmax* passed in here override any pre-existing values</span>
<span class="sd">            supplied in the *norm* instance.</span>

<span class="sd">          *shading*: [ &#39;flat&#39; | &#39;gouraud&#39; ]</span>
<span class="sd">            &#39;flat&#39; indicates a solid color for each quad.  When</span>
<span class="sd">            &#39;gouraud&#39;, each quad will be Gouraud shaded.  When gouraud</span>
<span class="sd">            shading, edgecolors is ignored.</span>

<span class="sd">          *edgecolors*: [*None* | ``&#39;None&#39;`` | ``&#39;face&#39;`` | color |</span>
<span class="sd">                         color sequence]</span>

<span class="sd">            If *None*, the rc setting is used by default.</span>

<span class="sd">            If ``&#39;None&#39;``, edges will not be visible.</span>

<span class="sd">            If ``&#39;face&#39;``, edges will have the same color as the faces.</span>

<span class="sd">            An mpl color or sequence of colors will set the edge color</span>

<span class="sd">          *alpha*: ``0 &lt;= scalar &lt;= 1``  or *None*</span>
<span class="sd">            the alpha blending value</span>

<span class="sd">        Return value is a :class:`matplotlib.collections.QuadMesh`</span>
<span class="sd">        object.</span>

<span class="sd">        kwargs can be used to control the</span>
<span class="sd">        :class:`matplotlib.collections.QuadMesh` properties:</span>

<span class="sd">        %(QuadMesh)s</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`~matplotlib.pyplot.pcolor`</span>
<span class="sd">                For an explanation of the grid orientation and the</span>
<span class="sd">                expansion of 1-D *X* and/or *Y* to 2-D arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;cmap&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vmin&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vmax&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">shading</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;shading&#39;</span><span class="p">,</span> <span class="s1">&#39;flat&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">antialiased</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;antialiased&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s1">&#39;edgecolors&#39;</span><span class="p">,</span> <span class="s1">&#39;None&#39;</span><span class="p">)</span>

        <span class="n">allmatch</span> <span class="o">=</span> <span class="p">(</span><span class="n">shading</span> <span class="o">==</span> <span class="s1">&#39;gouraud&#39;</span><span class="p">)</span>

        <span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pcolorargs</span><span class="p">(</span><span class="s1">&#39;pcolormesh&#39;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">allmatch</span><span class="o">=</span><span class="n">allmatch</span><span class="p">)</span>
        <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># convert to one dimensional arrays</span>
        <span class="n">C</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># unit conversion allows e.g. datetime objects as axis values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">Y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(((</span><span class="n">Nx</span> <span class="o">*</span> <span class="n">Ny</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
        <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Y</span>

        <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">QuadMesh</span><span class="p">(</span>
            <span class="n">Nx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span>
            <span class="n">antialiased</span><span class="o">=</span><span class="n">antialiased</span><span class="p">,</span> <span class="n">shading</span><span class="o">=</span><span class="n">shading</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="n">collection</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

        <span class="c1"># Transform from native to data coordinates?</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">_transform</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">mtransforms</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span> <span class="ow">and</span>
            <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;_as_mpl_transform&#39;</span><span class="p">)):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transData</span><span class="p">)):</span>
            <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">transData</span>
            <span class="n">pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

        <span class="n">minx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

        <span class="n">corners</span> <span class="o">=</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">collection</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.pcolorfast"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.pcolorfast.html#mpl.axes.Axes.pcolorfast">[docs]</a>    <span class="k">def</span> <span class="nf">pcolorfast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        pseudocolor plot of a 2-D array</span>

<span class="sd">        Experimental; this is a pcolor-type method that</span>
<span class="sd">        provides the fastest possible rendering with the Agg</span>
<span class="sd">        backend, and that can handle any quadrilateral grid.</span>
<span class="sd">        It supports only flat shading (no outlines), it lacks</span>
<span class="sd">        support for log scaling of the axes, and it does not</span>
<span class="sd">        have a pyplot wrapper.</span>

<span class="sd">        Call signatures::</span>

<span class="sd">          ax.pcolorfast(C, **kwargs)</span>
<span class="sd">          ax.pcolorfast(xr, yr, C, **kwargs)</span>
<span class="sd">          ax.pcolorfast(x, y, C, **kwargs)</span>
<span class="sd">          ax.pcolorfast(X, Y, C, **kwargs)</span>

<span class="sd">        C is the 2D array of color values corresponding to quadrilateral</span>
<span class="sd">        cells. Let (nr, nc) be its shape.  C may be a masked array.</span>

<span class="sd">        ``ax.pcolorfast(C, **kwargs)`` is equivalent to</span>
<span class="sd">        ``ax.pcolorfast([0,nc], [0,nr], C, **kwargs)``</span>

<span class="sd">        *xr*, *yr* specify the ranges of *x* and *y* corresponding to the</span>
<span class="sd">        rectangular region bounding *C*.  If::</span>

<span class="sd">            xr = [x0, x1]</span>

<span class="sd">        and::</span>

<span class="sd">            yr = [y0,y1]</span>

<span class="sd">        then *x* goes from *x0* to *x1* as the second index of *C* goes</span>
<span class="sd">        from 0 to *nc*, etc.  (*x0*, *y0*) is the outermost corner of</span>
<span class="sd">        cell (0,0), and (*x1*, *y1*) is the outermost corner of cell</span>
<span class="sd">        (*nr*-1, *nc*-1).  All cells are rectangles of the same size.</span>
<span class="sd">        This is the fastest version.</span>

<span class="sd">        *x*, *y* are 1D arrays of length *nc* +1 and *nr* +1, respectively,</span>
<span class="sd">        giving the x and y boundaries of the cells.  Hence the cells are</span>
<span class="sd">        rectangular but the grid may be nonuniform.  The speed is</span>
<span class="sd">        intermediate.  (The grid is checked, and if found to be</span>
<span class="sd">        uniform the fast version is used.)</span>

<span class="sd">        *X* and *Y* are 2D arrays with shape (*nr* +1, *nc* +1) that specify</span>
<span class="sd">        the (x,y) coordinates of the corners of the colored</span>
<span class="sd">        quadrilaterals; the quadrilateral for C[i,j] has corners at</span>
<span class="sd">        (X[i,j],Y[i,j]), (X[i,j+1],Y[i,j+1]), (X[i+1,j],Y[i+1,j]),</span>
<span class="sd">        (X[i+1,j+1],Y[i+1,j+1]).  The cells need not be rectangular.</span>
<span class="sd">        This is the most general, but the slowest to render.  It may</span>
<span class="sd">        produce faster and more compact output using ps, pdf, and</span>
<span class="sd">        svg backends, however.</span>

<span class="sd">        Note that the column index corresponds to the x-coordinate,</span>
<span class="sd">        and the row index corresponds to y; for details, see</span>
<span class="sd">        the &quot;Grid Orientation&quot; section below.</span>

<span class="sd">        Optional keyword arguments:</span>

<span class="sd">          *cmap*: [ *None* | Colormap ]</span>
<span class="sd">            A :class:`matplotlib.colors.Colormap` instance from cm. If *None*,</span>
<span class="sd">            use rc settings.</span>

<span class="sd">          *norm*: [ *None* | Normalize ]</span>
<span class="sd">            A :class:`matplotlib.colors.Normalize` instance is used to scale</span>
<span class="sd">            luminance data to 0,1. If *None*, defaults to normalize()</span>

<span class="sd">          *vmin*/*vmax*: [ *None* | scalar ]</span>
<span class="sd">            *vmin* and *vmax* are used in conjunction with norm to normalize</span>
<span class="sd">            luminance data.  If either are *None*, the min and max</span>
<span class="sd">            of the color array *C* is used.  If you pass a norm instance,</span>
<span class="sd">            *vmin* and *vmax* will be *None*.</span>

<span class="sd">          *alpha*: ``0 &lt;= scalar &lt;= 1``  or *None*</span>
<span class="sd">            the alpha blending value</span>

<span class="sd">        Return value is an image if a regular or rectangular grid</span>
<span class="sd">        is specified, and a :class:`~matplotlib.collections.QuadMesh`</span>
<span class="sd">        collection in the general quadrilateral case.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;cmap&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vmin&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;vmax&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;norm&#39; must be an instance of &#39;mcolors.Normalize&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">C</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nc</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">nr</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dx</span><span class="o">.</span><span class="n">mean</span><span class="p">())</span> <span class="ow">and</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dy</span><span class="o">.</span><span class="n">mean</span><span class="p">())):</span>
                        <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;image&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;pcolorimage&quot;</span>
            <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">style</span> <span class="o">=</span> <span class="s2">&quot;quadmesh&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;arguments do not match valid signatures&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;need 1 argument or 3 arguments&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;quadmesh&quot;</span><span class="p">:</span>

            <span class="c1"># convert to one dimensional arrays</span>
            <span class="c1"># This should also be moved to the QuadMesh class</span>

            <span class="c1"># data point in each cell is value at lower left corner</span>
            <span class="n">C</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">Nx</span> <span class="o">=</span> <span class="n">nc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">Ny</span> <span class="o">=</span> <span class="n">nr</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># The following needs to be cleaned up; the renderer</span>
            <span class="c1"># requires separate contiguous arrays for X and Y,</span>
            <span class="c1"># but the QuadMesh class requires the 2D array.</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(((</span><span class="n">Nx</span> <span class="o">*</span> <span class="n">Ny</span><span class="p">),</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">X</span>
            <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Y</span>

            <span class="c1"># The QuadMesh class can also be changed to</span>
            <span class="c1"># handle relevant superclass kwargs; the initializer</span>
            <span class="c1"># should do much more than it does now.</span>
            <span class="n">collection</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">QuadMesh</span><span class="p">(</span><span class="n">nc</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">coords</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">edgecolors</span><span class="o">=</span><span class="s2">&quot;None&quot;</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_cmap</span><span class="p">(</span><span class="n">cmap</span><span class="p">)</span>
            <span class="n">collection</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">norm</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">X</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">Y</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">collection</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># One of the image styles:</span>
            <span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span>

            <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">AxesImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">norm</span><span class="p">,</span>
                                        <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
                                        <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;lower&#39;</span><span class="p">,</span>
                                        <span class="n">extent</span><span class="o">=</span><span class="p">(</span><span class="n">xl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yb</span><span class="p">,</span> <span class="n">yt</span><span class="p">),</span>
                                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">im</span><span class="o">.</span><span class="n">set_data</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
            <span class="n">im</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">im</span>

        <span class="k">if</span> <span class="n">style</span> <span class="o">==</span> <span class="s2">&quot;pcolorimage&quot;</span><span class="p">:</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">mimage</span><span class="o">.</span><span class="n">PcolorImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span>
                                    <span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                                    <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                                    <span class="n">alpha</span><span class="o">=</span><span class="n">alpha</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_image</span><span class="p">(</span><span class="n">im</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">im</span>

        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">set_clim</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xl</span><span class="p">,</span> <span class="n">yb</span><span class="p">],</span> <span class="p">[</span><span class="n">xr</span><span class="p">,</span> <span class="n">yt</span><span class="p">]]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">()</span>
<div class="viewcode-block" id="Axes.contour"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.contour.html#mpl.axes.Axes.contour">[docs]</a>    <span class="k">def</span> <span class="nf">contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;filled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">contour</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="o">.</span><span class="n">contour_doc</span>

    <span class="nd">@unpack_labeled_data</span><span class="p">()</span>
<div class="viewcode-block" id="Axes.contourf"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.contourf.html#mpl.axes.Axes.contourf">[docs]</a>    <span class="k">def</span> <span class="nf">contourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;filled&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">contourf</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">QuadContourSet</span><span class="o">.</span><span class="n">contour_doc</span>

<div class="viewcode-block" id="Axes.clabel"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.clabel.html#mpl.axes.Axes.clabel">[docs]</a>    <span class="k">def</span> <span class="nf">clabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CS</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CS</span><span class="o">.</span><span class="n">clabel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">clabel</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mcontour</span><span class="o">.</span><span class="n">ContourSet</span><span class="o">.</span><span class="n">clabel</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.table"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.table.html#mpl.axes.Axes.table">[docs]</a>    <span class="k">def</span> <span class="nf">table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a table to the current axes.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          table(cellText=None, cellColours=None,</span>
<span class="sd">                cellLoc=&#39;right&#39;, colWidths=None,</span>
<span class="sd">                rowLabels=None, rowColours=None, rowLoc=&#39;left&#39;,</span>
<span class="sd">                colLabels=None, colColours=None, colLoc=&#39;center&#39;,</span>
<span class="sd">                loc=&#39;bottom&#39;, bbox=None):</span>

<span class="sd">        Returns a :class:`matplotlib.table.Table` instance.  For finer</span>
<span class="sd">        grained control over tables, use the</span>
<span class="sd">        :class:`~matplotlib.table.Table` class and add it to the axes</span>
<span class="sd">        with :meth:`~matplotlib.axes.Axes.add_table`.</span>

<span class="sd">        Thanks to John Gill for providing the class and table.</span>

<span class="sd">        kwargs control the :class:`~matplotlib.table.Table`</span>
<span class="sd">        properties:</span>

<span class="sd">        %(Table)s</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">mtable</span><span class="o">.</span><span class="n">table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1">#### Data analysis</span>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.hist"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.hist.html#mpl.axes.Axes.hist">[docs]</a>    <span class="k">def</span> <span class="nf">hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">cumulative</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">histtype</span><span class="o">=</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;mid&#39;</span><span class="p">,</span>
             <span class="n">orientation</span><span class="o">=</span><span class="s1">&#39;vertical&#39;</span><span class="p">,</span> <span class="n">rwidth</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">color</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stacked</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a histogram.</span>

<span class="sd">        Compute and draw the histogram of *x*. The return value is a</span>
<span class="sd">        tuple (*n*, *bins*, *patches*) or ([*n0*, *n1*, ...], *bins*,</span>
<span class="sd">        [*patches0*, *patches1*,...]) if the input contains multiple</span>
<span class="sd">        data.</span>

<span class="sd">        Multiple data can be provided via *x* as a list of datasets</span>
<span class="sd">        of potentially different length ([*x0*, *x1*, ...]), or as</span>
<span class="sd">        a 2-D ndarray in which each column is a dataset.  Note that</span>
<span class="sd">        the ndarray form is transposed relative to the list form.</span>

<span class="sd">        Masked arrays are not supported at present.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x : (n,) array or sequence of (n,) arrays</span>
<span class="sd">            Input values, this takes either a single array or a sequency of</span>
<span class="sd">            arrays which are not required to be of the same length</span>

<span class="sd">        bins : integer or array_like, optional</span>
<span class="sd">            If an integer is given, `bins + 1` bin edges are returned,</span>
<span class="sd">            consistently with :func:`numpy.histogram` for numpy version &gt;=</span>
<span class="sd">            1.3.</span>

<span class="sd">            Unequally spaced bins are supported if `bins` is a sequence.</span>

<span class="sd">            default is 10</span>

<span class="sd">        range : tuple or None, optional</span>
<span class="sd">            The lower and upper range of the bins. Lower and upper outliers</span>
<span class="sd">            are ignored. If not provided, `range` is (x.min(), x.max()). Range</span>
<span class="sd">            has no effect if `bins` is a sequence.</span>

<span class="sd">            If `bins` is a sequence or `range` is specified, autoscaling</span>
<span class="sd">            is based on the specified bin range instead of the</span>
<span class="sd">            range of x.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        normed : boolean, optional</span>
<span class="sd">            If `True`, the first element of the return tuple will</span>
<span class="sd">            be the counts normalized to form a probability density, i.e.,</span>
<span class="sd">            ``n/(len(x)`dbin)``, i.e., the integral of the histogram will sum</span>
<span class="sd">            to 1. If *stacked* is also *True*, the sum of the histograms is</span>
<span class="sd">            normalized to 1.</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        weights : (n, ) array_like or None, optional</span>
<span class="sd">            An array of weights, of the same shape as `x`.  Each value in `x`</span>
<span class="sd">            only contributes its associated weight towards the bin count</span>
<span class="sd">            (instead of 1).  If `normed` is True, the weights are normalized,</span>
<span class="sd">            so that the integral of the density over the range remains 1.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        cumulative : boolean, optional</span>
<span class="sd">            If `True`, then a histogram is computed where each bin gives the</span>
<span class="sd">            counts in that bin plus all bins for smaller values. The last bin</span>
<span class="sd">            gives the total number of datapoints.  If `normed` is also `True`</span>
<span class="sd">            then the histogram is normalized such that the last bin equals 1.</span>
<span class="sd">            If `cumulative` evaluates to less than 0 (e.g., -1), the direction</span>
<span class="sd">            of accumulation is reversed.  In this case, if `normed` is also</span>
<span class="sd">            `True`, then the histogram is normalized such that the first bin</span>
<span class="sd">            equals 1.</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        bottom : array_like, scalar, or None</span>
<span class="sd">            Location of the bottom baseline of each bin.  If a scalar,</span>
<span class="sd">            the base line for each bin is shifted by the same amount.</span>
<span class="sd">            If an array, each bin is shifted independently and the length</span>
<span class="sd">            of bottom must match the number of bins.  If None, defaults to 0.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        histtype : {&#39;bar&#39;, &#39;barstacked&#39;, &#39;step&#39;,  &#39;stepfilled&#39;}, optional</span>
<span class="sd">            The type of histogram to draw.</span>

<span class="sd">            - &#39;bar&#39; is a traditional bar-type histogram.  If multiple data</span>
<span class="sd">              are given the bars are aranged side by side.</span>

<span class="sd">            - &#39;barstacked&#39; is a bar-type histogram where multiple</span>
<span class="sd">              data are stacked on top of each other.</span>

<span class="sd">            - &#39;step&#39; generates a lineplot that is by default</span>
<span class="sd">              unfilled.</span>

<span class="sd">            - &#39;stepfilled&#39; generates a lineplot that is by default</span>
<span class="sd">              filled.</span>

<span class="sd">            Default is &#39;bar&#39;</span>

<span class="sd">        align : {&#39;left&#39;, &#39;mid&#39;, &#39;right&#39;}, optional</span>
<span class="sd">            Controls how the histogram is plotted.</span>

<span class="sd">                - &#39;left&#39;: bars are centered on the left bin edges.</span>

<span class="sd">                - &#39;mid&#39;: bars are centered between the bin edges.</span>

<span class="sd">                - &#39;right&#39;: bars are centered on the right bin edges.</span>

<span class="sd">            Default is &#39;mid&#39;</span>

<span class="sd">        orientation : {&#39;horizontal&#39;, &#39;vertical&#39;}, optional</span>
<span class="sd">            If &#39;horizontal&#39;, `~matplotlib.pyplot.barh` will be used for</span>
<span class="sd">            bar-type histograms and the *bottom* kwarg will be the left edges.</span>

<span class="sd">        rwidth : scalar or None, optional</span>
<span class="sd">            The relative width of the bars as a fraction of the bin width.  If</span>
<span class="sd">            `None`, automatically compute the width.</span>

<span class="sd">            Ignored if `histtype` is &#39;step&#39; or &#39;stepfilled&#39;.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        log : boolean, optional</span>
<span class="sd">            If `True`, the histogram axis will be set to a log scale. If `log`</span>
<span class="sd">            is `True` and `x` is a 1D array, empty bins will be filtered out</span>
<span class="sd">            and only the non-empty (`n`, `bins`, `patches`) will be returned.</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        color : color or array_like of colors or None, optional</span>
<span class="sd">            Color spec or sequence of color specs, one per dataset.  Default</span>
<span class="sd">            (`None`) uses the standard line color sequence.</span>

<span class="sd">            Default is ``None``</span>

<span class="sd">        label : string or None, optional</span>
<span class="sd">            String, or sequence of strings to match multiple datasets.  Bar</span>
<span class="sd">            charts yield multiple patches per dataset, but only the first gets</span>
<span class="sd">            the label, so that the legend command will work as expected.</span>

<span class="sd">            default is ``None``</span>

<span class="sd">        stacked : boolean, optional</span>
<span class="sd">            If `True`, multiple data are stacked on top of each other If</span>
<span class="sd">            `False` multiple data are aranged side by side if histtype is</span>
<span class="sd">            &#39;bar&#39; or on top of each other if histtype is &#39;step&#39;</span>

<span class="sd">            Default is ``False``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        n : array or list of arrays</span>
<span class="sd">            The values of the histogram bins. See **normed** and **weights**</span>
<span class="sd">            for a description of the possible semantics. If input **x** is an</span>
<span class="sd">            array, then this is an array of length **nbins**. If input is a</span>
<span class="sd">            sequence arrays ``[data1, data2,..]``, then this is a list of</span>
<span class="sd">            arrays with the values of the histograms for each of the arrays</span>
<span class="sd">            in the same order.</span>

<span class="sd">        bins : array</span>
<span class="sd">            The edges of the bins. Length nbins + 1 (nbins left edges and right</span>
<span class="sd">            edge of last bin).  Always a single array even when multiple data</span>
<span class="sd">            sets are passed in.</span>

<span class="sd">        patches : list or list of lists</span>
<span class="sd">            Silent list of individual patches used to create the histogram</span>
<span class="sd">            or list of such list if multiple input datasets.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs : `~matplotlib.patches.Patch` properties</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hist2d : 2D histograms</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Until numpy release 1.5, the underlying numpy histogram function was</span>
<span class="sd">        incorrect with `normed`=`True` if bin sizes were unequal.  MPL</span>
<span class="sd">        inherited that error.  It is now corrected within MPL when using</span>
<span class="sd">        earlier numpy versions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot:: mpl_examples/statistics/histogram_demo_features.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_normalize_input</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">ename</span><span class="o">=</span><span class="s1">&#39;input&#39;</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Normalize 1 or 2d input into list of np.ndarray or</span>
<span class="sd">            a single 2D np.ndarray.</span>

<span class="sd">            Parameters</span>
<span class="sd">            ----------</span>
<span class="sd">            inp : iterable</span>
<span class="sd">            ename : str, optional</span>
<span class="sd">                Name to use in ValueError if `inp` can not be normalized</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="n">iterable</span><span class="p">(</span><span class="n">cbook</span><span class="o">.</span><span class="n">safe_first_element</span><span class="p">(</span><span class="n">inp</span><span class="p">))):</span>
                <span class="c1"># TODO: support masked arrays;</span>
                <span class="n">inp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="c1"># 2-D input with columns as datasets; switch to rows</span>
                    <span class="n">inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">T</span>
                <span class="k">elif</span> <span class="n">inp</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># new view, single row</span>
                    <span class="n">inp</span> <span class="o">=</span> <span class="n">inp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;{ename} must be 1D or 2D&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ename</span><span class="o">=</span><span class="n">ename</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s1">&#39;2D hist input should be nsamples x nvariables;</span><span class="se">\n</span><span class="s1"> &#39;</span>
                        <span class="s1">&#39;this looks transposed &#39;</span>
                        <span class="s1">&#39;(shape is </span><span class="si">%d</span><span class="s1"> x </span><span class="si">%d</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">inp</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># multiple hist with data of different length</span>
                <span class="n">inp</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">inp</span><span class="p">]</span>

            <span class="k">return</span> <span class="n">inp</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

        <span class="c1"># xrange becomes range after 2to3</span>
        <span class="n">bin_range</span> <span class="o">=</span> <span class="nb">range</span>
        <span class="nb">range</span> <span class="o">=</span> <span class="n">__builtins__</span><span class="p">[</span><span class="s2">&quot;range&quot;</span><span class="p">]</span>

        <span class="c1"># NOTE: the range keyword overwrites the built-in func range !!!</span>
        <span class="c1">#       needs to be fixed in numpy                           !!!</span>

        <span class="c1"># Validate string inputs here so we don&#39;t have to clutter</span>
        <span class="c1"># subsequent code.</span>
        <span class="k">if</span> <span class="n">histtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">,</span> <span class="s1">&#39;barstacked&#39;</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">,</span> <span class="s1">&#39;stepfilled&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;histtype </span><span class="si">%s</span><span class="s2"> is not recognized&quot;</span> <span class="o">%</span> <span class="n">histtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">align</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;mid&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;align kwarg </span><span class="si">%s</span><span class="s2"> is not recognized&quot;</span> <span class="o">%</span> <span class="n">align</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orientation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;horizontal&#39;</span><span class="p">,</span> <span class="s1">&#39;vertical&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;orientation kwarg </span><span class="si">%s</span><span class="s2"> is not recognized&quot;</span> <span class="o">%</span> <span class="n">orientation</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;barstacked&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
            <span class="n">stacked</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c1"># process the unit information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bin_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">bin_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">bin_range</span><span class="p">)</span>

        <span class="c1"># Check whether bins or range are given explicitly.</span>
        <span class="n">binsgiven</span> <span class="o">=</span> <span class="p">(</span><span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="ow">or</span> <span class="n">bin_range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span>

        <span class="c1"># basic input validation</span>
        <span class="n">flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="n">input_empty</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flat</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

        <span class="c1"># Massage &#39;x&#39; for processing.</span>
        <span class="k">if</span> <span class="n">input_empty</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">_normalize_input</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># number of datasets</span>

        <span class="c1"># We need to do to &#39;weights&#39; what was done to &#39;x&#39;</span>
        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">_normalize_input</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="s1">&#39;weights&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="n">nx</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nx</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;weights should have the same shape as x&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">xi</span><span class="p">,</span> <span class="n">wi</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">wi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">wi</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;weights should have the same shape as x&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">color</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="s1">&#39;color&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">_prop_keys</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_lines</span><span class="o">.</span><span class="n">prop_cycler</span><span class="p">)[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
                     <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nx</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">colorConverter</span><span class="o">.</span><span class="n">to_rgba_array</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">color</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;color kwarg must have one color per dataset&quot;</span><span class="p">)</span>

        <span class="c1"># Save the datalimits for the same reason:</span>
        <span class="n">_saved_bounds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">bounds</span>

        <span class="c1"># If bins are not specified either explicitly or via range,</span>
        <span class="c1"># we need to figure out the range required for all datasets,</span>
        <span class="c1"># and supply that to np.histogram.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">binsgiven</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">input_empty</span><span class="p">:</span>
            <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">xmax</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xi</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
                    <span class="n">xmax</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmax</span><span class="p">,</span> <span class="n">xi</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
            <span class="n">bin_range</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>

        <span class="c1"># hist_kwargs = dict(range=range, normed=bool(normed))</span>
        <span class="c1"># We will handle the normed kwarg within mpl until we</span>
        <span class="c1"># get to the point of requiring numpy &gt;= 1.5.</span>
        <span class="n">hist_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">range</span><span class="o">=</span><span class="n">bin_range</span><span class="p">)</span>

        <span class="n">n</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mlast</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">nx</span><span class="p">):</span>
            <span class="c1"># this will automatically overwrite bins,</span>
            <span class="c1"># so that each histogram uses the same bins</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">**</span><span class="n">hist_kwargs</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># causes problems later if it&#39;s an int</span>
            <span class="k">if</span> <span class="n">mlast</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">mlast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">normed</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">db</span><span class="p">)</span> <span class="o">/</span> <span class="n">m</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mlast</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">mlast</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="n">mlast</span>
                <span class="n">mlast</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">m</span>
            <span class="n">n</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stacked</span> <span class="ow">and</span> <span class="n">normed</span><span class="p">:</span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">m</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">/</span> <span class="n">db</span><span class="p">)</span> <span class="o">/</span> <span class="n">n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">cumulative</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">is_numlike</span><span class="p">(</span><span class="n">cumulative</span><span class="p">)</span> <span class="ow">and</span> <span class="n">cumulative</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">slc</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">normed</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="p">[(</span><span class="n">m</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">))[</span><span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()[</span><span class="n">slc</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="n">slc</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()[</span><span class="n">slc</span><span class="p">]</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="p">]</span>

        <span class="n">patches</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">histtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;bar&#39;</span><span class="p">):</span>
            <span class="c1"># Save autoscale state for later restoration; turn autoscaling</span>
            <span class="c1"># off so we can do it all a single time at the end, instead</span>
            <span class="c1"># of having it done by bar or fill and then having to be redone.</span>
            <span class="n">_saved_autoscalex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_autoscalex_on</span><span class="p">()</span>
            <span class="n">_saved_autoscaley</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_autoscaley_on</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscalex_on</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscaley_on</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

            <span class="n">totwidth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">rwidth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">rwidth</span><span class="p">))</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="mf">0.8</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dr</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="k">if</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;bar&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">dr</span><span class="o">*</span><span class="n">totwidth</span><span class="o">/</span><span class="n">nx</span>
                <span class="n">dw</span> <span class="o">=</span> <span class="n">width</span>

                <span class="k">if</span> <span class="n">nx</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">boffset</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dr</span><span class="o">*</span><span class="n">totwidth</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">-</span><span class="mf">1.0</span><span class="o">/</span><span class="n">nx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">boffset</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">stacked</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">elif</span> <span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;barstacked&#39;</span> <span class="ow">or</span> <span class="n">stacked</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="n">dr</span><span class="o">*</span><span class="n">totwidth</span>
                <span class="n">boffset</span><span class="p">,</span> <span class="n">dw</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span>

            <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;mid&#39;</span> <span class="ow">or</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">totwidth</span>
            <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="n">totwidth</span>

            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="n">_barfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">barh</span>
                <span class="n">bottom_kwarg</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># orientation == &#39;vertical&#39;</span>
                <span class="n">_barfunc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bar</span>
                <span class="n">bottom_kwarg</span> <span class="o">=</span> <span class="s1">&#39;bottom&#39;</span>

            <span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="n">bottom</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">_barfunc</span><span class="p">(</span><span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">boffset</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span>
                                 <span class="n">align</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">log</span><span class="o">=</span><span class="n">log</span><span class="p">,</span>
                                 <span class="n">color</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="n">bottom_kwarg</span><span class="p">:</span> <span class="n">bottom</span><span class="p">})</span>
                <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="n">bottom</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">boffset</span> <span class="o">+=</span> <span class="n">dw</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscalex_on</span><span class="p">(</span><span class="n">_saved_autoscalex</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_autoscaley_on</span><span class="p">(</span><span class="n">_saved_autoscaley</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">histtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;step&#39;</span><span class="p">):</span>
            <span class="c1"># these define the perimeter of the polygon</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

            <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bins</span><span class="p">,</span> <span class="n">bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">bottom</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

            <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">bottom</span><span class="p">,</span> <span class="n">bottom</span>
            <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonposx</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
                    <span class="n">logbase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">_scale</span><span class="o">.</span><span class="n">base</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># orientation == &#39;vertical&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="n">nonposy</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
                    <span class="n">logbase</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">_scale</span><span class="o">.</span><span class="n">base</span>

                <span class="c1"># Setting a minimum of 0 results in problems for log plots</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bottom</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">normed</span> <span class="ow">or</span> <span class="n">weights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c1"># For normed data, set to log base * minimum data value</span>
                    <span class="c1"># (gives 1 full tick-label unit for the lowest filled bin)</span>
                    <span class="n">ndata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ndata</span><span class="p">[</span><span class="n">ndata</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span> <span class="o">/</span> <span class="n">logbase</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># For non-normed data, set the min to log base,</span>
                    <span class="c1"># again so that there is 1 full tick-label unit</span>
                    <span class="c1"># for the lowest bin</span>
                    <span class="n">minimum</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">logbase</span>

                <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum</span><span class="p">,</span> <span class="n">minimum</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">minimum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="ow">or</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;center&#39;</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">-=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">+=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># If fill kwarg is set, it will be passed to the patch collection,</span>
            <span class="c1"># overriding this</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="p">(</span><span class="n">histtype</span> <span class="o">==</span> <span class="s1">&#39;stepfilled&#39;</span><span class="p">)</span>

            <span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stacked</span><span class="p">:</span>
                    <span class="c1"># starting point for drawing polygon</span>
                    <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="c1"># top of the previous polygon becomes the bottom</span>
                    <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="c1"># set the top of this polygon</span>
                <span class="n">y</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">,</span>
                                                            <span class="n">m</span> <span class="o">+</span> <span class="n">bottom</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">log</span><span class="p">:</span>
                    <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">]</span> <span class="o">=</span> <span class="n">minimum</span>
                <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">yvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                    <span class="n">yvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

            <span class="k">if</span> <span class="n">fill</span><span class="p">:</span>
                <span class="c1"># add patches in reverse order so that when stacking,</span>
                <span class="c1"># items lower in the stack are plottted on top of</span>
                <span class="c1"># items higher in the stack</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">color</span><span class="p">))):</span>
                    <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span>
                        <span class="n">closed</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                        <span class="n">facecolor</span><span class="o">=</span><span class="n">c</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xvals</span><span class="p">,</span> <span class="n">yvals</span><span class="p">,</span> <span class="n">color</span><span class="p">))):</span>
                    <span class="n">split</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
                    <span class="n">patches</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span>
                        <span class="n">x</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span> <span class="n">y</span><span class="p">[:</span><span class="n">split</span><span class="p">],</span>
                        <span class="n">closed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">edgecolor</span><span class="o">=</span><span class="n">c</span><span class="p">,</span>
                        <span class="n">fill</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>

            <span class="c1"># we return patches, so put it back in the expected order</span>
            <span class="n">patches</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

            <span class="c1"># adopted from adjust_x/ylim part of the bar method</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;horizontal&#39;</span><span class="p">:</span>
                <span class="n">xmin0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">_saved_bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span>
                <span class="n">xmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervalx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># make sure there are counts</span>
                        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                        <span class="c1"># filter out the 0 height bins</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">xmin</span><span class="o">*</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">input_empty</span> <span class="k">else</span> <span class="n">minimum</span>
                <span class="n">xmin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">xmin0</span><span class="p">,</span> <span class="n">xmin</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervalx</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="n">ymin0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">_saved_bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span>
                <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervaly</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># make sure there are counts</span>
                        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
                        <span class="c1"># filter out the 0 height bins</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">ymin</span><span class="o">*</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">minimum</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">input_empty</span> <span class="k">else</span> <span class="n">minimum</span>
                <span class="n">ymin</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">ymin0</span><span class="p">,</span> <span class="n">ymin</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dataLim</span><span class="o">.</span><span class="n">intervaly</span> <span class="o">=</span> <span class="p">(</span><span class="n">ymin</span><span class="p">,</span> <span class="n">ymax</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">is_string_like</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">label</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">six</span><span class="o">.</span><span class="n">text_type</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span> <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">label</span><span class="p">]</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="n">lbl</span><span class="p">)</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="n">patches</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">patch</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">patch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">p</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">lbl</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">lbl</span><span class="p">)</span>

                <span class="n">p</span><span class="o">.</span><span class="n">set_snap</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">patch</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="n">p</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">binsgiven</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="s1">&#39;vertical&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span>
                    <span class="p">[(</span><span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)],</span> <span class="n">updatey</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">(</span>
                    <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])],</span> <span class="n">updatex</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nx</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bins</span><span class="p">,</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">&#39;Patch&#39;</span><span class="p">,</span> <span class="n">patches</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">&#39;Lists of Patches&#39;</span><span class="p">,</span> <span class="n">patches</span><span class="p">)</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;weights&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.hist2d"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.hist2d.html#mpl.axes.Axes.hist2d">[docs]</a>    <span class="k">def</span> <span class="nf">hist2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">normed</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">cmin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cmax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a 2D histogram plot.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x, y: array_like, shape (n, )</span>
<span class="sd">            Input values</span>

<span class="sd">        bins: [None | int | [int, int] | array_like | [array, array]]</span>

<span class="sd">            The bin specification:</span>

<span class="sd">                - If int, the number of bins for the two dimensions</span>
<span class="sd">                  (nx=ny=bins).</span>

<span class="sd">                - If [int, int], the number of bins in each dimension</span>
<span class="sd">                  (nx, ny = bins).</span>

<span class="sd">                - If array_like, the bin edges for the two dimensions</span>
<span class="sd">                  (x_edges=y_edges=bins).</span>

<span class="sd">                - If [array, array], the bin edges in each dimension</span>
<span class="sd">                  (x_edges, y_edges = bins).</span>

<span class="sd">            The default value is 10.</span>

<span class="sd">        range : array_like shape(2, 2), optional, default: None</span>
<span class="sd">             The leftmost and rightmost edges of the bins along each dimension</span>
<span class="sd">             (if not specified explicitly in the bins parameters): [[xmin,</span>
<span class="sd">             xmax], [ymin, ymax]]. All values outside of this range will be</span>
<span class="sd">             considered outliers and not tallied in the histogram.</span>

<span class="sd">        normed : boolean, optional, default: False</span>
<span class="sd">             Normalize histogram.</span>

<span class="sd">        weights : array_like, shape (n, ), optional, default: None</span>
<span class="sd">            An array of values w_i weighing each sample (x_i, y_i).</span>

<span class="sd">        cmin : scalar, optional, default: None</span>
<span class="sd">             All bins that has count less than cmin will not be displayed and</span>
<span class="sd">             these count values in the return value count histogram will also</span>
<span class="sd">             be set to nan upon return</span>

<span class="sd">        cmax : scalar, optional, default: None</span>
<span class="sd">             All bins that has count more than cmax will not be displayed (set</span>
<span class="sd">             to none before passing to imshow) and these count values in the</span>
<span class="sd">             return value count histogram will also be set to nan upon return</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        The return value is ``(counts, xedges, yedges, Image)``.</span>

<span class="sd">        Other parameters</span>
<span class="sd">        -----------------</span>
<span class="sd">        kwargs : :meth:`pcolorfast` properties.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        hist : 1D histogram</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Rendering the histogram with a logarithmic color scale is</span>
<span class="sd">        accomplished by passing a :class:`colors.LogNorm` instance to</span>
<span class="sd">        the *norm* keyword argument. Likewise, power-law normalization</span>
<span class="sd">        (similar in effect to gamma correction) can be accomplished with</span>
<span class="sd">        :class:`colors.PowerNorm`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot:: mpl_examples/pylab_examples/hist2d_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># xrange becomes range after 2to3</span>
        <span class="n">bin_range</span> <span class="o">=</span> <span class="nb">range</span>
        <span class="nb">range</span> <span class="o">=</span> <span class="n">__builtins__</span><span class="p">[</span><span class="s2">&quot;range&quot;</span><span class="p">]</span>
        <span class="n">h</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="o">=</span><span class="n">bin_range</span><span class="p">,</span>
                                           <span class="n">normed</span><span class="o">=</span><span class="n">normed</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">cmin</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="n">cmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">h</span><span class="p">[</span><span class="n">h</span> <span class="o">&gt;</span> <span class="n">cmax</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pcolorfast</span><span class="p">(</span><span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">,</span> <span class="n">h</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">yedges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">yedges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">h</span><span class="p">,</span> <span class="n">xedges</span><span class="p">,</span> <span class="n">yedges</span><span class="p">,</span> <span class="n">pc</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.psd"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.psd.html#mpl.axes.Axes.psd">[docs]</a>    <span class="k">def</span> <span class="nf">psd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">sides</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">return_line</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the power spectral density.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          psd(x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,</span>
<span class="sd">              window=mlab.window_hanning, noverlap=0, pad_to=None,</span>
<span class="sd">              sides=&#39;default&#39;, scale_by_freq=None, return_line=None, **kwargs)</span>

<span class="sd">        The power spectral density :math:`P_{xx}` by Welch&#39;s average</span>
<span class="sd">        periodogram method.  The vector *x* is divided into *NFFT* length</span>
<span class="sd">        segments.  Each segment is detrended by function *detrend* and</span>
<span class="sd">        windowed by function *window*.  *noverlap* gives the length of</span>
<span class="sd">        the overlap between segments.  The :math:`|\mathrm{fft}(i)|^2`</span>
<span class="sd">        of each segment :math:`i` are averaged to compute :math:`P_{xx}`,</span>
<span class="sd">        with a scaling to correct for power loss due to windowing.</span>

<span class="sd">        If len(*x*) &lt; *NFFT*, it will be zero padded to *NFFT*.</span>

<span class="sd">          *x*: 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">          *noverlap*: integer</span>
<span class="sd">            The number of points of overlap between segments.</span>
<span class="sd">            The default value is 0 (no overlap).</span>

<span class="sd">          *Fc*: integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">          *return_line*: bool</span>
<span class="sd">            Whether to include the line object plotted in the returned values.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        If *return_line* is False, returns the tuple (*Pxx*, *freqs*).</span>
<span class="sd">        If *return_line* is True, returns the tuple (*Pxx*, *freqs*. *line*):</span>

<span class="sd">          *Pxx*: 1-D array</span>
<span class="sd">            The values for the power spectrum `P_{xx}` before scaling</span>
<span class="sd">            (real valued)</span>

<span class="sd">          *freqs*: 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *Pxx*</span>

<span class="sd">          *line*: a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function.</span>
<span class="sd">            Only returend if *return_line* is True.</span>

<span class="sd">        For plotting, the power is plotted as</span>
<span class="sd">        :math:`10\log_{10}(P_{xx})` for decibels, though *Pxx* itself</span>
<span class="sd">        is returned.</span>

<span class="sd">        References:</span>
<span class="sd">          Bendat &amp; Piersol -- Random Data: Analysis and Measurement</span>
<span class="sd">          Procedures, John Wiley &amp; Sons (1986)</span>

<span class="sd">        kwargs control the :class:`~matplotlib.lines.Line2D` properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/psd_demo.py</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`specgram`</span>
<span class="sd">                :func:`specgram` differs in the default overlap; in not</span>
<span class="sd">                returning the mean of the segment periodograms; in  returning</span>
<span class="sd">                the times of the segments; and in plotting a colormap instead</span>
<span class="sd">                of a line.</span>

<span class="sd">            :func:`magnitude_spectrum`</span>
<span class="sd">                :func:`magnitude_spectrum` plots the magnitude spectrum.</span>

<span class="sd">            :func:`csd`</span>
<span class="sd">                :func:`csd` plots the spectral density between two signals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">psd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                              <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                              <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="n">pxx</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="k">if</span> <span class="n">scale_by_freq</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="n">psd_units</span> <span class="o">=</span> <span class="s1">&#39;dB/Hz&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psd_units</span> <span class="o">=</span> <span class="s1">&#39;dB&#39;</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">pxx</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Power Spectral Density (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">psd_units</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">intervaly</span>
        <span class="n">intv</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span>
        <span class="n">logi</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">intv</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">logi</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">logi</span> <span class="o">=</span> <span class="o">.</span><span class="mi">1</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">logi</span>
        <span class="c1">#print vmin, vmax, step, intv, math.floor(vmin), math.ceil(vmax)+1</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_line</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_line</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxx</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">line</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.csd"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.csd.html#mpl.axes.Axes.csd">[docs]</a>    <span class="k">def</span> <span class="nf">csd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">window</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">sides</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">return_line</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the cross-spectral density.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          csd(x, y, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,</span>
<span class="sd">              window=mlab.window_hanning, noverlap=0, pad_to=None,</span>
<span class="sd">              sides=&#39;default&#39;, scale_by_freq=None, return_line=None, **kwargs)</span>

<span class="sd">        The cross spectral density :math:`P_{xy}` by Welch&#39;s average</span>
<span class="sd">        periodogram method.  The vectors *x* and *y* are divided into</span>
<span class="sd">        *NFFT* length segments.  Each segment is detrended by function</span>
<span class="sd">        *detrend* and windowed by function *window*.  *noverlap* gives</span>
<span class="sd">        the length of the overlap between segments.  The product of</span>
<span class="sd">        the direct FFTs of *x* and *y* are averaged over each segment</span>
<span class="sd">        to compute :math:`P_{xy}`, with a scaling to correct for power</span>
<span class="sd">        loss due to windowing.</span>

<span class="sd">        If len(*x*) &lt; *NFFT* or len(*y*) &lt; *NFFT*, they will be zero</span>
<span class="sd">        padded to *NFFT*.</span>

<span class="sd">          *x*, *y*: 1-D arrays or sequences</span>
<span class="sd">            Arrays or sequences containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">          *noverlap*: integer</span>
<span class="sd">            The number of points of overlap between segments.</span>
<span class="sd">            The default value is 0 (no overlap).</span>

<span class="sd">          *Fc*: integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">          *return_line*: bool</span>
<span class="sd">            Whether to include the line object plotted in the returned values.</span>
<span class="sd">            Default is False.</span>

<span class="sd">        If *return_line* is False, returns the tuple (*Pxy*, *freqs*).</span>
<span class="sd">        If *return_line* is True, returns the tuple (*Pxy*, *freqs*. *line*):</span>

<span class="sd">          *Pxy*: 1-D array</span>
<span class="sd">            The values for the cross spectrum `P_{xy}` before scaling</span>
<span class="sd">            (complex valued)</span>

<span class="sd">          *freqs*: 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *Pxy*</span>

<span class="sd">          *line*: a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function.</span>
<span class="sd">            Only returend if *return_line* is True.</span>

<span class="sd">        For plotting, the power is plotted as</span>
<span class="sd">        :math:`10\log_{10}(P_{xy})` for decibels, though `P_{xy}` itself</span>
<span class="sd">        is returned.</span>

<span class="sd">        References:</span>
<span class="sd">          Bendat &amp; Piersol -- Random Data: Analysis and Measurement</span>
<span class="sd">          Procedures, John Wiley &amp; Sons (1986)</span>

<span class="sd">        kwargs control the Line2D properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/csd_demo.py</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`psd`</span>
<span class="sd">                :func:`psd` is the equivalent to setting y=x.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">csd</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                              <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                              <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="n">pxy</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs</span><span class="p">),</span>
        <span class="c1"># pxy is complex</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">pxy</span><span class="p">)),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Cross Spectrum Magnitude (dB)&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewLim</span><span class="o">.</span><span class="n">intervaly</span>

        <span class="n">intv</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span>
        <span class="n">step</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">intv</span><span class="p">))</span>

        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">return_line</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">return_line</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pxy</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">line</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.magnitude_spectrum"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.magnitude_spectrum.html#mpl.axes.Axes.magnitude_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">magnitude_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="n">pad_to</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the magnitude spectrum.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          magnitude_spectrum(x, Fs=2, Fc=0,  window=mlab.window_hanning,</span>
<span class="sd">                             pad_to=None, sides=&#39;default&#39;, **kwargs)</span>

<span class="sd">        Compute the magnitude spectrum of *x*.  Data is padded to a</span>
<span class="sd">        length of *pad_to* and the windowing function *window* is applied to</span>
<span class="sd">        the signal.</span>

<span class="sd">          *x*: 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">          *scale*: [ &#39;default&#39; | &#39;linear&#39; | &#39;dB&#39; ]</span>
<span class="sd">            The scaling of the values in the *spec*.  &#39;linear&#39; is no scaling.</span>
<span class="sd">            &#39;dB&#39; returns the values in dB scale.  When *mode* is &#39;density&#39;,</span>
<span class="sd">            this is dB power (10 * log10).  Otherwise this is dB amplitude</span>
<span class="sd">            (20 * log10). &#39;default&#39; is &#39;linear&#39;.</span>

<span class="sd">          *Fc*: integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        Returns the tuple (*spectrum*, *freqs*, *line*):</span>

<span class="sd">          *spectrum*: 1-D array</span>
<span class="sd">            The values for the magnitude spectrum before scaling (real valued)</span>

<span class="sd">          *freqs*: 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">          *line*: a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function</span>

<span class="sd">        kwargs control the :class:`~matplotlib.lines.Line2D` properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/spectrum_demo.py</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`psd`</span>
<span class="sd">                :func:`psd` plots the power spectral density.`.</span>

<span class="sd">            :func:`angle_spectrum`</span>
<span class="sd">                :func:`angle_spectrum` plots the angles of the corresponding</span>
<span class="sd">                frequencies.</span>

<span class="sd">            :func:`phase_spectrum`</span>
<span class="sd">                :func:`phase_spectrum` plots the phase (unwrapped angle) of the</span>
<span class="sd">                corresponding frequencies.</span>

<span class="sd">            :func:`specgram`</span>
<span class="sd">                :func:`specgram` can plot the magnitude spectrum of segments</span>
<span class="sd">                within the signal in a colormap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">magnitude_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                              <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">spec</span>
            <span class="n">yunits</span> <span class="o">=</span> <span class="s1">&#39;energy&#39;</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="n">yunits</span> <span class="o">=</span> <span class="s1">&#39;dB&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown scale </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">yunits</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.angle_spectrum"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.angle_spectrum.html#mpl.axes.Axes.angle_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">angle_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">pad_to</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the angle spectrum.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          angle_spectrum(x, Fs=2, Fc=0,  window=mlab.window_hanning,</span>
<span class="sd">                         pad_to=None, sides=&#39;default&#39;, **kwargs)</span>

<span class="sd">        Compute the angle spectrum (wrapped phase spectrum) of *x*.</span>
<span class="sd">        Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">        *window* is applied to the signal.</span>

<span class="sd">          *x*: 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">          *Fc*: integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        Returns the tuple (*spectrum*, *freqs*, *line*):</span>

<span class="sd">          *spectrum*: 1-D array</span>
<span class="sd">            The values for the angle spectrum in radians (real valued)</span>

<span class="sd">          *freqs*: 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">          *line*: a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function</span>

<span class="sd">        kwargs control the :class:`~matplotlib.lines.Line2D` properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/spectrum_demo.py</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`magnitude_spectrum`</span>
<span class="sd">                :func:`angle_spectrum` plots the magnitudes of the</span>
<span class="sd">                corresponding frequencies.</span>

<span class="sd">            :func:`phase_spectrum`</span>
<span class="sd">                :func:`phase_spectrum` plots the unwrapped version of this</span>
<span class="sd">                function.</span>

<span class="sd">            :func:`specgram`</span>
<span class="sd">                :func:`specgram` can plot the angle spectrum of segments</span>
<span class="sd">                within the signal in a colormap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">angle_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                          <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Angle (radians)&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.phase_spectrum"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.phase_spectrum.html#mpl.axes.Axes.phase_spectrum">[docs]</a>    <span class="k">def</span> <span class="nf">phase_spectrum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                       <span class="n">pad_to</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the phase spectrum.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          phase_spectrum(x, Fs=2, Fc=0,  window=mlab.window_hanning,</span>
<span class="sd">                         pad_to=None, sides=&#39;default&#39;, **kwargs)</span>

<span class="sd">        Compute the phase spectrum (unwrapped angle spectrum) of *x*.</span>
<span class="sd">        Data is padded to a length of *pad_to* and the windowing function</span>
<span class="sd">        *window* is applied to the signal.</span>

<span class="sd">          *x*: 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(Single_Spectrum)s</span>

<span class="sd">          *Fc*: integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        Returns the tuple (*spectrum*, *freqs*, *line*):</span>

<span class="sd">          *spectrum*: 1-D array</span>
<span class="sd">            The values for the phase spectrum in radians (real valued)</span>

<span class="sd">          *freqs*: 1-D array</span>
<span class="sd">            The frequencies corresponding to the elements in *spectrum*</span>

<span class="sd">          *line*: a :class:`~matplotlib.lines.Line2D` instance</span>
<span class="sd">            The line created by this function</span>

<span class="sd">        kwargs control the :class:`~matplotlib.lines.Line2D` properties:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/spectrum_demo.py</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`magnitude_spectrum`</span>
<span class="sd">                :func:`magnitude_spectrum` plots the magnitudes of the</span>
<span class="sd">                corresponding frequencies.</span>

<span class="sd">            :func:`angle_spectrum`</span>
<span class="sd">                :func:`angle_spectrum` plots the wrapped version of this</span>
<span class="sd">                function.</span>

<span class="sd">            :func:`specgram`</span>
<span class="sd">                :func:`specgram` can plot the phase spectrum of segments</span>
<span class="sd">                within the signal in a colormap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">phase_spectrum</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                          <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">spec</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (radians)&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.cohere"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.cohere.html#mpl.axes.Axes.cohere">[docs]</a>    <span class="k">def</span> <span class="nf">cohere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">detrend_none</span><span class="p">,</span>
               <span class="n">window</span><span class="o">=</span><span class="n">mlab</span><span class="o">.</span><span class="n">window_hanning</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">sides</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="n">scale_by_freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the coherence between *x* and *y*.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          cohere(x, y, NFFT=256, Fs=2, Fc=0, detrend = mlab.detrend_none,</span>
<span class="sd">                 window = mlab.window_hanning, noverlap=0, pad_to=None,</span>
<span class="sd">                 sides=&#39;default&#39;, scale_by_freq=None, **kwargs)</span>

<span class="sd">        Plot the coherence between *x* and *y*.  Coherence is the</span>
<span class="sd">        normalized cross spectral density:</span>

<span class="sd">        .. math::</span>

<span class="sd">          C_{xy} = \\frac{|P_{xy}|^2}{P_{xx}P_{yy}}</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">          *noverlap*: integer</span>
<span class="sd">            The number of points of overlap between blocks.  The</span>
<span class="sd">            default value is 0 (no overlap).</span>

<span class="sd">          *Fc*: integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">        The return value is a tuple (*Cxy*, *f*), where *f* are the</span>
<span class="sd">        frequencies of the coherence vector.</span>

<span class="sd">        kwargs are applied to the lines.</span>

<span class="sd">        References:</span>

<span class="sd">          * Bendat &amp; Piersol -- Random Data: Analysis and Measurement</span>
<span class="sd">            Procedures, John Wiley &amp; Sons (1986)</span>

<span class="sd">        kwargs control the :class:`~matplotlib.lines.Line2D`</span>
<span class="sd">        properties of the coherence plot:</span>

<span class="sd">        %(Line2D)s</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/cohere_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>
        <span class="n">cxy</span><span class="p">,</span> <span class="n">freqs</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">cohere</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span>
                                 <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span>
                                 <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">cxy</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Coherence&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cxy</span><span class="p">,</span> <span class="n">freqs</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
    <span class="nd">@docstring.dedent_interpd</span>
<div class="viewcode-block" id="Axes.specgram"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.specgram.html#mpl.axes.Axes.specgram">[docs]</a>    <span class="k">def</span> <span class="nf">specgram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">Fc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">detrend</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">window</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">cmap</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">xextent</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">sides</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">scale_by_freq</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">vmin</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a spectrogram.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          specgram(x, NFFT=256, Fs=2, Fc=0, detrend=mlab.detrend_none,</span>
<span class="sd">                   window=mlab.window_hanning, noverlap=128,</span>
<span class="sd">                   cmap=None, xextent=None, pad_to=None, sides=&#39;default&#39;,</span>
<span class="sd">                   scale_by_freq=None, mode=&#39;default&#39;, scale=&#39;default&#39;,</span>
<span class="sd">                   **kwargs)</span>

<span class="sd">        Compute and plot a spectrogram of data in *x*.  Data are split into</span>
<span class="sd">        *NFFT* length segments and the spectrum of each section is</span>
<span class="sd">        computed.  The windowing function *window* is applied to each</span>
<span class="sd">        segment, and the amount of overlap of each segment is</span>
<span class="sd">        specified with *noverlap*. The spectrogram is plotted as a colormap</span>
<span class="sd">        (using imshow).</span>

<span class="sd">        *x*: 1-D array or sequence</span>
<span class="sd">            Array or sequence containing the data</span>

<span class="sd">        %(Spectral)s</span>

<span class="sd">        %(PSD)s</span>

<span class="sd">          *mode*: [ &#39;default&#39; | &#39;psd&#39; | &#39;magnitude&#39; | &#39;angle&#39; | &#39;phase&#39; ]</span>
<span class="sd">            What sort of spectrum to use.  Default is &#39;psd&#39;. which takes</span>
<span class="sd">            the power spectral density.  &#39;complex&#39; returns the complex-valued</span>
<span class="sd">            frequency spectrum.  &#39;magnitude&#39; returns the magnitude spectrum.</span>
<span class="sd">            &#39;angle&#39; returns the phase spectrum without unwrapping.  &#39;phase&#39;</span>
<span class="sd">            returns the phase spectrum with unwrapping.</span>

<span class="sd">          *noverlap*: integer</span>
<span class="sd">            The number of points of overlap between blocks.  The</span>
<span class="sd">            default value is 128.</span>

<span class="sd">          *scale*: [ &#39;default&#39; | &#39;linear&#39; | &#39;dB&#39; ]</span>
<span class="sd">            The scaling of the values in the *spec*.  &#39;linear&#39; is no scaling.</span>
<span class="sd">            &#39;dB&#39; returns the values in dB scale.  When *mode* is &#39;psd&#39;,</span>
<span class="sd">            this is dB power (10 * log10).  Otherwise this is dB amplitude</span>
<span class="sd">            (20 * log10). &#39;default&#39; is &#39;dB&#39; if *mode* is &#39;psd&#39; or</span>
<span class="sd">            &#39;magnitude&#39; and &#39;linear&#39; otherwise.  This must be &#39;linear&#39;</span>
<span class="sd">            if *mode* is &#39;angle&#39; or &#39;phase&#39;.</span>

<span class="sd">          *Fc*: integer</span>
<span class="sd">            The center frequency of *x* (defaults to 0), which offsets</span>
<span class="sd">            the x extents of the plot to reflect the frequency range used</span>
<span class="sd">            when a signal is acquired and then filtered and downsampled to</span>
<span class="sd">            baseband.</span>

<span class="sd">          *cmap*:</span>
<span class="sd">            A :class:`matplotlib.colors.Colormap` instance; if *None*, use</span>
<span class="sd">            default determined by rc</span>

<span class="sd">          *xextent*:</span>
<span class="sd">            The image extent along the x-axis. xextent = (xmin,xmax)</span>
<span class="sd">            The default is (0,max(bins)), where bins is the return</span>
<span class="sd">            value from :func:`~matplotlib.mlab.specgram`</span>

<span class="sd">          *kwargs*:</span>
<span class="sd">            Additional kwargs are passed on to imshow which makes the</span>
<span class="sd">            specgram image</span>

<span class="sd">        .. note::</span>

<span class="sd">            *detrend* and *scale_by_freq* only apply when *mode* is set to</span>
<span class="sd">            &#39;psd&#39;</span>

<span class="sd">        Returns the tuple (*spectrum*, *freqs*, *t*, *im*):</span>

<span class="sd">          *spectrum*: 2-D array</span>
<span class="sd">            columns are the periodograms of successive segments</span>

<span class="sd">          *freqs*: 1-D array</span>
<span class="sd">            The frequencies corresponding to the rows in *spectrum*</span>

<span class="sd">          *t*: 1-D array</span>
<span class="sd">            The times corresponding to midpoints of segments (i.e the columns</span>
<span class="sd">            in *spectrum*)</span>

<span class="sd">          *im*: instance of class :class:`~matplotlib.image.AxesImage`</span>
<span class="sd">            The image created by imshow containing the spectrogram</span>

<span class="sd">        **Example:**</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/specgram_demo.py</span>

<span class="sd">        .. seealso::</span>

<span class="sd">            :func:`psd`</span>
<span class="sd">                :func:`psd` differs in the default overlap; in returning</span>
<span class="sd">                the mean of the segment periodograms; in not returning</span>
<span class="sd">                times; and in generating a line plot instead of colormap.</span>

<span class="sd">            :func:`magnitude_spectrum`</span>
<span class="sd">                A single spectrum, similar to having a single segment when</span>
<span class="sd">                *mode* is &#39;magnitude&#39;.  Plots a line instead of a colormap.</span>

<span class="sd">            :func:`angle_spectrum`</span>
<span class="sd">                A single spectrum, similar to having a single segment when</span>
<span class="sd">                *mode* is &#39;angle&#39;.  Plots a line instead of a colormap.</span>

<span class="sd">            :func:`phase_spectrum`</span>
<span class="sd">                A single spectrum, similar to having a single segment when</span>
<span class="sd">                *mode* is &#39;phase&#39;.  Plots a line instead of a colormap.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hold</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cla</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">Fc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">Fc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;complex&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot plot a complex specgram&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">]:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="s1">&#39;dB&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot use dB scale with angle or phase mode&#39;</span><span class="p">)</span>

        <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">specgram</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">NFFT</span><span class="o">=</span><span class="n">NFFT</span><span class="p">,</span> <span class="n">Fs</span><span class="o">=</span><span class="n">Fs</span><span class="p">,</span>
                                       <span class="n">detrend</span><span class="o">=</span><span class="n">detrend</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                       <span class="n">noverlap</span><span class="o">=</span><span class="n">noverlap</span><span class="p">,</span> <span class="n">pad_to</span><span class="o">=</span><span class="n">pad_to</span><span class="p">,</span>
                                       <span class="n">sides</span><span class="o">=</span><span class="n">sides</span><span class="p">,</span>
                                       <span class="n">scale_by_freq</span><span class="o">=</span><span class="n">scale_by_freq</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">spec</span>
        <span class="k">elif</span> <span class="n">scale</span> <span class="o">==</span> <span class="s1">&#39;dB&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;psd&#39;</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="mf">10.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="mf">20.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown scale </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">xextent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">xextent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span> <span class="o">=</span> <span class="n">xextent</span>
        <span class="n">freqs</span> <span class="o">+=</span> <span class="n">Fc</span>
        <span class="n">extent</span> <span class="o">=</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">freqs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">cmap</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
                         <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">spec</span><span class="p">,</span> <span class="n">freqs</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">im</span></div>

<div class="viewcode-block" id="Axes.spy"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.spy.html#mpl.axes.Axes.spy">[docs]</a>    <span class="k">def</span> <span class="nf">spy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s2">&quot;upper&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the sparsity pattern on a 2-D array.</span>

<span class="sd">        ``spy(Z)`` plots the sparsity pattern of the 2-D array *Z*.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        Z : sparse array (n, m)</span>
<span class="sd">            The array to be plotted.</span>

<span class="sd">        precision : float, optional, default: 0</span>
<span class="sd">            If *precision* is 0, any non-zero value will be plotted; else,</span>
<span class="sd">            values of :math:`|Z| &gt; precision` will be plotted.</span>

<span class="sd">            For :class:`scipy.sparse.spmatrix` instances, there is a special</span>
<span class="sd">            case: if *precision* is &#39;present&#39;, any value present in the array</span>
<span class="sd">            will be plotted, even if it is identically zero.</span>

<span class="sd">        origin : [&quot;upper&quot;, &quot;lower&quot;], optional, default: &quot;upper&quot;</span>
<span class="sd">            Place the [0,0] index of the array in the upper left or lower left</span>
<span class="sd">            corner of the axes.</span>

<span class="sd">        aspect : [&#39;auto&#39; | &#39;equal&#39; | scalar], optional, default: &quot;equal&quot;</span>

<span class="sd">            If &#39;equal&#39;, and `extent` is None, changes the axes aspect ratio to</span>
<span class="sd">            match that of the image. If `extent` is not `None`, the axes</span>
<span class="sd">            aspect ratio is changed to match that of the extent.</span>


<span class="sd">            If &#39;auto&#39;, changes the image aspect ratio to match that of the</span>
<span class="sd">            axes.</span>

<span class="sd">            If None, default to rc ``image.aspect`` value.</span>

<span class="sd">        Two plotting styles are available: image or marker. Both</span>
<span class="sd">        are available for full arrays, but only the marker style</span>
<span class="sd">        works for :class:`scipy.sparse.spmatrix` instances.</span>

<span class="sd">        If *marker* and *markersize* are *None*, an image will be</span>
<span class="sd">        returned and any remaining kwargs are passed to</span>
<span class="sd">        :func:`~matplotlib.pyplot.imshow`; else, a</span>
<span class="sd">        :class:`~matplotlib.lines.Line2D` object will be returned with</span>
<span class="sd">        the value of marker determining the marker type, and any</span>
<span class="sd">        remaining kwargs passed to the</span>
<span class="sd">        :meth:`~matplotlib.axes.Axes.plot` method.</span>

<span class="sd">        If *marker* and *markersize* are *None*, useful kwargs include:</span>

<span class="sd">        * *cmap*</span>
<span class="sd">        * *alpha*</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        imshow : for image options.</span>
<span class="sd">        plot : for plotting options</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="s1">&#39;tocoo&#39;</span><span class="p">):</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
        <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>

            <span class="k">if</span> <span class="s1">&#39;cmap&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;cmap&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mcolors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">([</span><span class="s1">&#39;w&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">],</span>
                                                        <span class="n">name</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">)</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">extent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">nc</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">nr</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;nearest&#39;</span><span class="p">,</span> <span class="n">aspect</span><span class="o">=</span><span class="n">aspect</span><span class="p">,</span>
                                <span class="n">extent</span><span class="o">=</span><span class="n">extent</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="s1">&#39;tocoo&#39;</span><span class="p">):</span>
                <span class="n">c</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">tocoo</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">precision</span> <span class="o">==</span> <span class="s1">&#39;present&#39;</span><span class="p">:</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">row</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">col</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">row</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">nonzero</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
                <span class="n">nonzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precision</span>
                <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">nonzero</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">marker</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">marker</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
            <span class="k">if</span> <span class="n">markersize</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">markersize</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">marks</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span>
                         <span class="n">marker</span><span class="o">=</span><span class="n">marker</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="n">markersize</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">marks</span><span class="p">)</span>
            <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">xmin</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">xmax</span><span class="o">=</span><span class="n">nc</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">ymin</span><span class="o">=</span><span class="n">nr</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">ymax</span><span class="o">=-</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="n">aspect</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">marks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_y</span><span class="p">(</span><span class="mf">1.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_top</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Axes.matshow"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.matshow.html#mpl.axes.Axes.matshow">[docs]</a>    <span class="k">def</span> <span class="nf">matshow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot a matrix or array as an image.</span>

<span class="sd">        The matrix will be shown the way it would be printed, with the first</span>
<span class="sd">        row at the top.  Row and column numbering is zero-based.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Z : array_like shape (n, m)</span>
<span class="sd">            The matrix to be displayed.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        image : `~matplotlib.image.AxesImage`</span>

<span class="sd">        Other parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        kwargs : `~matplotlib.axes.Axes.imshow` arguments</span>
<span class="sd">            Sets `origin` to &#39;upper&#39;, &#39;interpolation&#39; to &#39;nearest&#39; and</span>
<span class="sd">            &#39;aspect&#39; to equal.</span>

<span class="sd">        See also</span>
<span class="sd">        --------</span>
<span class="sd">        imshow : plot an image</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        .. plot:: mpl_examples/pylab_examples/matshow.py</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
        <span class="n">nr</span><span class="p">,</span> <span class="n">nc</span> <span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;origin&#39;</span><span class="p">:</span> <span class="s1">&#39;upper&#39;</span><span class="p">,</span>
              <span class="s1">&#39;interpolation&#39;</span><span class="p">:</span> <span class="s1">&#39;nearest&#39;</span><span class="p">,</span>
              <span class="s1">&#39;aspect&#39;</span><span class="p">:</span> <span class="s1">&#39;equal&#39;</span><span class="p">}</span>          <span class="c1"># (already the imshow default)</span>
        <span class="n">kw</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">im</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">title</span><span class="o">.</span><span class="n">set_y</span><span class="p">(</span><span class="mf">1.05</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">tick_top</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks_position</span><span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">mticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">nbins</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>
                                                 <span class="n">steps</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span>
                                                 <span class="n">integer</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">im</span></div>

    <span class="nd">@unpack_labeled_data</span><span class="p">(</span><span class="n">replace_names</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;dataset&quot;</span><span class="p">],</span> <span class="n">label_namer</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
<div class="viewcode-block" id="Axes.violinplot"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.violinplot.html#mpl.axes.Axes.violinplot">[docs]</a>    <span class="k">def</span> <span class="nf">violinplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                   <span class="n">showmeans</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">showextrema</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="n">points</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">bw_method</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a violin plot.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          violinplot(dataset, positions=None, vert=True, widths=0.5,</span>
<span class="sd">                     showmeans=False, showextrema=True, showmedians=False,</span>
<span class="sd">                     points=100, bw_method=None):</span>

<span class="sd">        Make a violin plot for each column of *dataset* or each vector in</span>
<span class="sd">        sequence *dataset*.  Each filled area extends to represent the</span>
<span class="sd">        entire data range, with optional lines at the mean, the median,</span>
<span class="sd">        the minimum, and the maximum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataset : Array or a sequence of vectors.</span>
<span class="sd">          The input data.</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">          Sets the positions of the violins. The ticks and limits are</span>
<span class="sd">          automatically set to match the positions.</span>

<span class="sd">        vert : bool, default = True.</span>
<span class="sd">          If true, creates a vertical violin plot.</span>
<span class="sd">          Otherwise, creates a horizontal violin plot.</span>

<span class="sd">        widths : array-like, default = 0.5</span>
<span class="sd">          Either a scalar or a vector that sets the maximal width of</span>
<span class="sd">          each violin. The default is 0.5, which uses about half of the</span>
<span class="sd">          available horizontal space.</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">          If `True`, will toggle rendering of the means.</span>

<span class="sd">        showextrema : bool, default = True</span>
<span class="sd">          If `True`, will toggle rendering of the extrema.</span>

<span class="sd">        showmedians : bool, default = False</span>
<span class="sd">          If `True`, will toggle rendering of the medians.</span>

<span class="sd">        points : scalar, default = 100</span>
<span class="sd">          Defines the number of points to evaluate each of the</span>
<span class="sd">          gaussian kernel density estimations at.</span>

<span class="sd">        bw_method : str, scalar or callable, optional</span>
<span class="sd">          The method used to calculate the estimator bandwidth.  This can be</span>
<span class="sd">          &#39;scott&#39;, &#39;silverman&#39;, a scalar constant or a callable.  If a</span>
<span class="sd">          scalar, this will be used directly as `kde.factor`.  If a</span>
<span class="sd">          callable, it should take a `GaussianKDE` instance as its only</span>
<span class="sd">          parameter and return a scalar. If None (default), &#39;scott&#39; is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>

<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the violinplot to a</span>
<span class="sd">          list of the corresponding collection instances created. The</span>
<span class="sd">          dictionary has the following keys:</span>

<span class="sd">            - ``bodies``: A list of the</span>
<span class="sd">              :class:`matplotlib.collections.PolyCollection` instances</span>
<span class="sd">              containing the filled area of each violin.</span>

<span class="sd">            - ``cmeans``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the mean values of each of the</span>
<span class="sd">              violin&#39;s distribution.</span>

<span class="sd">            - ``cmins``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the bottom of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmaxes``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the top of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cbars``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the centers of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmedians``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the median values of each of the</span>
<span class="sd">              violin&#39;s distribution.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_kde_method</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
            <span class="c1"># fallback gracefully if the vector contains only one value</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">X</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
            <span class="n">kde</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">GaussianKDE</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">bw_method</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">kde</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

        <span class="n">vpstats</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">violin_stats</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">_kde_method</span><span class="p">,</span> <span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">violin</span><span class="p">(</span><span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">positions</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="n">vert</span><span class="p">,</span>
                           <span class="n">widths</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span> <span class="n">showmeans</span><span class="o">=</span><span class="n">showmeans</span><span class="p">,</span>
                           <span class="n">showextrema</span><span class="o">=</span><span class="n">showextrema</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="n">showmedians</span><span class="p">)</span></div>

<div class="viewcode-block" id="Axes.violin"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.violin.html#mpl.axes.Axes.violin">[docs]</a>    <span class="k">def</span> <span class="nf">violin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">vert</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
               <span class="n">showmeans</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">showextrema</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">showmedians</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drawing function for violin plots.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          violin(vpstats, positions=None, vert=True, widths=0.5,</span>
<span class="sd">                 showmeans=False, showextrema=True, showmedians=False):</span>

<span class="sd">        Draw a violin plot for each column of `vpstats`. Each filled area</span>
<span class="sd">        extends to represent the entire data range, with optional lines at the</span>
<span class="sd">        mean, the median, the minimum, and the maximum.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        vpstats : list of dicts</span>
<span class="sd">          A list of dictionaries containing stats for each violin plot.</span>
<span class="sd">          Required keys are:</span>

<span class="sd">          - ``coords``: A list of scalars containing the coordinates that</span>
<span class="sd">            the violin&#39;s kernel density estimate were evaluated at.</span>

<span class="sd">          - ``vals``: A list of scalars containing the values of the</span>
<span class="sd">            kernel density estimate at each of the coordinates given</span>
<span class="sd">            in *coords*.</span>

<span class="sd">          - ``mean``: The mean value for this violin&#39;s dataset.</span>

<span class="sd">          - ``median``: The median value for this violin&#39;s dataset.</span>

<span class="sd">          - ``min``: The minimum value for this violin&#39;s dataset.</span>

<span class="sd">          - ``max``: The maximum value for this violin&#39;s dataset.</span>

<span class="sd">        positions : array-like, default = [1, 2, ..., n]</span>
<span class="sd">          Sets the positions of the violins. The ticks and limits are</span>
<span class="sd">          automatically set to match the positions.</span>

<span class="sd">        vert : bool, default = True.</span>
<span class="sd">          If true, plots the violins veritcally.</span>
<span class="sd">          Otherwise, plots the violins horizontally.</span>

<span class="sd">        widths : array-like, default = 0.5</span>
<span class="sd">          Either a scalar or a vector that sets the maximal width of</span>
<span class="sd">          each violin. The default is 0.5, which uses about half of the</span>
<span class="sd">          available horizontal space.</span>

<span class="sd">        showmeans : bool, default = False</span>
<span class="sd">          If true, will toggle rendering of the means.</span>

<span class="sd">        showextrema : bool, default = True</span>
<span class="sd">          If true, will toggle rendering of the extrema.</span>

<span class="sd">        showmedians : bool, default = False</span>
<span class="sd">          If true, will toggle rendering of the medians.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : dict</span>
<span class="sd">          A dictionary mapping each component of the violinplot to a</span>
<span class="sd">          list of the corresponding collection instances created. The</span>
<span class="sd">          dictionary has the following keys:</span>

<span class="sd">            - ``bodies``: A list of the</span>
<span class="sd">              :class:`matplotlib.collections.PolyCollection` instances</span>
<span class="sd">              containing the filled area of each violin.</span>

<span class="sd">            - ``cmeans``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the mean values of each of the</span>
<span class="sd">              violin&#39;s distribution.</span>

<span class="sd">            - ``cmins``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the bottom of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmaxes``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the top of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cbars``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the centers of each violin&#39;s</span>
<span class="sd">              distribution.</span>

<span class="sd">            - ``cmedians``: A</span>
<span class="sd">              :class:`matplotlib.collections.LineCollection` instance</span>
<span class="sd">              created to identify the median values of each of the</span>
<span class="sd">              violin&#39;s distribution.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Statistical quantities to be plotted on the violins</span>
        <span class="n">means</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">mins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">maxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">medians</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Collections to be returned</span>
        <span class="n">artists</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vpstats</span><span class="p">)</span>
        <span class="n">datashape_message</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;List of violinplot statistics and `{0}` &quot;</span>
                             <span class="s2">&quot;values must have the same length&quot;</span><span class="p">)</span>

        <span class="c1"># Validate positions</span>
        <span class="k">if</span> <span class="n">positions</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">positions</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">positions</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;positions&quot;</span><span class="p">))</span>

        <span class="c1"># Validate widths</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">widths</span><span class="p">):</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">widths</span><span class="p">]</span> <span class="o">*</span> <span class="n">N</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">datashape_message</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;widths&quot;</span><span class="p">))</span>

        <span class="c1"># Calculate ranges for statistics lines</span>
        <span class="n">pmins</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">+</span> <span class="n">positions</span>
        <span class="n">pmaxes</span> <span class="o">=</span> <span class="mf">0.25</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">widths</span><span class="p">)</span> <span class="o">+</span> <span class="n">positions</span>

        <span class="c1"># Check whether we are rendering vertically or horizontally</span>
        <span class="k">if</span> <span class="n">vert</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_betweenx</span>
            <span class="n">perp_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hlines</span>
            <span class="n">par_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_between</span>
            <span class="n">perp_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vlines</span>
            <span class="n">par_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hlines</span>

        <span class="c1"># Render violins</span>
        <span class="n">bodies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">stats</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">width</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">vpstats</span><span class="p">,</span> <span class="n">positions</span><span class="p">,</span> <span class="n">widths</span><span class="p">):</span>
            <span class="c1"># The 0.5 factor reflects the fact that we plot from v-p to</span>
            <span class="c1"># v+p</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;vals&#39;</span><span class="p">])</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">width</span> <span class="o">*</span> <span class="n">vals</span> <span class="o">/</span> <span class="n">vals</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="n">bodies</span> <span class="o">+=</span> <span class="p">[</span><span class="n">fill</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">],</span>
                            <span class="o">-</span><span class="n">vals</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span>
                            <span class="n">vals</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span>
                            <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span>
                            <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)]</span>
            <span class="n">means</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;mean&#39;</span><span class="p">])</span>
            <span class="n">mins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">])</span>
            <span class="n">maxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">])</span>
            <span class="n">medians</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="p">[</span><span class="s1">&#39;median&#39;</span><span class="p">])</span>
        <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;bodies&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bodies</span>

        <span class="c1"># Render means</span>
        <span class="k">if</span> <span class="n">showmeans</span><span class="p">:</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmeans&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">means</span><span class="p">,</span> <span class="n">pmins</span><span class="p">,</span> <span class="n">pmaxes</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="c1"># Render extrema</span>
        <span class="k">if</span> <span class="n">showextrema</span><span class="p">:</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmaxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">maxes</span><span class="p">,</span> <span class="n">pmins</span><span class="p">,</span> <span class="n">pmaxes</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmins&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">mins</span><span class="p">,</span> <span class="n">pmins</span><span class="p">,</span> <span class="n">pmaxes</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cbars&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">par_lines</span><span class="p">(</span><span class="n">positions</span><span class="p">,</span> <span class="n">mins</span><span class="p">,</span> <span class="n">maxes</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="c1"># Render medians</span>
        <span class="k">if</span> <span class="n">showmedians</span><span class="p">:</span>
            <span class="n">artists</span><span class="p">[</span><span class="s1">&#39;cmedians&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">perp_lines</span><span class="p">(</span><span class="n">medians</span><span class="p">,</span>
                                             <span class="n">pmins</span><span class="p">,</span>
                                             <span class="n">pmaxes</span><span class="p">,</span>
                                             <span class="n">colors</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">artists</span></div>

<div class="viewcode-block" id="Axes.tricontour"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.tricontour.html#mpl.axes.Axes.tricontour">[docs]</a>    <span class="k">def</span> <span class="nf">tricontour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">tricontour</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">TriContourSet</span><span class="o">.</span><span class="n">tricontour_doc</span>

<div class="viewcode-block" id="Axes.tricontourf"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.tricontourf.html#mpl.axes.Axes.tricontourf">[docs]</a>    <span class="k">def</span> <span class="nf">tricontourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tricontourf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">tricontourf</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">TriContourSet</span><span class="o">.</span><span class="n">tricontour_doc</span>

<div class="viewcode-block" id="Axes.tripcolor"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.tripcolor.html#mpl.axes.Axes.tripcolor">[docs]</a>    <span class="k">def</span> <span class="nf">tripcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tripcolor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">tripcolor</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">tripcolor</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="Axes.triplot"><a class="viewcode-back" href="../../../generated/generated/mpl.axes.Axes.triplot.html#mpl.axes.Axes.triplot">[docs]</a>    <span class="k">def</span> <span class="nf">triplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">mtri</span><span class="o">.</span><span class="n">triplot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>
    <span class="n">triplot</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">mtri</span><span class="o">.</span><span class="n">triplot</span><span class="o">.</span><span class="n">__doc__</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>
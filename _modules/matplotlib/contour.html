

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>matplotlib.contour &mdash; Matplotlib API 1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Matplotlib API 1 documentation" href="../../index.html"/>
        <link rel="up" title="matplotlib" href="../matplotlib.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> Matplotlib API
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.html">1. matplotlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.pyplot.html">2. matplotlib.pyplot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.axes.html">3. matplotlib.axes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.axis.html">4. matplotlib.axis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.cm.html">5. matplotlib.cm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.colorbar.html">6. matplotlib.colorbar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.colors.html">7. matplotlib.colors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.figure.html">8. matplotlib.figure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.legend.html">9. matplotlib.legend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.lines.html">10. matplotlib.lines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.markers.html">11. matplotlib.markers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.patches.html">12. matplotlib.patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.style.html">13. matplotlib.style</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.text.html">14. matplotlib.text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.widgets.html">15. matplotlib.widgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../separator.html">16. ===== INFREQ =====</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.animation.html">17. matplotlib.animation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.artist.html">18. matplotlib.artist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.backends.html">19. matplotlib.backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.cbook.html">20. matplotlib.cbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.collections.html">21. matplotlib.collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.dates.html">22. matplotlib.dates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.dviread.html">23. matplotlib.dviread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.finance.html">24. matplotlib.finance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.font_manager.html">25. matplotlib.font_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.gridspec.html">26. matplotlib.gridspec</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.image.html">27. matplotlib.image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.mathtext.html">28. matplotlib.mathtext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.mlab.html">29. matplotlib.mlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.offsetbox.html">30. matplotlib.offsetbox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.path.html">31. matplotlib.path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.patheffects.html">32. matplotlib.patheffects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.sankey.html">33. matplotlib.sankey</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.spines.html">34. matplotlib.spines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.ticker.html">35. matplotlib.ticker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.tight_layout.html">36. matplotlib.tight_layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.tri.html">37. matplotlib.tri</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.type1font.html">38. matplotlib.type1font</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.units.html">39. matplotlib.units</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Matplotlib API</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../matplotlib.html">matplotlib</a> &raquo;</li>
        
      <li>matplotlib.contour</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for matplotlib.contour</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">These are  classes to support contour plotting and</span>
<span class="sd">labelling for the axes class</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">matplotlib.externals</span> <span class="k">import</span> <span class="n">six</span>
<span class="kn">from</span> <span class="nn">matplotlib.externals.six.moves</span> <span class="k">import</span> <span class="n">xrange</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">matplotlib</span> <span class="k">as</span> <span class="nn">mpl</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">ma</span>
<span class="kn">import</span> <span class="nn">matplotlib._cntr</span> <span class="k">as</span> <span class="nn">_cntr</span>
<span class="kn">import</span> <span class="nn">matplotlib._contour</span> <span class="k">as</span> <span class="nn">_contour</span>
<span class="kn">import</span> <span class="nn">matplotlib.path</span> <span class="k">as</span> <span class="nn">mpath</span>
<span class="kn">import</span> <span class="nn">matplotlib.ticker</span> <span class="k">as</span> <span class="nn">ticker</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">import</span> <span class="nn">matplotlib.colors</span> <span class="k">as</span> <span class="nn">colors</span>
<span class="kn">import</span> <span class="nn">matplotlib.collections</span> <span class="k">as</span> <span class="nn">mcoll</span>
<span class="kn">import</span> <span class="nn">matplotlib.font_manager</span> <span class="k">as</span> <span class="nn">font_manager</span>
<span class="kn">import</span> <span class="nn">matplotlib.text</span> <span class="k">as</span> <span class="nn">text</span>
<span class="kn">import</span> <span class="nn">matplotlib.cbook</span> <span class="k">as</span> <span class="nn">cbook</span>
<span class="kn">import</span> <span class="nn">matplotlib.mlab</span> <span class="k">as</span> <span class="nn">mlab</span>
<span class="kn">import</span> <span class="nn">matplotlib.mathtext</span> <span class="k">as</span> <span class="nn">mathtext</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">matplotlib.texmanager</span> <span class="k">as</span> <span class="nn">texmanager</span>
<span class="kn">import</span> <span class="nn">matplotlib.transforms</span> <span class="k">as</span> <span class="nn">mtrans</span>

<span class="c1"># Import needed for adding manual selection capability to clabel</span>
<span class="kn">from</span> <span class="nn">matplotlib.blocking_input</span> <span class="k">import</span> <span class="n">BlockingContourLabeler</span>

<span class="c1"># We can&#39;t use a single line collection for contour because a line</span>
<span class="c1"># collection can have only a single line style, and we want to be able to have</span>
<span class="c1"># dashed negative contours, for example, and solid positive contours.</span>
<span class="c1"># We could use a single polygon collection for filled contours, but it</span>
<span class="c1"># seems better to keep line and filled contours similar, with one collection</span>
<span class="c1"># per level.</span>


<span class="k">class</span> <span class="nc">ClabelText</span><span class="p">(</span><span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unlike the ordinary text, the get_rotation returns an updated</span>
<span class="sd">    angle in the pixel coordinate assuming that the input rotation is</span>
<span class="sd">    an angle in data coordinate (or whatever transform set).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
        <span class="n">new_angles</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform_angles</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">angle</span><span class="p">]),</span>
                                            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]]))</span>
        <span class="k">return</span> <span class="n">new_angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">ContourLabeler</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Mixin to provide labelling capability to ContourSet&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">clabel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Label a contour plot.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          clabel(cs, **kwargs)</span>

<span class="sd">        Adds labels to line contours in *cs*, where *cs* is a</span>
<span class="sd">        :class:`~matplotlib.contour.ContourSet` object returned by</span>
<span class="sd">        contour.</span>

<span class="sd">        ::</span>

<span class="sd">          clabel(cs, v, **kwargs)</span>

<span class="sd">        only labels contours listed in *v*.</span>

<span class="sd">        Optional keyword arguments:</span>

<span class="sd">          *fontsize*:</span>
<span class="sd">            size in points or relative size e.g., &#39;smaller&#39;, &#39;x-large&#39;</span>

<span class="sd">          *colors*:</span>
<span class="sd">            - if *None*, the color of each label matches the color of</span>
<span class="sd">              the corresponding contour</span>

<span class="sd">            - if one string color, e.g., *colors* = &#39;r&#39; or *colors* =</span>
<span class="sd">              &#39;red&#39;, all labels will be plotted in this color</span>

<span class="sd">            - if a tuple of matplotlib color args (string, float, rgb, etc),</span>
<span class="sd">              different labels will be plotted in different colors in the order</span>
<span class="sd">              specified</span>

<span class="sd">          *inline*:</span>
<span class="sd">            controls whether the underlying contour is removed or</span>
<span class="sd">            not. Default is *True*.</span>

<span class="sd">          *inline_spacing*:</span>
<span class="sd">            space in pixels to leave on each side of label when</span>
<span class="sd">            placing inline.  Defaults to 5.  This spacing will be</span>
<span class="sd">            exact for labels at locations where the contour is</span>
<span class="sd">            straight, less so for labels on curved contours.</span>

<span class="sd">          *fmt*:</span>
<span class="sd">            a format string for the label. Default is &#39;%1.3f&#39;</span>
<span class="sd">            Alternatively, this can be a dictionary matching contour</span>
<span class="sd">            levels with arbitrary strings to use for each contour level</span>
<span class="sd">            (i.e., fmt[level]=string), or it can be any callable, such</span>
<span class="sd">            as a :class:`~matplotlib.ticker.Formatter` instance, that</span>
<span class="sd">            returns a string when called with a numeric contour level.</span>

<span class="sd">          *manual*:</span>
<span class="sd">            if *True*, contour labels will be placed manually using</span>
<span class="sd">            mouse clicks.  Click the first button near a contour to</span>
<span class="sd">            add a label, click the second button (or potentially both</span>
<span class="sd">            mouse buttons at once) to finish adding labels.  The third</span>
<span class="sd">            button can be used to remove the last label added, but</span>
<span class="sd">            only if labels are not inline.  Alternatively, the keyboard</span>
<span class="sd">            can be used to select label locations (enter to end label</span>
<span class="sd">            placement, delete or backspace act like the third mouse button,</span>
<span class="sd">            and any other key will select a label location).</span>

<span class="sd">            *manual* can be an iterable object of x,y tuples. Contour labels</span>
<span class="sd">            will be created as if mouse is clicked at each x,y positions.</span>

<span class="sd">          *rightside_up*:</span>
<span class="sd">            if *True* (default), label rotations will always be plus</span>
<span class="sd">            or minus 90 degrees from level.</span>

<span class="sd">          *use_clabeltext*:</span>
<span class="sd">            if *True* (default is False), ClabelText class (instead of</span>
<span class="sd">            matplotlib.Text) is used to create labels. ClabelText</span>
<span class="sd">            recalculates rotation angles of texts during the drawing time,</span>
<span class="sd">            therefore this can be used if aspect of the axes changes.</span>

<span class="sd">        .. plot:: mpl_examples/pylab_examples/contour_demo.py</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        NOTES on how this all works:</span>

<span class="sd">        clabel basically takes the input arguments and uses them to</span>
<span class="sd">        add a list of &quot;label specific&quot; attributes to the ContourSet</span>
<span class="sd">        object.  These attributes are all of the form label* and names</span>
<span class="sd">        should be fairly self explanatory.</span>

<span class="sd">        Once these attributes are set, clabel passes control to the</span>
<span class="sd">        labels method (case of automatic label placement) or</span>
<span class="sd">        BlockingContourLabeler (case of manual label placement).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fontsize</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fontsize&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">inline</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inline&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">inline_spacing</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;inline_spacing&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;fmt&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">%1.3f</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">_colors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;colors&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_use_clabeltext</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;use_clabeltext&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Detect if manual selection is desired and remove from argument list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;manual&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rightside_up</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;rightside_up&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">levlabs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">indices</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lev</span> <span class="ow">in</span> <span class="n">levlabs</span><span class="p">:</span>
                    <span class="n">indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">levlabs</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Specified levels &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">levlabs</span><span class="p">)</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> don&#39;t match available levels &quot;</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Illegal arguments to clabel, see help(clabel)&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span> <span class="o">=</span> <span class="n">levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span> <span class="o">=</span> <span class="n">indices</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span> <span class="o">=</span> <span class="n">font_manager</span><span class="o">.</span><span class="n">FontProperties</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="o">.</span><span class="n">set_size</span><span class="p">(</span><span class="n">fontsize</span><span class="p">)</span>
        <span class="n">font_size_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="o">.</span><span class="n">get_size_in_points</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelFontSizeList</span> <span class="o">=</span> <span class="p">[</span><span class="n">font_size_pts</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">_colors</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cmap</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="n">_colors</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">cmap</span><span class="o">=</span><span class="n">cmap</span><span class="p">,</span>
                                                   <span class="n">norm</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">NoNorm</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_label_near</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">inline</span><span class="p">,</span>
                                    <span class="n">inline_spacing</span><span class="p">)</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelManual</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Select label locations manually using first mouse button.&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;End manual selection with second mouse button.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">inline</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Remove last label by clicking third mouse button.&#39;</span><span class="p">)</span>

            <span class="n">blocking_contour_labeler</span> <span class="o">=</span> <span class="n">BlockingContourLabeler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">blocking_contour_labeler</span><span class="p">(</span><span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">(</span><span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">)</span>

        <span class="c1"># Hold on to some old attribute names.  These are deprecated and will</span>
        <span class="c1"># be removed in the near future (sometime after 2008-08-01), but</span>
        <span class="c1"># keeping for now for backwards compatibility</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cl_xy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cl_cvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">labelTextsList</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">&#39;text.Text&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTextsList</span>

    <span class="k">def</span> <span class="nf">print_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linecontour</span><span class="p">,</span> <span class="n">labelwidth</span><span class="p">):</span>
        <span class="s2">&quot;Return *False* if contours are too short for a label.&quot;</span>
        <span class="n">lcsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">linecontour</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lcsize</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">labelwidth</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="n">lw</span> <span class="o">=</span> <span class="n">labelwidth</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">-</span> <span class="n">xmin</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">lw</span> <span class="ow">or</span> <span class="p">(</span><span class="n">ymax</span> <span class="o">-</span> <span class="n">ymin</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">lw</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">too_close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="s2">&quot;Return *True* if a label is already near this location.&quot;</span>
        <span class="k">for</span> <span class="n">loc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mf">1.2</span> <span class="o">*</span> <span class="n">lw</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">get_label_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distances</span><span class="p">,</span> <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return x, y, and the index of a label location.</span>

<span class="sd">        Labels are plotted at a location with the smallest</span>
<span class="sd">        deviation of the contour from a straight line</span>
<span class="sd">        unless there is another label nearby, in which case</span>
<span class="sd">        the next best place on the contour is picked up.</span>
<span class="sd">        If all such candidates are rejected, the beginning</span>
<span class="sd">        of the contour is chosen.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hysize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ysize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">adist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">adist</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">],</span> <span class="n">YY</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">too_close</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span>

        <span class="n">ind</span> <span class="o">=</span> <span class="n">adist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">],</span> <span class="n">YY</span><span class="p">[</span><span class="n">ind</span><span class="p">][</span><span class="n">hysize</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span>

    <span class="k">def</span> <span class="nf">get_label_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">fsize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the width of the label in points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">is_string_like</span><span class="p">(</span><span class="n">lev</span><span class="p">):</span>
            <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">)</span>

        <span class="n">lev</span><span class="p">,</span> <span class="n">ismath</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="o">.</span><span class="n">is_math_text</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ismath</span> <span class="o">==</span> <span class="s1">&#39;TeX&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_TeX_manager&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_TeX_manager</span> <span class="o">=</span> <span class="n">texmanager</span><span class="o">.</span><span class="n">TexManager</span><span class="p">()</span>
            <span class="n">lw</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_TeX_manager</span><span class="o">.</span><span class="n">get_text_width_height_descent</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span>
                                                                       <span class="n">fsize</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ismath</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_mathtext_parser&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mathtext_parser</span> <span class="o">=</span> <span class="n">mathtext</span><span class="o">.</span><span class="n">MathTextParser</span><span class="p">(</span><span class="s1">&#39;bitmap&#39;</span><span class="p">)</span>
            <span class="n">img</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mathtext_parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">72</span><span class="p">,</span>
                                                 <span class="n">prop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="p">)</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span>  <span class="c1"># at dpi=72, the units are PostScript points</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># width is much less than &quot;font size&quot;</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lev</span><span class="p">))</span> <span class="o">*</span> <span class="n">fsize</span> <span class="o">*</span> <span class="mf">0.6</span>

        <span class="k">return</span> <span class="n">lw</span>

    <span class="k">def</span> <span class="nf">get_real_label_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">,</span> <span class="n">fsize</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This computes actual onscreen label width.</span>
<span class="sd">        This uses some black magic to determine onscreen extent of non-drawn</span>
<span class="sd">        label.  This magic may not be very robust.</span>

<span class="sd">        This method is not being used, and may be modified or removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find middle of axes</span>
        <span class="n">xx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">axis</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Temporarily create text object</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="n">xx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xx</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_label_props</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">),</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>

        <span class="c1"># Some black magic to get onscreen extent</span>
        <span class="c1"># NOTE: This will only work for already drawn figures, as the canvas</span>
        <span class="c1"># does not have a renderer otherwise.  This is the reason this function</span>
        <span class="c1"># can&#39;t be integrated into the rest of the code.</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">(</span><span class="n">renderer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">renderer</span><span class="p">)</span>

        <span class="c1"># difference in pixel extent of image</span>
        <span class="n">lw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bbox</span><span class="o">.</span><span class="n">corners</span><span class="p">()[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">lw</span>

    <span class="k">def</span> <span class="nf">set_label_props</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">text</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
        <span class="s2">&quot;set the label properties - color, fontsize, text&quot;</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_fontproperties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelFontProps</span><span class="p">)</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_clip_box</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">bbox</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="s2">&quot;get the text of the label&quot;</span>
        <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">is_string_like</span><span class="p">(</span><span class="n">lev</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">lev</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">fmt</span><span class="p">[</span><span class="n">lev</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">six</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">fmt</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">fmt</span><span class="p">(</span><span class="n">lev</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fmt</span> <span class="o">%</span> <span class="n">lev</span>

    <span class="k">def</span> <span class="nf">locate_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linecontour</span><span class="p">,</span> <span class="n">labelwidth</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a good place to plot a label (relatively flat</span>
<span class="sd">        part of the contour).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nsize</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">linecontour</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">labelwidth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">xsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">nsize</span> <span class="o">/</span> <span class="n">labelwidth</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xsize</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">xsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ysize</span> <span class="o">=</span> <span class="n">nsize</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ysize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">labelwidth</span><span class="p">)</span>

        <span class="n">XX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">))</span>
        <span class="n">YY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">linecontour</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="n">ysize</span><span class="p">))</span>
        <span class="c1"># I might have fouled up the following:</span>
        <span class="n">yfirst</span> <span class="o">=</span> <span class="n">YY</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ylast</span> <span class="o">=</span> <span class="n">YY</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">xfirst</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">xlast</span> <span class="o">=</span> <span class="n">XX</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">yfirst</span> <span class="o">-</span> <span class="n">YY</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">xlast</span> <span class="o">-</span> <span class="n">xfirst</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">xfirst</span> <span class="o">-</span> <span class="n">XX</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">ylast</span> <span class="o">-</span> <span class="n">yfirst</span><span class="p">)</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">xlast</span> <span class="o">-</span> <span class="n">xfirst</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">ylast</span> <span class="o">-</span> <span class="n">yfirst</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(([(</span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xsize</span><span class="p">)]),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_coords</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">XX</span><span class="p">,</span> <span class="n">YY</span><span class="p">,</span> <span class="n">ysize</span><span class="p">,</span> <span class="n">labelwidth</span><span class="p">)</span>

        <span class="c1"># There must be a more efficient way...</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">linecontour</span><span class="p">]</span>
        <span class="n">dind</span> <span class="o">=</span> <span class="n">lc</span><span class="o">.</span><span class="n">index</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dind</span>

    <span class="k">def</span> <span class="nf">calc_label_rot_and_inline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">slc</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">lc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">spacing</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function calculates the appropriate label rotation given</span>
<span class="sd">        the linecontour coordinates in screen units, the index of the</span>
<span class="sd">        label location and the label width.</span>

<span class="sd">        It will also break contour and calculate inlining if *lc* is</span>
<span class="sd">        not empty (lc defaults to the empty list if None).  *spacing*</span>
<span class="sd">        is the space around the label in pixels to leave empty.</span>

<span class="sd">        Do both of these tasks at once to avoid calling mlab.path_length</span>
<span class="sd">        multiple times, which is relatively costly.</span>

<span class="sd">        The method used here involves calculating the path length</span>
<span class="sd">        along the contour in pixel coordinates and then looking</span>
<span class="sd">        approximately label width / 2 away from central point to</span>
<span class="sd">        determine rotation and then to break contour if desired.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">lc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Half the label width</span>
        <span class="n">hlw</span> <span class="o">=</span> <span class="n">lw</span> <span class="o">/</span> <span class="mf">2.0</span>

        <span class="c1"># Check if closed and, if so, rotate contour so label is at edge</span>
        <span class="n">closed</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">is_closed_polygon</span><span class="p">(</span><span class="n">slc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">slc</span><span class="p">[</span><span class="n">ind</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">slc</span><span class="p">[:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>  <span class="c1"># Rotate lc also if not empty</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">lc</span><span class="p">[</span><span class="n">ind</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">lc</span><span class="p">[:</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>

            <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Path length in pixel space</span>
        <span class="n">pl</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">path_length</span><span class="p">(</span><span class="n">slc</span><span class="p">)</span>
        <span class="n">pl</span> <span class="o">=</span> <span class="n">pl</span> <span class="o">-</span> <span class="n">pl</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>

        <span class="c1"># Use linear interpolation to get points around label</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">hlw</span><span class="p">,</span> <span class="n">hlw</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>  <span class="c1"># Look at end also for closed contours</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span>

        <span class="n">ll</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">less_simple_linear_interpolation</span><span class="p">(</span><span class="n">pl</span><span class="p">,</span> <span class="n">slc</span><span class="p">,</span> <span class="n">dp</span> <span class="o">+</span> <span class="n">xi</span><span class="p">,</span>
                                                   <span class="n">extrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># get vector in pixel space coordinates from one point to other</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ll</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Get angle of vector - must be calculated in pixel space for</span>
        <span class="c1"># text rotation to work correctly</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># Must deal with case of zero length label</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">dd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dd</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rightside_up</span><span class="p">:</span>
            <span class="c1"># Fix angle so text is never upside-down</span>
            <span class="k">if</span> <span class="n">rotation</span> <span class="o">&gt;</span> <span class="mi">90</span><span class="p">:</span>
                <span class="n">rotation</span> <span class="o">=</span> <span class="n">rotation</span> <span class="o">-</span> <span class="mf">180.0</span>
            <span class="k">if</span> <span class="n">rotation</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">90</span><span class="p">:</span>
                <span class="n">rotation</span> <span class="o">=</span> <span class="mf">180.0</span> <span class="o">+</span> <span class="n">rotation</span>

        <span class="c1"># Break contour if desired</span>
        <span class="n">nlc</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>
            <span class="c1"># Expand range by spacing</span>
            <span class="n">xi</span> <span class="o">=</span> <span class="n">dp</span> <span class="o">+</span> <span class="n">xi</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">spacing</span><span class="p">,</span> <span class="n">spacing</span><span class="p">])</span>

            <span class="c1"># Get indices near points of interest</span>
            <span class="n">I</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">less_simple_linear_interpolation</span><span class="p">(</span>
                <span class="n">pl</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pl</span><span class="p">)),</span> <span class="n">xi</span><span class="p">,</span> <span class="n">extrap</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="c1"># If those indices aren&#39;t beyond contour edge, find x,y</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">xy1</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">less_simple_linear_interpolation</span><span class="p">(</span>
                    <span class="n">pl</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">xy2</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">less_simple_linear_interpolation</span><span class="p">(</span>
                    <span class="n">pl</span><span class="p">,</span> <span class="n">lc</span><span class="p">,</span> <span class="p">[</span><span class="n">xi</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># Round to integer values but keep as float</span>
            <span class="c1"># To allow check against nan below</span>
            <span class="n">I</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>

            <span class="c1"># Actually break contours</span>
            <span class="k">if</span> <span class="n">closed</span><span class="p">:</span>
                <span class="c1"># This will remove contour if shorter than label</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">I</span><span class="p">)):</span>
                    <span class="n">nlc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">xy2</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xy1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># These will remove pieces of contour if they have length zero</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">nlc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">lc</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xy1</span><span class="p">])</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">nlc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">xy2</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">I</span><span class="p">[</span><span class="mi">1</span><span class="p">]):]])</span>

            <span class="c1"># The current implementation removes contours completely</span>
            <span class="c1"># covered by labels.  Uncomment line below to keep</span>
            <span class="c1"># original contour if this is the preferred behavior.</span>
            <span class="c1"># if not len(nlc): nlc = [ lc ]</span>

        <span class="k">return</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">nlc</span>

    <span class="k">def</span> <span class="nf">_get_label_text</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span><span class="o">.</span><span class="n">transform_point</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">Text</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">rotation</span><span class="p">,</span>
                      <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                      <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_get_label_clabeltext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">):</span>
        <span class="c1"># x, y, rotation is given in pixel coordinate. Convert them to</span>
        <span class="c1"># the data coordinate and create a label using ClabelText</span>
        <span class="c1"># class. This way, the roation of the clabel is along the</span>
        <span class="c1"># contour line always.</span>
        <span class="n">transDataInv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">transDataInv</span><span class="o">.</span><span class="n">transform_point</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
        <span class="n">drotation</span> <span class="o">=</span> <span class="n">transDataInv</span><span class="o">.</span><span class="n">transform_angles</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">rotation</span><span class="p">]),</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]]))</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">ClabelText</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="n">drotation</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                       <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span>
                       <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">_add_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">):</span>
        <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">cvalue</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>

        <span class="n">_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_text</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_label_props</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">_text</span><span class="p">,</span> <span class="n">color</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cvalue</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelXYs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="c1"># Add label to plot here - useful for manual mode label selection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add contour label using :class:`~matplotlib.text.Text` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_label_text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_label</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_label_clabeltext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add contour label using :class:`ClabelText` class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># x, y, rotation is given in pixel coordinate. Convert them to</span>
        <span class="c1"># the data coordinate and create a label using ClabelText</span>
        <span class="c1"># class. This way, the roation of the clabel is along the</span>
        <span class="c1"># contour line always.</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_label_clabeltext</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_label</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">add_label_near</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                       <span class="n">transform</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a label near the point (x, y). If transform is None</span>
<span class="sd">        (default), (x, y) is in data coordinates; if transform is</span>
<span class="sd">        False, (x, y) is in display coordinates; otherwise, the</span>
<span class="sd">        specified transform will be used to translate (x, y) into</span>
<span class="sd">        display coordinates.</span>

<span class="sd">        *inline*:</span>
<span class="sd">          controls whether the underlying contour is removed or</span>
<span class="sd">          not. Default is *True*.</span>

<span class="sd">        *inline_spacing*:</span>
<span class="sd">          space in pixels to leave on each side of label when</span>
<span class="sd">          placing inline.  Defaults to 5.  This spacing will be</span>
<span class="sd">          exact for labels at locations where the contour is</span>
<span class="sd">          straight, less so for labels on curved contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span>

        <span class="k">if</span> <span class="n">transform</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform_point</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="c1"># find the nearest contour _in screen units_</span>
        <span class="n">conmin</span><span class="p">,</span> <span class="n">segmin</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nearest_contour</span><span class="p">(</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="p">)[:</span><span class="mi">5</span><span class="p">]</span>

        <span class="c1"># The calc_label_rot_and_inline routine requires that (xmin,ymin)</span>
        <span class="c1"># be a vertex in the path. So, if it isn&#39;t, add a vertex here</span>

        <span class="c1"># grab the paths from the collections</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">conmin</span><span class="p">]</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>
        <span class="c1"># grab the correct segment</span>
        <span class="n">active_path</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">segmin</span><span class="p">]</span>
        <span class="c1"># grab it&#39;s verticies</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">active_path</span><span class="o">.</span><span class="n">vertices</span>
        <span class="c1"># sort out where the new vertex should be added data-units</span>
        <span class="n">xcmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span><span class="o">.</span><span class="n">transform_point</span><span class="p">([</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">])</span>
        <span class="c1"># if there isn&#39;t a vertex close enough</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xcmin</span><span class="p">,</span> <span class="n">lc</span><span class="p">[</span><span class="n">imin</span><span class="p">]):</span>
            <span class="c1"># insert new data into the vertex list</span>
            <span class="n">lc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">lc</span><span class="p">[:</span><span class="n">imin</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xcmin</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">lc</span><span class="p">[</span><span class="n">imin</span><span class="p">:]]</span>
            <span class="c1"># replace the path with the new one</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">segmin</span><span class="p">]</span> <span class="o">=</span> <span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="c1"># Get index of nearest level in subset of levels used for labeling</span>
        <span class="n">lmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">conmin</span><span class="p">)</span>

        <span class="c1"># Coordinates of contour</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">conmin</span><span class="p">]</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>
        <span class="n">lc</span> <span class="o">=</span> <span class="n">paths</span><span class="p">[</span><span class="n">segmin</span><span class="p">]</span><span class="o">.</span><span class="n">vertices</span>

        <span class="c1"># In pixel/screen space</span>
        <span class="n">slc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

        <span class="c1"># Get label width for rotating labels and breaking contours</span>
        <span class="n">lw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_width</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">[</span><span class="n">lmin</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFontSizeList</span><span class="p">[</span><span class="n">lmin</span><span class="p">])</span>

        <span class="c1"># Figure out label rotation.</span>
        <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
            <span class="n">lcarg</span> <span class="o">=</span> <span class="n">lc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lcarg</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">rotation</span><span class="p">,</span> <span class="n">nlc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_label_rot_and_inline</span><span class="p">(</span>
            <span class="n">slc</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">lcarg</span><span class="p">,</span>
            <span class="n">inline_spacing</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span><span class="p">(</span><span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">[</span><span class="n">lmin</span><span class="p">],</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span><span class="p">[</span><span class="n">lmin</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
            <span class="c1"># Remove old, not looping over paths so we can do this up front</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">segmin</span><span class="p">)</span>

            <span class="c1"># Add paths if not empty or single point</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nlc</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">pop_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Defaults to removing last label, but any index can be supplied&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">t</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inline</span><span class="p">,</span> <span class="n">inline_spacing</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_use_clabeltext</span><span class="p">:</span>
            <span class="n">add_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_label_clabeltext</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">add_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_label</span>

        <span class="k">for</span> <span class="n">icon</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">fsize</span><span class="p">,</span> <span class="n">cvalue</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labelIndiceList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelLevelList</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">labelFontSizeList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelCValueList</span><span class="p">):</span>

            <span class="n">con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">icon</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
            <span class="n">lw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_label_width</span><span class="p">(</span><span class="n">lev</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelFmt</span><span class="p">,</span> <span class="n">fsize</span><span class="p">)</span>
            <span class="n">lw</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">figure</span><span class="o">.</span><span class="n">dpi</span> <span class="o">/</span> <span class="mf">72.0</span>  <span class="c1"># scale to screen coordinates</span>
            <span class="n">additions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">segNum</span><span class="p">,</span> <span class="n">linepath</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">linepath</span><span class="o">.</span><span class="n">vertices</span>  <span class="c1"># Line contour</span>
                <span class="n">slc0</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>  <span class="c1"># Line contour in screen coords</span>

                <span class="c1"># For closed polygons, add extra point to avoid division by</span>
                <span class="c1"># zero in print_label and locate_label.  Other than these</span>
                <span class="c1"># functions, this is not necessary and should probably be</span>
                <span class="c1"># eventually removed.</span>
                <span class="k">if</span> <span class="n">mlab</span><span class="o">.</span><span class="n">is_closed_polygon</span><span class="p">(</span><span class="n">lc</span><span class="p">):</span>
                    <span class="n">slc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">slc0</span><span class="p">,</span> <span class="n">slc0</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slc</span> <span class="o">=</span> <span class="n">slc0</span>

                <span class="c1"># Check if long enough for a label</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_label</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">lw</span><span class="p">):</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ind</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locate_label</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">lw</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
                        <span class="n">lcarg</span> <span class="o">=</span> <span class="n">lc</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lcarg</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">rotation</span><span class="p">,</span> <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_label_rot_and_inline</span><span class="p">(</span>
                        <span class="n">slc0</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">lw</span><span class="p">,</span> <span class="n">lcarg</span><span class="p">,</span>
                        <span class="n">inline_spacing</span><span class="p">)</span>

                    <span class="c1"># Actually add the label</span>
                    <span class="n">add_label</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">lev</span><span class="p">,</span> <span class="n">cvalue</span><span class="p">)</span>

                    <span class="c1"># If inline, add new contours</span>
                    <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new</span><span class="p">:</span>
                            <span class="c1"># Add path if not empty or single point</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                                <span class="n">additions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># If not adding label, keep old path</span>
                    <span class="n">additions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">linepath</span><span class="p">)</span>

            <span class="c1"># After looping over all segments on a contour, remove old</span>
            <span class="c1"># paths and add new ones if inlining</span>
            <span class="k">if</span> <span class="n">inline</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">paths</span><span class="p">[:]</span>
                <span class="n">paths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">additions</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_find_closest_point_on_leg</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;find closest point to p0 on line segment connecting p1 and p2&quot;&quot;&quot;</span>

    <span class="c1"># handle degenerate case</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">p2</span> <span class="o">==</span> <span class="n">p1</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">p0</span> <span class="o">-</span> <span class="n">p1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">p1</span>

    <span class="n">d21</span> <span class="o">=</span> <span class="n">p2</span> <span class="o">-</span> <span class="n">p1</span>
    <span class="n">d01</span> <span class="o">=</span> <span class="n">p0</span> <span class="o">-</span> <span class="n">p1</span>

    <span class="c1"># project on to line segment to find closest point</span>
    <span class="n">proj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d01</span><span class="p">,</span> <span class="n">d21</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d21</span><span class="p">,</span> <span class="n">d21</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">proj</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">proj</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">proj</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">proj</span> <span class="o">*</span> <span class="n">d21</span>

    <span class="c1"># find squared distance</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">pc</span><span class="o">-</span><span class="n">p0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">pc</span>


<span class="k">def</span> <span class="nf">_find_closest_point_on_path</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    lc: coordinates of vertices</span>
<span class="sd">    point: coordinates of test point</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># find index of closest vertex for this segment</span>
    <span class="n">ds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">lc</span> <span class="o">-</span> <span class="n">point</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span>

    <span class="n">dmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">xcmin</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">legmin</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="n">closed</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">is_closed_polygon</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

    <span class="c1"># build list of legs before and after this vertex</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">imin</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">closed</span><span class="p">:</span>
        <span class="n">legs</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">imin</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">),</span> <span class="n">imin</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">imin</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">closed</span><span class="p">:</span>
        <span class="n">legs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">imin</span><span class="p">,</span> <span class="p">(</span><span class="n">imin</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">lc</span><span class="p">)))</span>

    <span class="k">for</span> <span class="n">leg</span> <span class="ow">in</span> <span class="n">legs</span><span class="p">:</span>
        <span class="n">d</span><span class="p">,</span> <span class="n">xc</span> <span class="o">=</span> <span class="n">_find_closest_point_on_leg</span><span class="p">(</span><span class="n">lc</span><span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">lc</span><span class="p">[</span><span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">point</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dmin</span><span class="p">:</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="n">d</span>
            <span class="n">xcmin</span> <span class="o">=</span> <span class="n">xc</span>
            <span class="n">legmin</span> <span class="o">=</span> <span class="n">leg</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">dmin</span><span class="p">,</span> <span class="n">xcmin</span><span class="p">,</span> <span class="n">legmin</span><span class="p">)</span>


<div class="viewcode-block" id="ContourSet"><a class="viewcode-back" href="../../generated/generated/matplotlib.tri.ContourSet.html#matplotlib.tri.ContourSet">[docs]</a><span class="k">class</span> <span class="nc">ContourSet</span><span class="p">(</span><span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">,</span> <span class="n">ContourLabeler</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Store a set of contour lines or filled regions.</span>

<span class="sd">    User-callable method: clabel</span>

<span class="sd">    Useful attributes:</span>
<span class="sd">      ax:</span>
<span class="sd">        The axes object in which the contours are drawn</span>

<span class="sd">      collections:</span>
<span class="sd">        a silent_list of LineCollections or PolyCollections</span>

<span class="sd">      levels:</span>
<span class="sd">        contour levels</span>

<span class="sd">      layers:</span>
<span class="sd">        same as levels for line contours; half-way between</span>
<span class="sd">        levels for filled contours.  See :meth:`_process_colors`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ContourSet.__init__"><a class="viewcode-back" href="../../generated/generated/matplotlib.tri.ContourSet.__init__.html#matplotlib.tri.ContourSet.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw contour lines or filled regions, depending on</span>
<span class="sd">        whether keyword arg &#39;filled&#39; is *False* (default) or *True*.</span>

<span class="sd">        The first three arguments must be:</span>

<span class="sd">          *ax*: axes object.</span>

<span class="sd">          *levels*: [level0, level1, ..., leveln]</span>
<span class="sd">            A list of floating point numbers indicating the contour</span>
<span class="sd">            levels.</span>

<span class="sd">          *allsegs*: [level0segs, level1segs, ...]</span>
<span class="sd">            List of all the polygon segments for all the *levels*.</span>
<span class="sd">            For contour lines ``len(allsegs) == len(levels)``, and for</span>
<span class="sd">            filled contour regions ``len(allsegs) = len(levels)-1``.</span>

<span class="sd">            level0segs = [polygon0, polygon1, ...]</span>

<span class="sd">            polygon0 = array_like [[x0,y0], [x1,y1], ...]</span>

<span class="sd">          *allkinds*: *None* or [level0kinds, level1kinds, ...]</span>
<span class="sd">            Optional list of all the polygon vertex kinds (code types), as</span>
<span class="sd">            described and used in Path.   This is used to allow multiply-</span>
<span class="sd">            connected paths such as holes within filled polygons.</span>
<span class="sd">            If not *None*, len(allkinds) == len(allsegs).</span>

<span class="sd">            level0kinds = [polygon0kinds, ...]</span>

<span class="sd">            polygon0kinds = [vertexcode0, vertexcode1, ...]</span>

<span class="sd">            If *allkinds* is not *None*, usually all polygons for a particular</span>
<span class="sd">            contour level are grouped together so that</span>

<span class="sd">            level0segs = [polygon0] and level0kinds = [polygon0kinds].</span>

<span class="sd">        Keyword arguments are as described in</span>
<span class="sd">        :class:`~matplotlib.contour.QuadContourSet` object.</span>

<span class="sd">        **Examples:**</span>

<span class="sd">        .. plot:: mpl_examples/misc/contour_manual.py</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;levels&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;filled&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linewidths</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;linewidths&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linestyles</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;linestyles&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">hatches</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;hatches&#39;</span><span class="p">,</span> <span class="p">[</span><span class="kc">None</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;extent&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">cmap</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cmap&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;colors&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;vmin&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;vmax&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;extend&#39;</span><span class="p">,</span> <span class="s1">&#39;neither&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;antialiased&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># eliminate artifacts; we are not</span>
                                      <span class="c1"># stroking the boundaries.</span>
            <span class="c1"># The default for line contours will be taken from</span>
            <span class="c1"># the LineCollection default, which uses the</span>
            <span class="c1"># rcParams[&#39;lines.antialiased&#39;]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nchunk</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nchunk&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;locator&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">norm</span><span class="p">,</span> <span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">)</span>
                <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">locator</span><span class="p">,</span> <span class="n">ticker</span><span class="o">.</span><span class="n">LogLocator</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">LogNorm</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="s1">&#39;neither&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;extend kwarg does not work yet with log &#39;</span>
                                 <span class="s1">&#39; scale&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;lower&#39;</span><span class="p">,</span> <span class="s1">&#39;upper&#39;</span><span class="p">,</span> <span class="s1">&#39;image&#39;</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If given, *origin* must be one of [ &#39;lower&#39; |&quot;</span>
                             <span class="s2">&quot; &#39;upper&#39; | &#39;image&#39;]&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">extent</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If given, *extent* must be &#39;[ *None* |&quot;</span>
                             <span class="s2">&quot; (x0,x1,y0,y1) ]&#39;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Either colors or cmap must be None&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;image&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;image.origin&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;transform&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_process_args</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_levels</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ncolors</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
                <span class="n">ncolors</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Handle the case where colors are given for the extended</span>
            <span class="c1"># parts of the contour.</span>
            <span class="n">extend_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">]</span>
            <span class="n">extend_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">]</span>
            <span class="n">use_set_under_over</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># if we are extending the lower end, and we&#39;ve been given enough</span>
            <span class="c1"># colors then skip the first color in the resulting cmap. For the</span>
            <span class="c1"># extend_max case we don&#39;t need to worry about passing more colors</span>
            <span class="c1"># than ncolors as ListedColormap will clip.</span>
            <span class="n">total_levels</span> <span class="o">=</span> <span class="n">ncolors</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">extend_min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">extend_max</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">)</span> <span class="o">==</span> <span class="n">total_levels</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">([</span><span class="n">extend_min</span><span class="p">,</span> <span class="n">extend_max</span><span class="p">])):</span>
                <span class="n">use_set_under_over</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">extend_min</span><span class="p">:</span>
                    <span class="n">i0</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">cmap</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">ListedColormap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="n">i0</span><span class="p">:</span><span class="kc">None</span><span class="p">],</span> <span class="n">N</span><span class="o">=</span><span class="n">ncolors</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_set_under_over</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">extend_min</span><span class="p">:</span>
                    <span class="n">cmap</span><span class="o">.</span><span class="n">set_under</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">extend_max</span><span class="p">:</span>
                    <span class="n">cmap</span><span class="o">.</span><span class="n">set_over</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">colors</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">&#39;mcoll.PathCollection&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">=</span> <span class="n">cbook</span><span class="o">.</span><span class="n">silent_list</span><span class="p">(</span><span class="s1">&#39;mcoll.LineCollection&#39;</span><span class="p">)</span>
        <span class="c1"># label lists must be initialized here</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cmap&#39;</span><span class="p">:</span> <span class="n">cmap</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;norm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span>
        <span class="c1"># sets self.cmap, norm if needed;</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vmin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmin</span> <span class="o">=</span> <span class="n">vmin</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_process_colors</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_allsegs_and_allkinds</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">linewidths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;linewidths is ignored by contourf&#39;</span><span class="p">)</span>

            <span class="c1"># Lower and upper contour levels.</span>
            <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowers_and_uppers</span><span class="p">()</span>

            <span class="c1"># Ensure allkinds can be zipped below.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span> <span class="ow">in</span> \
                    <span class="nb">zip</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span><span class="p">):</span>
                <span class="n">paths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_paths</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span><span class="p">)</span>
                <span class="c1"># Default zorder taken from Collection</span>
                <span class="n">zorder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">PathCollection</span><span class="p">(</span>
                    <span class="n">paths</span><span class="p">,</span>
                    <span class="n">antialiaseds</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span><span class="p">,),</span>
                    <span class="n">edgecolors</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">(),</span>
                    <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tlinewidths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_linewidths</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tlinewidths</span> <span class="o">=</span> <span class="n">tlinewidths</span>
            <span class="n">tlinestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_process_linestyles</span><span class="p">()</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span>
            <span class="k">if</span> <span class="n">aa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">aa</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">antialiased</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">lstyle</span><span class="p">,</span> <span class="n">segs</span> <span class="ow">in</span> \
                    <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">,</span> <span class="n">tlinewidths</span><span class="p">,</span> <span class="n">tlinestyles</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">):</span>
                <span class="c1"># Default zorder taken from LineCollection</span>
                <span class="n">zorder</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;zorder&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span>
                    <span class="n">segs</span><span class="p">,</span>
                    <span class="n">antialiaseds</span><span class="o">=</span><span class="n">aa</span><span class="p">,</span>
                    <span class="n">linewidths</span><span class="o">=</span><span class="n">width</span><span class="p">,</span>
                    <span class="n">linestyles</span><span class="o">=</span><span class="p">[</span><span class="n">lstyle</span><span class="p">],</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                    <span class="n">transform</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">(),</span>
                    <span class="n">zorder</span><span class="o">=</span><span class="n">zorder</span><span class="p">)</span>
                <span class="n">col</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="s1">&#39;_nolegend_&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">autolim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span>  <span class="c1"># set the colors</span></div>

<div class="viewcode-block" id="ContourSet.get_transform"><a class="viewcode-back" href="../../generated/generated/matplotlib.tri.ContourSet.get_transform.html#matplotlib.tri.ContourSet.get_transform">[docs]</a>    <span class="k">def</span> <span class="nf">get_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the :class:`~matplotlib.transforms.Transform`</span>
<span class="sd">        instance used by this ContourSet.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="n">mtrans</span><span class="o">.</span><span class="n">Transform</span><span class="p">)</span>
              <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">,</span> <span class="s1">&#39;_as_mpl_transform&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">_as_mpl_transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span></div>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># the C object _contour_generator cannot currently be pickled. This</span>
        <span class="c1"># isn&#39;t a big issue as it is not actually used once the contour has</span>
        <span class="c1"># been calculated.</span>
        <span class="n">state</span><span class="p">[</span><span class="s1">&#39;_contour_generator&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">state</span>

<div class="viewcode-block" id="ContourSet.legend_elements"><a class="viewcode-back" href="../../generated/generated/matplotlib.tri.ContourSet.legend_elements.html#matplotlib.tri.ContourSet.legend_elements">[docs]</a>    <span class="k">def</span> <span class="nf">legend_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variable_name</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">str_format</span><span class="o">=</span><span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of artist and labels suitable for passing through</span>
<span class="sd">        to :func:`plt.legend` which represent this ContourSet.</span>

<span class="sd">        Args:</span>

<span class="sd">            *variable_name*: the string used inside the inequality used</span>
<span class="sd">              on the labels</span>

<span class="sd">            *str_format*: function used to format the numbers in the labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">artists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowers_and_uppers</span><span class="p">()</span>
            <span class="n">n_levels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">collection</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">upper</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">,</span> <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">)):</span>
                <span class="n">patch</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="n">facecolor</span><span class="o">=</span><span class="n">collection</span><span class="o">.</span><span class="n">get_facecolor</span><span class="p">()[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">hatch</span><span class="o">=</span><span class="n">collection</span><span class="o">.</span><span class="n">get_hatch</span><span class="p">(),</span>
                    <span class="n">alpha</span><span class="o">=</span><span class="n">collection</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">())</span>
                <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>

                <span class="n">lower</span> <span class="o">=</span> <span class="n">str_format</span><span class="p">(</span><span class="n">lower</span><span class="p">)</span>
                <span class="n">upper</span> <span class="o">=</span> <span class="n">str_format</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">r&#39;$</span><span class="si">%s</span><span class="s1"> \leq </span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable_name</span><span class="p">,</span>
                                                     <span class="n">lower</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">i</span> <span class="o">==</span> <span class="n">n_levels</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;both&#39;</span><span class="p">):</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">r&#39;$</span><span class="si">%s</span><span class="s1"> &gt; </span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable_name</span><span class="p">,</span>
                                                  <span class="n">upper</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">r&#39;$</span><span class="si">%s</span><span class="s1"> &lt; </span><span class="si">%s</span><span class="s1"> \leq </span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">lower</span><span class="p">,</span>
                                                          <span class="n">variable_name</span><span class="p">,</span>
                                                          <span class="n">upper</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">collection</span><span class="p">,</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>

                <span class="n">patch</span> <span class="o">=</span> <span class="n">mcoll</span><span class="o">.</span><span class="n">LineCollection</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="n">patch</span><span class="o">.</span><span class="n">update_from</span><span class="p">(</span><span class="n">collection</span><span class="p">)</span>

                <span class="n">artists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">patch</span><span class="p">)</span>
                <span class="c1"># format the level for insertion into the labels</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">str_format</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">r&#39;$</span><span class="si">%s</span><span class="s1"> = </span><span class="si">%s</span><span class="s1">$&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">variable_name</span><span class="p">,</span> <span class="n">level</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">artists</span><span class="p">,</span> <span class="n">labels</span></div>

    <span class="k">def</span> <span class="nf">_process_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process *args* and *kwargs*; override in derived classes.</span>

<span class="sd">        Must set self.levels, self.zmin and self.zmax, and update axes</span>
<span class="sd">        limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Check lengths of levels and allsegs.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must be one less number of segments as &#39;</span>
                                 <span class="s1">&#39;levels&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;must be same number of segments as levels&#39;</span><span class="p">)</span>

        <span class="c1"># Check length of allkinds.</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;allkinds has different length to allsegs&#39;</span><span class="p">)</span>

        <span class="c1"># Determine x,y bounds and update axes data limits.</span>
        <span class="n">havelimits</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">segs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">:</span>
                <span class="n">seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">havelimits</span><span class="p">:</span>
                    <span class="nb">min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                    <span class="nb">max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="nb">max</span><span class="p">,</span> <span class="n">seg</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">min</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="nb">max</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">havelimits</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">havelimits</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">([</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_allsegs_and_allkinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Override in derived classes to create and return allsegs and allkinds.</span>
<span class="sd">        allkinds can be None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">allsegs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">allkinds</span>

    <span class="k">def</span> <span class="nf">_get_lowers_and_uppers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return (lowers,uppers) for filled contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lowers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">==</span> <span class="n">lowers</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="c1"># Include minimum values in lowest interval</span>
            <span class="n">lowers</span> <span class="o">=</span> <span class="n">lowers</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>  <span class="c1"># so we don&#39;t change self._levels</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span><span class="p">:</span>
                <span class="n">lowers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.99</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lowers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_make_paths</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kinds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">codes</span><span class="o">=</span><span class="n">kind</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">seg</span><span class="p">,</span> <span class="n">kind</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">segs</span><span class="p">,</span> <span class="n">kinds</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">mpath</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span> <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">segs</span><span class="p">]</span>

<div class="viewcode-block" id="ContourSet.changed"><a class="viewcode-back" href="../../generated/generated/matplotlib.tri.ContourSet.changed.html#matplotlib.tri.ContourSet.changed">[docs]</a>    <span class="k">def</span> <span class="nf">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">tcolors</span> <span class="o">=</span> <span class="p">[(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">rgba</span><span class="p">),)</span>
                   <span class="k">for</span> <span class="n">rgba</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tcolors</span> <span class="o">=</span> <span class="n">tcolors</span>
        <span class="n">hatches</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hatches</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">tcolors</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">color</span><span class="p">,</span> <span class="n">hatch</span><span class="p">,</span> <span class="n">collection</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tcolors</span><span class="p">,</span> <span class="n">hatches</span><span class="p">,</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
                <span class="c1"># update the collection&#39;s hatch (may be None)</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_hatch</span><span class="p">(</span><span class="n">hatch</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">collection</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">cv</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelTexts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">labelCValues</span><span class="p">):</span>
            <span class="n">label</span><span class="o">.</span><span class="n">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
            <span class="n">label</span><span class="o">.</span><span class="n">set_color</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">labelMappable</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">cv</span><span class="p">))</span>
        <span class="c1"># add label colors</span>
        <span class="n">cm</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="o">.</span><span class="n">changed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_autolev</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select contour levels to span the data.</span>

<span class="sd">        We need two more levels for filled contours than for</span>
<span class="sd">        line contours, because for the latter we need to specify</span>
<span class="sd">        the lower and upper boundary of each range. For example,</span>
<span class="sd">        a single contour boundary, say at z = 0, requires only</span>
<span class="sd">        one contour line, but two filled regions, and therefore</span>
<span class="sd">        three levels to provide boundaries for both regions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">LogLocator</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">locator</span> <span class="o">=</span> <span class="n">ticker</span><span class="o">.</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">zmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span>
        <span class="n">zmin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span>
        <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locator</span><span class="o">.</span><span class="n">tick_values</span><span class="p">(</span><span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">lev</span>
        <span class="c1"># For line contours, drop levels outside the data range.</span>
        <span class="k">return</span> <span class="n">lev</span><span class="p">[(</span><span class="n">lev</span> <span class="o">&gt;</span> <span class="n">zmin</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">lev</span> <span class="o">&lt;</span> <span class="n">zmax</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_contour_level_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the contour levels and store in self.levels.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">&#39;contourf&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">&#39;contour&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_auto</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autolev</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">level_arg</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">level_arg</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
                        <span class="n">lev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_autolev</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">level_arg</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">lev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">level_arg</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Last </span><span class="si">%s</span><span class="s2"> arg must give levels; see help(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">lev</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Filled contours require at least 2 levels.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_corner_mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">==</span> <span class="s1">&#39;legacy&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Contour levels are not increasing&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Contour levels must be increasing&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_levels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assign values to :attr:`layers` based on :attr:`levels`,</span>
<span class="sd">        adding extended layers as needed if contours are filled.</span>

<span class="sd">        For line contours, layers simply coincide with levels;</span>
<span class="sd">        a line is a thin layer.  No extended levels are needed</span>
<span class="sd">        with line contours.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The following attributes are no longer needed, and</span>
        <span class="c1"># should be deprecated and removed to reduce confusion.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>

        <span class="c1"># Make a private _levels to include extended regions; we</span>
        <span class="c1"># want to leave the original levels attribute unchanged.</span>
        <span class="c1"># (Colorbar needs this even for line contours.)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span>
            <span class="k">return</span>

        <span class="c1"># layer values are mid-way between levels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_levels</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="c1"># ...except that extended layers must be outside the</span>
        <span class="c1"># normed range:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

    <span class="k">def</span> <span class="nf">_process_colors</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Color argument processing for contouring.</span>

<span class="sd">        Note that we base the color mapping on the contour levels</span>
<span class="sd">        and layers, not on the actual range of the Z values.  This</span>
<span class="sd">        means we don&#39;t have to worry about bad values in Z, and we</span>
<span class="sd">        always have the full dynamic range available for the selected</span>
<span class="sd">        levels.</span>

<span class="sd">        The color is based on the midpoint of the layer, except for</span>
<span class="sd">        extended end layers.  By default, the norm vmin and vmax</span>
<span class="sd">        are the extreme values of the non-extended levels.  Hence,</span>
<span class="sd">        the layer color extremes are not the extreme values of</span>
<span class="sd">        the colormap itself, but approach those values as the number</span>
<span class="sd">        of levels increases.  An advantage of this scheme is that</span>
<span class="sd">        line contours, when added to filled contours, take on</span>
<span class="sd">        colors that are consistent with those of the filled regions;</span>
<span class="sd">        for example, a contour line on the boundary between two</span>
<span class="sd">        regions will have a color intermediate between those</span>
<span class="sd">        of the regions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">monochrome</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmap</span><span class="o">.</span><span class="n">monochrome</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">colors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Generate integers for direct indexing.</span>
            <span class="n">i0</span><span class="p">,</span> <span class="n">i1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
                <span class="n">i1</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># Out of range indices for over and under:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">):</span>
                <span class="n">i0</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">):</span>
                <span class="n">i1</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i0</span><span class="p">,</span> <span class="n">i1</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_norm</span><span class="p">(</span><span class="n">colors</span><span class="o">.</span><span class="n">NoNorm</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cvalues</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">layers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoscale_None</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extend</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">clip</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># self.tcolors are set by the &quot;changed&quot; method</span>

    <span class="k">def</span> <span class="nf">_process_linewidths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">linewidths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linewidths</span>
        <span class="n">Nlev</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linewidths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tlinewidths</span> <span class="o">=</span> <span class="p">[(</span><span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;lines.linewidth&#39;</span><span class="p">],)]</span> <span class="o">*</span> <span class="n">Nlev</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linewidths</span><span class="p">):</span>
                <span class="n">linewidths</span> <span class="o">=</span> <span class="p">[</span><span class="n">linewidths</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nlev</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">linewidths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">nreps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nlev</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)))</span>
                    <span class="n">linewidths</span> <span class="o">=</span> <span class="n">linewidths</span> <span class="o">*</span> <span class="n">nreps</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">linewidths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">linewidths</span> <span class="o">=</span> <span class="n">linewidths</span><span class="p">[:</span><span class="n">Nlev</span><span class="p">]</span>
            <span class="n">tlinewidths</span> <span class="o">=</span> <span class="p">[(</span><span class="n">w</span><span class="p">,)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">linewidths</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">tlinewidths</span>

    <span class="k">def</span> <span class="nf">_process_linestyles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">linestyles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">linestyles</span>
        <span class="n">Nlev</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linestyles</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tlinestyles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;solid&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nlev</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">monochrome</span><span class="p">:</span>
                <span class="n">neg_ls</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;contour.negative_linestyle&#39;</span><span class="p">]</span>
                <span class="n">eps</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">15</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lev</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">lev</span> <span class="o">&lt;</span> <span class="n">eps</span><span class="p">:</span>
                        <span class="n">tlinestyles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">neg_ls</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cbook</span><span class="o">.</span><span class="n">is_string_like</span><span class="p">(</span><span class="n">linestyles</span><span class="p">):</span>
                <span class="n">tlinestyles</span> <span class="o">=</span> <span class="p">[</span><span class="n">linestyles</span><span class="p">]</span> <span class="o">*</span> <span class="n">Nlev</span>
            <span class="k">elif</span> <span class="n">cbook</span><span class="o">.</span><span class="n">iterable</span><span class="p">(</span><span class="n">linestyles</span><span class="p">):</span>
                <span class="n">tlinestyles</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlinestyles</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">nreps</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Nlev</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">linestyles</span><span class="p">)))</span>
                    <span class="n">tlinestyles</span> <span class="o">=</span> <span class="n">tlinestyles</span> <span class="o">*</span> <span class="n">nreps</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tlinestyles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Nlev</span><span class="p">:</span>
                    <span class="n">tlinestyles</span> <span class="o">=</span> <span class="n">tlinestyles</span><span class="p">[:</span><span class="n">Nlev</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized type for linestyles kwarg&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tlinestyles</span>

<div class="viewcode-block" id="ContourSet.get_alpha"><a class="viewcode-back" href="../../generated/generated/matplotlib.tri.ContourSet.get_alpha.html#matplotlib.tri.ContourSet.get_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">get_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns alpha to be applied to all ContourSet artists&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span></div>

<div class="viewcode-block" id="ContourSet.set_alpha"><a class="viewcode-back" href="../../generated/generated/matplotlib.tri.ContourSet.set_alpha.html#matplotlib.tri.ContourSet.set_alpha">[docs]</a>    <span class="k">def</span> <span class="nf">set_alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;sets alpha for all ContourSet artists&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span> <span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">()</span></div>

<div class="viewcode-block" id="ContourSet.find_nearest_contour"><a class="viewcode-back" href="../../generated/generated/matplotlib.tri.ContourSet.find_nearest_contour.html#matplotlib.tri.ContourSet.find_nearest_contour">[docs]</a>    <span class="k">def</span> <span class="nf">find_nearest_contour</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pixel</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds contour that is closest to a point.  Defaults to</span>
<span class="sd">        measuring distance in pixels (screen space - useful for manual</span>
<span class="sd">        contour labeling), but this can be controlled via a keyword</span>
<span class="sd">        argument.</span>

<span class="sd">        Returns a tuple containing the contour, segment, index of</span>
<span class="sd">        segment, x &amp; y of segment point and distance to minimum point.</span>

<span class="sd">        Call signature::</span>

<span class="sd">          conmin,segmin,imin,xmin,ymin,dmin = find_nearest_contour(</span>
<span class="sd">                     self, x, y, indices=None, pixel=True )</span>

<span class="sd">        Optional keyword arguments:</span>

<span class="sd">          *indices*:</span>
<span class="sd">            Indexes of contour levels to consider when looking for</span>
<span class="sd">            nearest point.  Defaults to using all levels.</span>

<span class="sd">          *pixel*:</span>
<span class="sd">            If *True*, measure distance in pixel space, if not, measure</span>
<span class="sd">            distance in axes space.  Defaults to *True*.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># This function uses a method that is probably quite</span>
        <span class="c1"># inefficient based on converting each contour segment to</span>
        <span class="c1"># pixel coordinates and then comparing the given point to</span>
        <span class="c1"># those coordinates for each contour.  This will probably be</span>
        <span class="c1"># quite slow for complex contours, but for normal use it works</span>
        <span class="c1"># sufficiently well that the time is not noticeable.</span>
        <span class="c1"># Nonetheless, improvements could probably be made.</span>

        <span class="k">if</span> <span class="n">indices</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">)))</span>

        <span class="n">dmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">conmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">segmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ymin</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">point</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">icon</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
            <span class="n">con</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">icon</span><span class="p">]</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="n">get_paths</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">segNum</span><span class="p">,</span> <span class="n">linepath</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
                <span class="n">lc</span> <span class="o">=</span> <span class="n">linepath</span><span class="o">.</span><span class="n">vertices</span>
                <span class="c1"># transfer all data points to screen coordinates if desired</span>
                <span class="k">if</span> <span class="n">pixel</span><span class="p">:</span>
                    <span class="n">lc</span> <span class="o">=</span> <span class="n">trans</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>

                <span class="n">d</span><span class="p">,</span> <span class="n">xc</span><span class="p">,</span> <span class="n">leg</span> <span class="o">=</span> <span class="n">_find_closest_point_on_path</span><span class="p">(</span><span class="n">lc</span><span class="p">,</span> <span class="n">point</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">dmin</span><span class="p">:</span>
                    <span class="n">dmin</span> <span class="o">=</span> <span class="n">d</span>
                    <span class="n">conmin</span> <span class="o">=</span> <span class="n">icon</span>
                    <span class="n">segmin</span> <span class="o">=</span> <span class="n">segNum</span>
                    <span class="n">imin</span> <span class="o">=</span> <span class="n">leg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">xmin</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">ymin</span> <span class="o">=</span> <span class="n">xc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">conmin</span><span class="p">,</span> <span class="n">segmin</span><span class="p">,</span> <span class="n">imin</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">dmin</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">QuadContourSet</span><span class="p">(</span><span class="n">ContourSet</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create and store a set of contour lines or filled regions.</span>

<span class="sd">    User-callable method: :meth:`clabel`</span>

<span class="sd">    Useful attributes:</span>
<span class="sd">      ax:</span>
<span class="sd">        The axes object in which the contours are drawn</span>

<span class="sd">      collections:</span>
<span class="sd">        A silent_list of LineCollections or PolyCollections</span>

<span class="sd">      levels:</span>
<span class="sd">        Contour levels</span>

<span class="sd">      layers:</span>
<span class="sd">        Same as levels for line contours; half-way between</span>
<span class="sd">        levels for filled contours.  See :meth:`_process_colors` method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate and draw contour lines or filled regions, depending</span>
<span class="sd">        on whether keyword arg &#39;filled&#39; is False (default) or True.</span>

<span class="sd">        The first argument of the initializer must be an axes</span>
<span class="sd">        object.  The remaining arguments and keyword arguments</span>
<span class="sd">        are described in QuadContourSet.contour_doc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ContourSet</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ax</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_process_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Process args and kwargs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">QuadContourSet</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">levels</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">zmin</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">zmax</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_corner_mask</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">==</span> <span class="s1">&#39;legacy&#39;</span><span class="p">:</span>
                <span class="n">contour_generator</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Cntr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">contour_generator</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_contour_generator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;corner_mask&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">=</span> <span class="n">mpl</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;contour.corner_mask&#39;</span><span class="p">]</span>

            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contour_args</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

            <span class="n">_mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">ma</span><span class="o">.</span><span class="n">nomask</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">==</span> <span class="s1">&#39;legacy&#39;</span><span class="p">:</span>
                <span class="n">cbook</span><span class="o">.</span><span class="n">warn_deprecated</span><span class="p">(</span><span class="s1">&#39;1.5&#39;</span><span class="p">,</span>
                                      <span class="n">name</span><span class="o">=</span><span class="s2">&quot;corner_mask=&#39;legacy&#39;&quot;</span><span class="p">,</span>
                                      <span class="n">alternative</span><span class="o">=</span><span class="s1">&#39;corner_mask=False or True&#39;</span><span class="p">)</span>
                <span class="n">contour_generator</span> <span class="o">=</span> <span class="n">_cntr</span><span class="o">.</span><span class="n">Cntr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">filled</span><span class="p">(),</span> <span class="n">_mask</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">contour_generator</span> <span class="o">=</span> <span class="n">_contour</span><span class="o">.</span><span class="n">QuadContourGenerator</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">filled</span><span class="p">(),</span> <span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nchunk</span><span class="p">)</span>

            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_transform</span><span class="p">()</span>

            <span class="c1"># if the transform is not trans data, and some part of it</span>
            <span class="c1"># contains transData, transform the xs and ys to data coordinates</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span> <span class="ow">and</span>
                    <span class="nb">any</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span><span class="p">))):</span>
                <span class="n">trans_to_data</span> <span class="o">=</span> <span class="n">t</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">transData</span>
                <span class="n">pts</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">flat</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">flat</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">transformed_pts</span> <span class="o">=</span> <span class="n">trans_to_data</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">transformed_pts</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="n">x0</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">update_datalim</span><span class="p">([(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">autoscale_view</span><span class="p">(</span><span class="n">tight</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">==</span> <span class="s1">&#39;legacy&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Cntr</span> <span class="o">=</span> <span class="n">contour_generator</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_contour_generator</span> <span class="o">=</span> <span class="n">contour_generator</span>

    <span class="k">def</span> <span class="nf">_get_allsegs_and_allkinds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and return allsegs and allkinds by calling underlying C code.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allsegs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_lowers_and_uppers</span><span class="p">()</span>
            <span class="n">allkinds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lowers</span><span class="p">,</span> <span class="n">uppers</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">==</span> <span class="s1">&#39;legacy&#39;</span><span class="p">:</span>
                    <span class="n">nlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cntr</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span><span class="p">,</span>
                                            <span class="n">nchunk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nchunk</span><span class="p">)</span>
                    <span class="n">nseg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nlist</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="n">nlist</span><span class="p">[:</span><span class="n">nseg</span><span class="p">]</span>
                    <span class="n">kinds</span> <span class="o">=</span> <span class="n">nlist</span><span class="p">[</span><span class="n">nseg</span><span class="p">:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vertices</span><span class="p">,</span> <span class="n">kinds</span> <span class="o">=</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">_contour_generator</span><span class="o">.</span><span class="n">create_filled_contour</span><span class="p">(</span>
                                                           <span class="n">level</span><span class="p">,</span> <span class="n">level_upper</span><span class="p">)</span>
                <span class="n">allsegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
                <span class="n">allkinds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kinds</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">allkinds</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_corner_mask</span> <span class="o">==</span> <span class="s1">&#39;legacy&#39;</span><span class="p">:</span>
                    <span class="n">nlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Cntr</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                    <span class="n">nseg</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">nlist</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="n">nlist</span><span class="p">[:</span><span class="n">nseg</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_contour_generator</span><span class="o">.</span><span class="n">create_contour</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                <span class="n">allsegs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">allsegs</span><span class="p">,</span> <span class="n">allkinds</span>

    <span class="k">def</span> <span class="nf">_contour_args</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">&#39;contourf&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn</span> <span class="o">=</span> <span class="s1">&#39;contour&#39;</span>
        <span class="n">Nargs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Nargs</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_initialize_x_y</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">Nargs</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_xyz</span><span class="p">(</span><span class="n">args</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Too many arguments to </span><span class="si">%s</span><span class="s2">; see help(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">fn</span><span class="p">))</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_invalid</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmax</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">logscale</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked_where</span><span class="p">(</span><span class="n">z</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Log scale: values of z &lt;= 0 have been masked&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zmin</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_contour_level_args</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_check_xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For functions like contour, check that the dimensions</span>
<span class="sd">        of the input arrays match; if x and y are 1D, convert</span>
<span class="sd">        them to 2D using meshgrid.</span>

<span class="sd">        Possible change: I think we should make and use an ArgumentError</span>
<span class="sd">        Exception class (here and elsewhere).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">_process_unit_info</span><span class="p">(</span><span class="n">xdata</span><span class="o">=</span><span class="n">x</span><span class="p">,</span> <span class="n">ydata</span><span class="o">=</span><span class="n">y</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">convert_xunits</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ax</span><span class="o">.</span><span class="n">convert_yunits</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input z must be a 2D array.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Number of dimensions of x and y should match.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>

            <span class="n">nx</span><span class="p">,</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">ny</span><span class="p">,</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span>

            <span class="k">if</span> <span class="n">nx</span> <span class="o">!=</span> <span class="n">Nx</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Length of x must be number of columns in z.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ny</span> <span class="o">!=</span> <span class="n">Ny</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Length of y must be number of rows in z.&quot;</span><span class="p">)</span>

            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Shape of x does not match that of z: found &quot;</span>
                                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> instead of </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Shape of y does not match that of z: found &quot;</span>
                                <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2"> instead of </span><span class="si">{1}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Inputs x and y must be 1D or 2D.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span>

    <span class="k">def</span> <span class="nf">_initialize_x_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return X, Y arrays such that contour(Z) will match imshow(Z)</span>
<span class="sd">        if origin is not None.</span>
<span class="sd">        The center of pixel Z[i,j] depends on origin:</span>
<span class="sd">        if origin is None, x = j, y = i;</span>
<span class="sd">        if origin is &#39;lower&#39;, x = j + 0.5, y = i + 0.5;</span>
<span class="sd">        if origin is &#39;upper&#39;, x = j + 0.5, y = Nrows - i - 0.5</span>
<span class="sd">        If extent is not None, x and y will be scaled to match,</span>
<span class="sd">        as in imshow.</span>
<span class="sd">        If origin is None and extent is not None, then extent</span>
<span class="sd">        will give the minimum and maximum values of x and y.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">z</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input must be a 2D array.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Ny</span><span class="p">,</span> <span class="n">Nx</span> <span class="o">=</span> <span class="n">z</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Not for image-matching.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Ny</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># Match image behavior:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">extent</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span> <span class="o">/</span> <span class="n">Nx</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span> <span class="o">/</span> <span class="n">Ny</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Nx</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dx</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y0</span> <span class="o">+</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">Ny</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">dy</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;upper&#39;</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

    <span class="n">contour_doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        Plot contours.</span>

<span class="s2">        :func:`~matplotlib.pyplot.contour` and</span>
<span class="s2">        :func:`~matplotlib.pyplot.contourf` draw contour lines and</span>
<span class="s2">        filled contours, respectively.  Except as noted, function</span>
<span class="s2">        signatures and return values are the same for both versions.</span>

<span class="s2">        :func:`~matplotlib.pyplot.contourf` differs from the MATLAB</span>
<span class="s2">        version in that it does not draw the polygon edges.</span>
<span class="s2">        To draw edges, add line contours with</span>
<span class="s2">        calls to :func:`~matplotlib.pyplot.contour`.</span>


<span class="s2">        Call signatures::</span>

<span class="s2">          contour(Z)</span>

<span class="s2">        make a contour plot of an array *Z*. The level values are chosen</span>
<span class="s2">        automatically.</span>

<span class="s2">        ::</span>

<span class="s2">          contour(X,Y,Z)</span>

<span class="s2">        *X*, *Y* specify the (x, y) coordinates of the surface</span>

<span class="s2">        ::</span>

<span class="s2">          contour(Z,N)</span>
<span class="s2">          contour(X,Y,Z,N)</span>

<span class="s2">        contour up to *N* automatically-chosen levels.</span>

<span class="s2">        ::</span>

<span class="s2">          contour(Z,V)</span>
<span class="s2">          contour(X,Y,Z,V)</span>

<span class="s2">        draw contour lines at the values specified in sequence *V*,</span>
<span class="s2">        which must be in increasing order.</span>

<span class="s2">        ::</span>

<span class="s2">          contourf(..., V)</span>

<span class="s2">        fill the ``len(V)-1`` regions between the values in *V*,</span>
<span class="s2">        which must be in increasing order.</span>

<span class="s2">        ::</span>

<span class="s2">          contour(Z, **kwargs)</span>

<span class="s2">        Use keyword args to control colors, linewidth, origin, cmap ... see</span>
<span class="s2">        below for more details.</span>

<span class="s2">        *X* and *Y* must both be 2-D with the same shape as *Z*, or they</span>
<span class="s2">        must both be 1-D such that ``len(X)`` is the number of columns in</span>
<span class="s2">        *Z* and ``len(Y)`` is the number of rows in *Z*.</span>

<span class="s2">        ``C = contour(...)`` returns a</span>
<span class="s2">        :class:`~matplotlib.contour.QuadContourSet` object.</span>

<span class="s2">        Optional keyword arguments:</span>

<span class="s2">          *corner_mask*: [ *True* | *False* | &#39;legacy&#39; ]</span>
<span class="s2">            Enable/disable corner masking, which only has an effect if *Z* is</span>
<span class="s2">            a masked array.  If *False*, any quad touching a masked point is</span>
<span class="s2">            masked out.  If *True*, only the triangular corners of quads</span>
<span class="s2">            nearest those points are always masked out, other triangular</span>
<span class="s2">            corners comprising three unmasked points are contoured as usual.</span>
<span class="s2">            If &#39;legacy&#39;, the old contouring algorithm is used, which is</span>
<span class="s2">            equivalent to *False* and is deprecated, only remaining whilst the</span>
<span class="s2">            new algorithm is tested fully.</span>

<span class="s2">            If not specified, the default is taken from</span>
<span class="s2">            rcParams[&#39;contour.corner_mask&#39;], which is True unless it has</span>
<span class="s2">            been modified.</span>

<span class="s2">          *colors*: [ *None* | string | (mpl_colors) ]</span>
<span class="s2">            If *None*, the colormap specified by cmap will be used.</span>

<span class="s2">            If a string, like &#39;r&#39; or &#39;red&#39;, all levels will be plotted in this</span>
<span class="s2">            color.</span>

<span class="s2">            If a tuple of matplotlib color args (string, float, rgb, etc),</span>
<span class="s2">            different levels will be plotted in different colors in the order</span>
<span class="s2">            specified.</span>

<span class="s2">          *alpha*: float</span>
<span class="s2">            The alpha blending value</span>

<span class="s2">          *cmap*: [ *None* | Colormap ]</span>
<span class="s2">            A cm :class:`~matplotlib.colors.Colormap` instance or</span>
<span class="s2">            *None*. If *cmap* is *None* and *colors* is *None*, a</span>
<span class="s2">            default Colormap is used.</span>

<span class="s2">          *norm*: [ *None* | Normalize ]</span>
<span class="s2">            A :class:`matplotlib.colors.Normalize` instance for</span>
<span class="s2">            scaling data values to colors. If *norm* is *None* and</span>
<span class="s2">            *colors* is *None*, the default linear scaling is used.</span>

<span class="s2">          *vmin*, *vmax*: [ *None* | scalar ]</span>
<span class="s2">            If not *None*, either or both of these values will be</span>
<span class="s2">            supplied to the :class:`matplotlib.colors.Normalize`</span>
<span class="s2">            instance, overriding the default color scaling based on</span>
<span class="s2">            *levels*.</span>

<span class="s2">          *levels*: [level0, level1, ..., leveln]</span>
<span class="s2">            A list of floating point numbers indicating the level</span>
<span class="s2">            curves to draw, in increasing order; e.g., to draw just</span>
<span class="s2">            the zero contour pass ``levels=[0]``</span>

<span class="s2">          *origin*: [ *None* | &#39;upper&#39; | &#39;lower&#39; | &#39;image&#39; ]</span>
<span class="s2">            If *None*, the first value of *Z* will correspond to the</span>
<span class="s2">            lower left corner, location (0,0). If &#39;image&#39;, the rc</span>
<span class="s2">            value for ``image.origin`` will be used.</span>

<span class="s2">            This keyword is not active if *X* and *Y* are specified in</span>
<span class="s2">            the call to contour.</span>

<span class="s2">          *extent*: [ *None* | (x0,x1,y0,y1) ]</span>

<span class="s2">            If *origin* is not *None*, then *extent* is interpreted as</span>
<span class="s2">            in :func:`matplotlib.pyplot.imshow`: it gives the outer</span>
<span class="s2">            pixel boundaries. In this case, the position of Z[0,0]</span>
<span class="s2">            is the center of the pixel, not a corner. If *origin* is</span>
<span class="s2">            *None*, then (*x0*, *y0*) is the position of Z[0,0], and</span>
<span class="s2">            (*x1*, *y1*) is the position of Z[-1,-1].</span>

<span class="s2">            This keyword is not active if *X* and *Y* are specified in</span>
<span class="s2">            the call to contour.</span>

<span class="s2">          *locator*: [ *None* | ticker.Locator subclass ]</span>
<span class="s2">            If *locator* is *None*, the default</span>
<span class="s2">            :class:`~matplotlib.ticker.MaxNLocator` is used. The</span>
<span class="s2">            locator is used to determine the contour levels if they</span>
<span class="s2">            are not given explicitly via the *V* argument.</span>

<span class="s2">          *extend*: [ &#39;neither&#39; | &#39;both&#39; | &#39;min&#39; | &#39;max&#39; ]</span>
<span class="s2">            Unless this is &#39;neither&#39;, contour levels are automatically</span>
<span class="s2">            added to one or both ends of the range so that all data</span>
<span class="s2">            are included. These added ranges are then mapped to the</span>
<span class="s2">            special colormap values which default to the ends of the</span>
<span class="s2">            colormap range, but can be set via</span>
<span class="s2">            :meth:`matplotlib.colors.Colormap.set_under` and</span>
<span class="s2">            :meth:`matplotlib.colors.Colormap.set_over` methods.</span>

<span class="s2">          *xunits*, *yunits*: [ *None* | registered units ]</span>
<span class="s2">            Override axis units by specifying an instance of a</span>
<span class="s2">            :class:`matplotlib.units.ConversionInterface`.</span>

<span class="s2">          *antialiased*: [ *True* | *False* ]</span>
<span class="s2">            enable antialiasing, overriding the defaults.  For</span>
<span class="s2">            filled contours, the default is *True*.  For line contours,</span>
<span class="s2">            it is taken from rcParams[&#39;lines.antialiased&#39;].</span>

<span class="s2">          *nchunk*: [ 0 | integer ]</span>
<span class="s2">            If 0, no subdivision of the domain.  Specify a positive integer to</span>
<span class="s2">            divide the domain into subdomains of *nchunk* by *nchunk* quads.</span>
<span class="s2">            Chunking reduces the maximum length of polygons generated by the</span>
<span class="s2">            contouring algorithm which reduces the rendering workload passed</span>
<span class="s2">            on to the backend and also requires slightly less RAM.  It can</span>
<span class="s2">            however introduce rendering artifacts at chunk boundaries depending</span>
<span class="s2">            on the backend, the *antialiased* flag and value of *alpha*.</span>

<span class="s2">        contour-only keyword arguments:</span>

<span class="s2">          *linewidths*: [ *None* | number | tuple of numbers ]</span>
<span class="s2">            If *linewidths* is *None*, the default width in</span>
<span class="s2">            ``lines.linewidth`` in ``matplotlibrc`` is used.</span>

<span class="s2">            If a number, all levels will be plotted with this linewidth.</span>

<span class="s2">            If a tuple, different levels will be plotted with different</span>
<span class="s2">            linewidths in the order specified.</span>

<span class="s2">          *linestyles*: [ *None* | &#39;solid&#39; | &#39;dashed&#39; | &#39;dashdot&#39; | &#39;dotted&#39; ]</span>
<span class="s2">            If *linestyles* is *None*, the default is &#39;solid&#39; unless</span>
<span class="s2">            the lines are monochrome.  In that case, negative</span>
<span class="s2">            contours will take their linestyle from the ``matplotlibrc``</span>
<span class="s2">            ``contour.negative_linestyle`` setting.</span>

<span class="s2">            *linestyles* can also be an iterable of the above strings</span>
<span class="s2">            specifying a set of linestyles to be used. If this</span>
<span class="s2">            iterable is shorter than the number of contour levels</span>
<span class="s2">            it will be repeated as necessary.</span>

<span class="s2">        contourf-only keyword arguments:</span>

<span class="s2">          *hatches*:</span>
<span class="s2">            A list of cross hatch patterns to use on the filled areas.</span>
<span class="s2">            If None, no hatching will be added to the contour.</span>
<span class="s2">            Hatching is supported in the PostScript, PDF, SVG and Agg</span>
<span class="s2">            backends only.</span>


<span class="s2">        Note: contourf fills intervals that are closed at the top; that</span>
<span class="s2">        is, for boundaries *z1* and *z2*, the filled region is::</span>

<span class="s2">            z1 &lt; z &lt;= z2</span>

<span class="s2">        There is one exception: if the lowest boundary coincides with</span>
<span class="s2">        the minimum value of the *z* array, then that minimum value</span>
<span class="s2">        will be included in the lowest interval.</span>

<span class="s2">        **Examples:**</span>

<span class="s2">        .. plot:: mpl_examples/pylab_examples/contour_demo.py</span>

<span class="s2">        .. plot:: mpl_examples/pylab_examples/contourf_demo.py</span>

<span class="s2">        .. plot:: mpl_examples/pylab_examples/contour_corner_mask.py</span>
<span class="s2">        &quot;&quot;&quot;</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>
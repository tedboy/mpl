

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>matplotlib.transforms &mdash; PROJECT_NAME 1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PROJECT_NAME 1 documentation" href="../../index.html"/>
        <link rel="up" title="matplotlib" href="../matplotlib.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> PROJECT_NAME
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.html">1. matplotlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.pyplot.html">2. matplotlib.pyplot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.axes.html">3. matplotlib.axes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.axis.html">4. matplotlib.axis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.cm.html">5. matplotlib.cm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.colorbar.html">6. matplotlib.colorbar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.colors.html">7. matplotlib.colors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.figure.html">8. matplotlib.figure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.legend.html">9. matplotlib.legend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.lines.html">10. matplotlib.lines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.markers.html">11. matplotlib.markers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.patches.html">12. matplotlib.patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.style.html">13. matplotlib.style</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.text.html">14. matplotlib.text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.widgets.html">15. matplotlib.widgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../separator.html">16. ===== INFREQ =====</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.animation.html">17. matplotlib.animation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.artist.html">18. matplotlib.artist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.backends.html">19. matplotlib.backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.cbook.html">20. matplotlib.cbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.collections.html">21. matplotlib.collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.dates.html">22. matplotlib.dates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.dviread.html">23. matplotlib.dviread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.finance.html">24. matplotlib.finance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.font_manager.html">25. matplotlib.font_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.gridspec.html">26. matplotlib.gridspec</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.image.html">27. matplotlib.image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.mathtext.html">28. matplotlib.mathtext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.mlab.html">29. matplotlib.mlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.offsetbox.html">30. matplotlib.offsetbox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.path.html">31. matplotlib.path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.patheffects.html">32. matplotlib.patheffects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.sankey.html">33. matplotlib.sankey</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.spines.html">34. matplotlib.spines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.ticker.html">35. matplotlib.ticker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.tight_layout.html">36. matplotlib.tight_layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.tri.html">37. matplotlib.tri</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.type1font.html">38. matplotlib.type1font</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../generated/matplotlib.units.html">39. matplotlib.units</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">PROJECT_NAME</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../matplotlib.html">matplotlib</a> &raquo;</li>
        
      <li>matplotlib.transforms</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for matplotlib.transforms</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">matplotlib includes a framework for arbitrary geometric</span>
<span class="sd">transformations that is used determine the final position of all</span>
<span class="sd">elements drawn on the canvas.</span>

<span class="sd">Transforms are composed into trees of :class:`TransformNode` objects</span>
<span class="sd">whose actual value depends on their children.  When the contents of</span>
<span class="sd">children change, their parents are automatically invalidated.  The</span>
<span class="sd">next time an invalidated transform is accessed, it is recomputed to</span>
<span class="sd">reflect those changes.  This invalidation/caching approach prevents</span>
<span class="sd">unnecessary recomputations of transforms, and contributes to better</span>
<span class="sd">interactive performance.</span>

<span class="sd">For example, here is a graph of the transform tree used to plot data</span>
<span class="sd">to the graph:</span>

<span class="sd">.. image:: ../_static/transforms.png</span>

<span class="sd">The framework can be used for both affine and non-affine</span>
<span class="sd">transformations.  However, for speed, we want use the backend</span>
<span class="sd">renderers to perform affine transformations whenever possible.</span>
<span class="sd">Therefore, it is possible to perform just the affine or non-affine</span>
<span class="sd">part of a transformation on a set of data.  The affine is always</span>
<span class="sd">assumed to occur after the non-affine.  For any transform::</span>

<span class="sd">  full transform == non-affine part + affine part</span>

<span class="sd">The backends are not expected to handle non-affine transformations</span>
<span class="sd">themselves.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">matplotlib.externals</span> <span class="k">import</span> <span class="n">six</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="k">import</span> <span class="n">ma</span>
<span class="kn">from</span> <span class="nn">matplotlib._path</span> <span class="k">import</span> <span class="p">(</span><span class="n">affine_transform</span><span class="p">,</span> <span class="n">count_bboxes_overlapping_bbox</span><span class="p">,</span>
    <span class="n">update_path_extents</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="k">import</span> <span class="n">inv</span>

<span class="kn">from</span> <span class="nn">weakref</span> <span class="k">import</span> <span class="n">WeakValueDictionary</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="k">try</span><span class="p">:</span>
    <span class="nb">set</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">sets</span> <span class="k">import</span> <span class="n">Set</span> <span class="k">as</span> <span class="nb">set</span>

<span class="kn">from</span> <span class="nn">.path</span> <span class="k">import</span> <span class="n">Path</span>

<span class="n">DEBUG</span> <span class="o">=</span> <span class="kc">False</span>
<span class="c1"># we need this later, but this is very expensive to set up</span>
<span class="n">MINFLOAT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">MachAr</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">xmin</span>
<span class="n">MaskedArray</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span>


<span class="k">class</span> <span class="nc">TransformNode</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :class:`TransformNode` is the base class for anything that</span>
<span class="sd">    participates in the transform tree and needs to invalidate its</span>
<span class="sd">    parents or be invalidated.  This includes classes that are not</span>
<span class="sd">    really transforms, such as bounding boxes, since some transforms</span>
<span class="sd">    depend on bounding boxes to compute their values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_gid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Invalidation may affect only the affine part.  If the</span>
    <span class="c1"># invalidation was &quot;affine-only&quot;, the _invalid member is set to</span>
    <span class="c1"># INVALID_AFFINE_ONLY</span>
    <span class="n">INVALID_NON_AFFINE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">INVALID_AFFINE</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">INVALID</span> <span class="o">=</span> <span class="n">INVALID_NON_AFFINE</span> <span class="o">|</span> <span class="n">INVALID_AFFINE</span>

    <span class="c1"># Some metadata about the transform, used to determine whether an</span>
    <span class="c1"># invalidation is affine-only</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">is_bbox</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If pass_through is True, all ancestors will always be</span>
<span class="sd">    invalidated, even if &#39;self&#39; is already invalid.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shorthand_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new :class:`TransformNode`.</span>

<span class="sd">        **shorthand_name** - a string representing the &quot;name&quot; of this</span>
<span class="sd">                             transform. The name carries no significance</span>
<span class="sd">                             other than to improve the readability of</span>
<span class="sd">                             ``str(transform)`` when DEBUG=True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parents are stored in a WeakValueDictionary, so that if the</span>
        <span class="c1"># parents are deleted, references from the children won&#39;t keep</span>
        <span class="c1"># them alive.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">()</span>

        <span class="c1"># TransformNodes start out as invalid until their values are</span>
        <span class="c1"># computed for the first time.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span> <span class="o">=</span> <span class="n">shorthand_name</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># either just return the name of this TransformNode, or it&#39;s repr</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span> <span class="ow">or</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># turn the weakkey dictionary into a normal dictionary</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;_parents&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_dict</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="n">data_dict</span>
        <span class="c1"># turn the normal dictionary back into a WeakValueDictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;TransformNode instances can not be copied. &quot;</span> <span class="o">+</span>
            <span class="s2">&quot;Consider using frozen() instead.&quot;</span><span class="p">)</span>
    <span class="n">__deepcopy__</span> <span class="o">=</span> <span class="n">__copy__</span>

    <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Invalidate this :class:`TransformNode` and triggers an</span>
<span class="sd">        invalidation of its ancestors.  Should be called any</span>
<span class="sd">        time the transform changes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_AFFINE</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalidate_internal</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_invalidate_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by :meth:`invalidate` and subsequently ascends the transform</span>
<span class="sd">        stack calling each TransformNode&#39;s _invalidate_internal method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># determine if this call will be an extension to the invalidation</span>
        <span class="c1"># status. If not, then a shortcut means that we needn&#39;t invoke an</span>
        <span class="c1"># invalidation up the transform stack as it will already have been</span>
        <span class="c1"># invalidated.</span>

        <span class="c1"># N.B This makes the invalidation sticky, once a transform has been</span>
        <span class="c1"># invalidated as NON_AFFINE, then it will always be invalidated as</span>
        <span class="c1"># NON_AFFINE even when triggered with a AFFINE_ONLY invalidation.</span>
        <span class="c1"># In most cases this is not a problem (i.e. for interactive panning and</span>
        <span class="c1"># zooming) and the only side effect will be on performance.</span>
        <span class="n">status_changed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">&lt;</span> <span class="n">value</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pass_through</span> <span class="ow">or</span> <span class="n">status_changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">)):</span>
                <span class="n">parent</span><span class="o">.</span><span class="n">_invalidate_internal</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                            <span class="n">invalidating_node</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the children of the transform, to let the invalidation</span>
<span class="sd">        system know which transforms can invalidate this transform.</span>
<span class="sd">        Should be called from the constructor of any transforms that</span>
<span class="sd">        depend on other transforms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_set_children</span> <span class="o">=</span> <span class="n">set_children</span>

        <span class="k">def</span> <span class="nf">set_children</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">children</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_children</span><span class="p">(</span><span class="o">*</span><span class="n">children</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_children</span> <span class="o">=</span> <span class="n">children</span>
        <span class="n">set_children</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">_set_children</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a frozen copy of this transform node.  The frozen copy</span>
<span class="sd">        will not update when its children change.  Useful for storing</span>
<span class="sd">        a previously known state of a transform where</span>
<span class="sd">        ``copy.deepcopy()`` might normally be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">write_graphviz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fobj</span><span class="p">,</span> <span class="n">highlight</span><span class="o">=</span><span class="p">[]):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            For debugging purposes.</span>

<span class="sd">            Writes the transform tree rooted at &#39;self&#39; to a graphviz &quot;dot&quot;</span>
<span class="sd">            format file.  This file can be run through the &quot;dot&quot; utility</span>
<span class="sd">            to produce a graph of the transform tree.</span>

<span class="sd">            Affine transforms are marked in blue.  Bounding boxes are</span>
<span class="sd">            marked in yellow.</span>

<span class="sd">            *fobj*: A Python file-like object</span>

<span class="sd">            Once the &quot;dot&quot; file has been created, it can be turned into a</span>
<span class="sd">            png easily with::</span>

<span class="sd">                $&gt; dot -Tpng -o $OUTPUT_FILE $DOT_FILE</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

            <span class="k">def</span> <span class="nf">recurse</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">props</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">label</span> <span class="o">=</span> <span class="n">root</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
                <span class="k">if</span> <span class="n">root</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
                    <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> <span class="n">label</span>
                <span class="k">if</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">highlight</span><span class="p">:</span>
                    <span class="n">props</span><span class="p">[</span><span class="s1">&#39;style&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;bold&#39;</span>
                <span class="n">props</span><span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;box&#39;</span>
                <span class="n">props</span><span class="p">[</span><span class="s1">&#39;label&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">label</span>
                <span class="n">props</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                                  <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span>
                                  <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">props</span><span class="p">)])</span>

                <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> [</span><span class="si">%s</span><span class="s1">];</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span>
                           <span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">root</span><span class="p">),</span> <span class="n">props</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;_children&#39;</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">_children</span><span class="p">:</span>
                        <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;?&#39;</span>
                        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">__dict__</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="n">child</span><span class="p">:</span>
                                <span class="n">name</span> <span class="o">=</span> <span class="n">key</span>
                                <span class="k">break</span>
                        <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot; -&gt; &quot;</span><span class="si">%s</span><span class="s1">&quot; [label=&quot;</span><span class="si">%s</span><span class="s1">&quot;, fontsize=10];</span><span class="se">\n</span><span class="s1">&#39;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="nb">hash</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
                                    <span class="nb">hash</span><span class="p">(</span><span class="n">child</span><span class="p">),</span>
                                    <span class="n">name</span><span class="p">))</span>
                        <span class="n">recurse</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

            <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;digraph G {</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">recurse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="n">fobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="BboxBase"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.html#matplotlib.artist.BboxBase">[docs]</a><span class="k">class</span> <span class="nc">BboxBase</span><span class="p">(</span><span class="n">TransformNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base class of all bounding boxes, and provides</span>
<span class="sd">    read-only access to its data.  A mutable bounding box is provided</span>
<span class="sd">    by the :class:`Bbox` class.</span>

<span class="sd">    The canonical representation is as two points, with no</span>
<span class="sd">    restrictions on their ordering.  Convenience properties are</span>
<span class="sd">    provided to get the left, bottom, right and top edges and width</span>
<span class="sd">    and height, but these are not stored explicitly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_bbox</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1">#* Redundant: Removed for performance</span>
    <span class="c1">#</span>
    <span class="c1"># def __init__(self):</span>
    <span class="c1">#     TransformNode.__init__(self)</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">_check</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Bbox bounds are a masked array.&quot;</span><span class="p">)</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span>
                <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Singular Bbox.&quot;</span><span class="p">)</span>
        <span class="n">_check</span> <span class="o">=</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">_check</span><span class="p">)</span>

<div class="viewcode-block" id="BboxBase.frozen"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.frozen.html#matplotlib.artist.BboxBase.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>
    <span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">TransformNode</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>

<div class="viewcode-block" id="BboxBase.is_unit"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.is_unit.html#matplotlib.artist.BboxBase.is_unit">[docs]</a>    <span class="k">def</span> <span class="nf">is_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if the :class:`Bbox` is the unit bounding box</span>
<span class="sd">        from (0, 0) to (1, 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span> <span class="o">==</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_get_x0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_x0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">         (property) :attr:`x0` is the first of the pair of *x* coordinates that</span>
<span class="s2">         define the bounding box.  :attr:`x0` is not guaranteed to be</span>
<span class="s2">         less than :attr:`x1`.  If you require that, use :attr:`xmin`.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_y0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_y0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">         (property) :attr:`y0` is the first of the pair of *y* coordinates that</span>
<span class="s2">         define the bounding box.  :attr:`y0` is not guaranteed to be</span>
<span class="s2">         less than :attr:`y1`.  If you require that, use :attr:`ymin`.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_x1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_x1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">         (property) :attr:`x1` is the second of the pair of *x* coordinates</span>
<span class="s2">         that define the bounding box.  :attr:`x1` is not guaranteed to be</span>
<span class="s2">         greater than :attr:`x0`.  If you require that, use :attr:`xmax`.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_y1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_y1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">         (property) :attr:`y1` is the second of the pair of *y* coordinates</span>
<span class="s2">         that define the bounding box.  :attr:`y1` is not guaranteed to be</span>
<span class="s2">         greater than :attr:`y0`.  If you require that, use :attr:`ymax`.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_p0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_p0</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">         (property) :attr:`p0` is the first pair of (*x*, *y*) coordinates</span>
<span class="s2">         that define the bounding box.  It is not guaranteed to be the</span>
<span class="s2">         bottom-left corner.  For that, use :attr:`min`.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_p1</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_p1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">         (property) :attr:`p1` is the second pair of (*x*, *y*) coordinates</span>
<span class="s2">         that define the bounding box.  It is not guaranteed to be the</span>
<span class="s2">         top-right corner.  For that, use :attr:`max`.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_xmin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_xmin</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) :attr:`xmin` is the left edge of the bounding box.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_ymin</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_ymin</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) :attr:`ymin` is the bottom edge of the bounding box.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_xmax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_xmax</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) :attr:`xmax` is the right edge of the bounding box.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_ymax</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_ymax</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) :attr:`ymax` is the top edge of the bounding box.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_min</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]),</span>
                <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">])]</span>
    <span class="nb">min</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_min</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) :attr:`min` is the bottom-left corner of the bounding</span>
<span class="s2">        box.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_max</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]),</span>
                <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">])]</span>
    <span class="nb">max</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_max</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) :attr:`max` is the top-right corner of the bounding box.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_intervalx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">intervalx</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_intervalx</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) :attr:`intervalx` is the pair of *x* coordinates that define</span>
<span class="s2">        the bounding box. It is not guaranteed to be sorted from left to</span>
<span class="s2">        right.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_intervaly</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">intervaly</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_intervaly</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) :attr:`intervaly` is the pair of *y* coordinates that define</span>
<span class="s2">        the bounding box.  It is not guaranteed to be sorted from bottom to</span>
<span class="s2">        top.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_width</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) The width of the bounding box.  It may be negative if</span>
<span class="s2">        :attr:`x1` &lt; :attr:`x0`.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_height</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) The height of the bounding box.  It may be negative if</span>
<span class="s2">        :attr:`y1` &lt; :attr:`y0`.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">size</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) The width and height of the bounding box.  May be negative,</span>
<span class="s2">        in the same way as :attr:`width` and :attr:`height`.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_bounds</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) Returns (:attr:`x0`, :attr:`y0`, :attr:`width`,</span>
<span class="s2">        :attr:`height`).&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_extents</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">extents</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_extents</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        (property) Returns (:attr:`x0`, :attr:`y0`, :attr:`x1`,</span>
<span class="s2">        :attr:`y1`).&quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BboxBase.get_points"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.get_points.html#matplotlib.artist.BboxBase.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div>

<div class="viewcode-block" id="BboxBase.containsx"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.containsx.html#matplotlib.artist.BboxBase.containsx">[docs]</a>    <span class="k">def</span> <span class="nf">containsx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if *x* is between or equal to :attr:`x0` and</span>
<span class="sd">        :attr:`x1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalx</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">x0</span> <span class="o">&lt;</span> <span class="n">x1</span>
                 <span class="ow">and</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x0</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x1</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">x1</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x0</span><span class="p">))</span></div>

<div class="viewcode-block" id="BboxBase.containsy"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.containsy.html#matplotlib.artist.BboxBase.containsy">[docs]</a>    <span class="k">def</span> <span class="nf">containsy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if *y* is between or equal to :attr:`y0` and</span>
<span class="sd">        :attr:`y1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervaly</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">y0</span> <span class="o">&lt;</span> <span class="n">y1</span>
                 <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">y0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">y1</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="n">y1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;=</span> <span class="n">y0</span><span class="p">))</span></div>

<div class="viewcode-block" id="BboxBase.contains"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.contains.html#matplotlib.artist.BboxBase.contains">[docs]</a>    <span class="k">def</span> <span class="nf">contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns *True* if (*x*, *y*) is a coordinate inside the</span>
<span class="sd">        bounding box or on its edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">containsx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">containsy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.overlaps"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.overlaps.html#matplotlib.artist.BboxBase.overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if this bounding box overlaps with the given</span>
<span class="sd">        bounding box *other*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ay2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extents</span><span class="p">()</span>
        <span class="n">bx1</span><span class="p">,</span> <span class="n">by1</span><span class="p">,</span> <span class="n">bx2</span><span class="p">,</span> <span class="n">by2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_extents</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ay2</span><span class="p">,</span> <span class="n">bx1</span><span class="p">,</span> <span class="n">by1</span><span class="p">,</span> <span class="n">bx2</span><span class="p">,</span> <span class="n">by2</span><span class="p">]):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">ax2</span> <span class="o">&lt;</span> <span class="n">ax1</span><span class="p">:</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span>
        <span class="k">if</span> <span class="n">ay2</span> <span class="o">&lt;</span> <span class="n">ay1</span><span class="p">:</span>
            <span class="n">ay2</span><span class="p">,</span> <span class="n">ay1</span> <span class="o">=</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ay2</span>
        <span class="k">if</span> <span class="n">bx2</span> <span class="o">&lt;</span> <span class="n">bx1</span><span class="p">:</span>
            <span class="n">bx2</span><span class="p">,</span> <span class="n">bx1</span> <span class="o">=</span> <span class="n">bx1</span><span class="p">,</span> <span class="n">bx2</span>
        <span class="k">if</span> <span class="n">by2</span> <span class="o">&lt;</span> <span class="n">by1</span><span class="p">:</span>
            <span class="n">by2</span><span class="p">,</span> <span class="n">by1</span> <span class="o">=</span> <span class="n">by1</span><span class="p">,</span> <span class="n">by2</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="p">((</span><span class="n">bx2</span> <span class="o">&lt;</span> <span class="n">ax1</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">by2</span> <span class="o">&lt;</span> <span class="n">ay1</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">bx1</span> <span class="o">&gt;</span> <span class="n">ax2</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">by1</span> <span class="o">&gt;</span> <span class="n">ay2</span><span class="p">))</span></div>

<div class="viewcode-block" id="BboxBase.fully_containsx"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.fully_containsx.html#matplotlib.artist.BboxBase.fully_containsx">[docs]</a>    <span class="k">def</span> <span class="nf">fully_containsx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if *x* is between but not equal to :attr:`x0` and</span>
<span class="sd">        :attr:`x1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervalx</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">x0</span> <span class="o">&lt;</span> <span class="n">x1</span>
                 <span class="ow">and</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">x0</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x1</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">x1</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">x0</span><span class="p">))</span></div>

<div class="viewcode-block" id="BboxBase.fully_containsy"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.fully_containsy.html#matplotlib.artist.BboxBase.fully_containsy">[docs]</a>    <span class="k">def</span> <span class="nf">fully_containsy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if *y* is between but not equal to :attr:`y0` and</span>
<span class="sd">        :attr:`y1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">y0</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">intervaly</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">y0</span> <span class="o">&lt;</span> <span class="n">y1</span>
                 <span class="ow">and</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">y0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y1</span><span class="p">))</span>
                <span class="ow">or</span> <span class="p">(</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">y1</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="n">y0</span><span class="p">))</span></div>

<div class="viewcode-block" id="BboxBase.fully_contains"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.fully_contains.html#matplotlib.artist.BboxBase.fully_contains">[docs]</a>    <span class="k">def</span> <span class="nf">fully_contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if (*x*, *y*) is a coordinate inside the bounding</span>
<span class="sd">        box, but not on its edge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fully_containsx</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> \
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">fully_containsy</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.fully_overlaps"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.fully_overlaps.html#matplotlib.artist.BboxBase.fully_overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">fully_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if this bounding box overlaps with the given</span>
<span class="sd">        bounding box *other*, but not on its edge alone.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ax1</span><span class="p">,</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">,</span> <span class="n">ay2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extents</span><span class="p">()</span>
        <span class="n">bx1</span><span class="p">,</span> <span class="n">by1</span><span class="p">,</span> <span class="n">bx2</span><span class="p">,</span> <span class="n">by2</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_get_extents</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">ax2</span> <span class="o">&lt;</span> <span class="n">ax1</span><span class="p">:</span>
            <span class="n">ax2</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span>
        <span class="k">if</span> <span class="n">ay2</span> <span class="o">&lt;</span> <span class="n">ay1</span><span class="p">:</span>
            <span class="n">ay2</span><span class="p">,</span> <span class="n">ay1</span> <span class="o">=</span> <span class="n">ay1</span><span class="p">,</span> <span class="n">ay2</span>
        <span class="k">if</span> <span class="n">bx2</span> <span class="o">&lt;</span> <span class="n">bx1</span><span class="p">:</span>
            <span class="n">bx2</span><span class="p">,</span> <span class="n">bx1</span> <span class="o">=</span> <span class="n">bx1</span><span class="p">,</span> <span class="n">bx2</span>
        <span class="k">if</span> <span class="n">by2</span> <span class="o">&lt;</span> <span class="n">by1</span><span class="p">:</span>
            <span class="n">by2</span><span class="p">,</span> <span class="n">by1</span> <span class="o">=</span> <span class="n">by1</span><span class="p">,</span> <span class="n">by2</span>

        <span class="k">return</span> <span class="ow">not</span> <span class="p">((</span><span class="n">bx2</span> <span class="o">&lt;=</span> <span class="n">ax1</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">by2</span> <span class="o">&lt;=</span> <span class="n">ay1</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">bx1</span> <span class="o">&gt;=</span> <span class="n">ax2</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="n">by1</span> <span class="o">&gt;=</span> <span class="n">ay2</span><span class="p">))</span></div>

<div class="viewcode-block" id="BboxBase.transformed"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.transformed.html#matplotlib.artist.BboxBase.transformed">[docs]</a>    <span class="k">def</span> <span class="nf">transformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new :class:`Bbox` object, statically transformed by</span>
<span class="sd">        the given transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="n">ll</span><span class="p">,</span> <span class="n">ul</span><span class="p">,</span> <span class="n">lr</span> <span class="o">=</span> <span class="n">transform</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">pts</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pts</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]))</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([</span><span class="n">ll</span><span class="p">,</span> <span class="p">[</span><span class="n">lr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ul</span><span class="p">[</span><span class="mi">1</span><span class="p">]]])</span></div>

<div class="viewcode-block" id="BboxBase.inverse_transformed"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.inverse_transformed.html#matplotlib.artist.BboxBase.inverse_transformed">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_transformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new :class:`Bbox` object, statically transformed by</span>
<span class="sd">        the inverse of the given transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transformed</span><span class="p">(</span><span class="n">transform</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span></div>

    <span class="n">coefs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;C&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
             <span class="s1">&#39;SW&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
             <span class="s1">&#39;S&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
             <span class="s1">&#39;SE&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
             <span class="s1">&#39;E&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span>
             <span class="s1">&#39;NE&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
             <span class="s1">&#39;N&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
             <span class="s1">&#39;NW&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">),</span>
             <span class="s1">&#39;W&#39;</span><span class="p">:</span>  <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)}</span>

<div class="viewcode-block" id="BboxBase.anchored"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.anchored.html#matplotlib.artist.BboxBase.anchored">[docs]</a>    <span class="k">def</span> <span class="nf">anchored</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the :class:`Bbox`, shifted to position *c*</span>
<span class="sd">        within a container.</span>

<span class="sd">        *c*: may be either:</span>

<span class="sd">          * a sequence (*cx*, *cy*) where *cx* and *cy* range from 0</span>
<span class="sd">            to 1, where 0 is left or bottom and 1 is right or top</span>

<span class="sd">          * a string:</span>
<span class="sd">            - &#39;C&#39; for centered</span>
<span class="sd">            - &#39;S&#39; for bottom-center</span>
<span class="sd">            - &#39;SE&#39; for bottom-left</span>
<span class="sd">            - &#39;E&#39; for left</span>
<span class="sd">            - etc.</span>

<span class="sd">        Optional argument *container* is the box within which the</span>
<span class="sd">        :class:`Bbox` is positioned; it defaults to the initial</span>
<span class="sd">        :class:`Bbox`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">six</span><span class="o">.</span><span class="n">string_types</span><span class="p">):</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coefs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">c</span>
        <span class="n">L</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">+</span>
                    <span class="p">[(</span><span class="n">l</span> <span class="o">+</span> <span class="n">cx</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">W</span><span class="p">))</span> <span class="o">-</span> <span class="n">L</span><span class="p">,</span>
                     <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="n">cy</span> <span class="o">*</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">H</span><span class="p">))</span> <span class="o">-</span> <span class="n">B</span><span class="p">])</span></div>

<div class="viewcode-block" id="BboxBase.shrunk"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.shrunk.html#matplotlib.artist.BboxBase.shrunk">[docs]</a>    <span class="k">def</span> <span class="nf">shrunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mx</span><span class="p">,</span> <span class="n">my</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the :class:`Bbox`, shrunk by the factor *mx*</span>
<span class="sd">        in the *x* direction and the factor *my* in the *y* direction.</span>
<span class="sd">        The lower left corner of the box remains unchanged.  Normally</span>
<span class="sd">        *mx* and *my* will be less than 1, but this is not enforced.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">mx</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">my</span> <span class="o">*</span> <span class="n">h</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.shrunk_to_aspect"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.shrunk_to_aspect.html#matplotlib.artist.BboxBase.shrunk_to_aspect">[docs]</a>    <span class="k">def</span> <span class="nf">shrunk_to_aspect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">box_aspect</span><span class="p">,</span> <span class="n">container</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fig_aspect</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the :class:`Bbox`, shrunk so that it is as</span>
<span class="sd">        large as it can be while having the desired aspect ratio,</span>
<span class="sd">        *box_aspect*.  If the box coordinates are relative---that</span>
<span class="sd">        is, fractions of a larger box such as a figure---then the</span>
<span class="sd">        physical aspect ratio of that figure is specified with</span>
<span class="sd">        *fig_aspect*, so that *box_aspect* can also be given as a</span>
<span class="sd">        ratio of the absolute dimensions, not the relative dimensions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">box_aspect</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">fig_aspect</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;box_aspect&#39; and &#39;fig_aspect&#39; must be positive&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">container</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">container</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">container</span><span class="o">.</span><span class="n">size</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">box_aspect</span> <span class="o">/</span> <span class="n">fig_aspect</span>
        <span class="k">if</span> <span class="n">H</span> <span class="o">&lt;=</span> <span class="n">h</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">W</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="n">fig_aspect</span> <span class="o">/</span> <span class="n">box_aspect</span>
            <span class="n">H</span> <span class="o">=</span> <span class="n">h</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                     <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">W</span><span class="p">,</span> <span class="n">H</span><span class="p">)])</span></div>

<div class="viewcode-block" id="BboxBase.splitx"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.splitx.html#matplotlib.artist.BboxBase.splitx">[docs]</a>    <span class="k">def</span> <span class="nf">splitx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        e.g., ``bbox.splitx(f1, f2, ...)``</span>

<span class="sd">        Returns a list of new :class:`Bbox` objects formed by</span>
<span class="sd">        splitting the original one with vertical lines at fractional</span>
<span class="sd">        positions *f1*, *f2*, ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extents</span><span class="p">()</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">-</span> <span class="n">x0</span>
        <span class="k">for</span> <span class="n">xf0</span><span class="p">,</span> <span class="n">xf1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">xf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span> <span class="o">+</span> <span class="n">xf0</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">y0</span><span class="p">],</span> <span class="p">[</span><span class="n">x0</span> <span class="o">+</span> <span class="n">xf1</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">y1</span><span class="p">]]))</span>
        <span class="k">return</span> <span class="n">boxes</span></div>

<div class="viewcode-block" id="BboxBase.splity"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.splity.html#matplotlib.artist.BboxBase.splity">[docs]</a>    <span class="k">def</span> <span class="nf">splity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        e.g., ``bbox.splitx(f1, f2, ...)``</span>

<span class="sd">        Returns a list of new :class:`Bbox` objects formed by</span>
<span class="sd">        splitting the original one with horizontal lines at fractional</span>
<span class="sd">        positions *f1*, *f2*, ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">boxes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">yf</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extents</span><span class="p">()</span>
        <span class="n">h</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">y0</span>
        <span class="k">for</span> <span class="n">yf0</span><span class="p">,</span> <span class="n">yf1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">yf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">yf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">boxes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Bbox</span><span class="p">([[</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">yf0</span> <span class="o">*</span> <span class="n">h</span><span class="p">],</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">yf1</span> <span class="o">*</span> <span class="n">h</span><span class="p">]]))</span>
        <span class="k">return</span> <span class="n">boxes</span></div>

<div class="viewcode-block" id="BboxBase.count_contains"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.count_contains.html#matplotlib.artist.BboxBase.count_contains">[docs]</a>    <span class="k">def</span> <span class="nf">count_contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of vertices contained in the :class:`Bbox`.</span>

<span class="sd">        *vertices* is a Nx2 Numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_extents</span><span class="p">()</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">dx0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x0</span><span class="p">)</span>
            <span class="n">dy0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y0</span><span class="p">)</span>
            <span class="n">dx1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">dy1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">vertices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span>
        <span class="n">inside</span> <span class="o">=</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">dx0</span> <span class="o">+</span> <span class="n">dx1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dy0</span> <span class="o">+</span> <span class="n">dy1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">inside</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.count_overlaps"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.count_overlaps.html#matplotlib.artist.BboxBase.count_overlaps">[docs]</a>    <span class="k">def</span> <span class="nf">count_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bboxes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the number of bounding boxes that overlap this one.</span>

<span class="sd">        bboxes is a sequence of :class:`BboxBase` objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">count_bboxes_overlapping_bbox</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">]))</span></div>

<div class="viewcode-block" id="BboxBase.expanded"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.expanded.html#matplotlib.artist.BboxBase.expanded">[docs]</a>    <span class="k">def</span> <span class="nf">expanded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sw</span><span class="p">,</span> <span class="n">sh</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new :class:`Bbox` which is this :class:`Bbox`</span>
<span class="sd">        expanded around its center by the given factors *sw* and</span>
<span class="sd">        *sh*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span>
        <span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span>
        <span class="n">deltaw</span> <span class="o">=</span> <span class="p">(</span><span class="n">sw</span> <span class="o">*</span> <span class="n">width</span> <span class="o">-</span> <span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">deltah</span> <span class="o">=</span> <span class="p">(</span><span class="n">sh</span> <span class="o">*</span> <span class="n">height</span> <span class="o">-</span> <span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="o">-</span><span class="n">deltaw</span><span class="p">,</span> <span class="o">-</span><span class="n">deltah</span><span class="p">],</span> <span class="p">[</span><span class="n">deltaw</span><span class="p">,</span> <span class="n">deltah</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span></div>

<div class="viewcode-block" id="BboxBase.padded"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.padded.html#matplotlib.artist.BboxBase.padded">[docs]</a>    <span class="k">def</span> <span class="nf">padded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new :class:`Bbox` that is padded on all four sides by</span>
<span class="sd">        the given value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">points</span> <span class="o">+</span> <span class="p">[[</span><span class="o">-</span><span class="n">p</span><span class="p">,</span> <span class="o">-</span><span class="n">p</span><span class="p">],</span> <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.translated"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.translated.html#matplotlib.artist.BboxBase.translated">[docs]</a>    <span class="k">def</span> <span class="nf">translated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the :class:`Bbox`, statically translated by</span>
<span class="sd">        *tx* and *ty*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">+</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">))</span></div>

<div class="viewcode-block" id="BboxBase.corners"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.corners.html#matplotlib.artist.BboxBase.corners">[docs]</a>    <span class="k">def</span> <span class="nf">corners</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array of points which are the four corners of this</span>
<span class="sd">        rectangle.  For example, if this :class:`Bbox` is defined by</span>
<span class="sd">        the points (*a*, *b*) and (*c*, *d*), :meth:`corners` returns</span>
<span class="sd">        (*a*, *b*), (*a*, *d*), (*c*, *b*) and (*c*, *d*).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">l</span><span class="p">,</span> <span class="n">t</span><span class="p">],</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">t</span><span class="p">]])</span></div>

<div class="viewcode-block" id="BboxBase.rotated"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.rotated.html#matplotlib.artist.BboxBase.rotated">[docs]</a>    <span class="k">def</span> <span class="nf">rotated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radians</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new bounding box that bounds a rotated version of</span>
<span class="sd">        this bounding box by the given radians.  The new bounding box</span>
<span class="sd">        is still aligned with the axes, of course.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">corners</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corners</span><span class="p">()</span>
        <span class="n">corners_rotated</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>
        <span class="n">bbox</span> <span class="o">=</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">unit</span><span class="p">()</span>
        <span class="n">bbox</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">corners_rotated</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bbox</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BboxBase.union"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.union.html#matplotlib.artist.BboxBase.union">[docs]</a>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">bboxes</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a :class:`Bbox` that contains all of the given bboxes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">bboxes</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;bboxes&#39; cannot be empty&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bboxes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">bboxes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">y0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="k">for</span> <span class="n">bbox</span> <span class="ow">in</span> <span class="n">bboxes</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">bbox</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">y0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">y1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">from_extents</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="BboxBase.intersection"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxBase.intersection.html#matplotlib.artist.BboxBase.intersection">[docs]</a>    <span class="k">def</span> <span class="nf">intersection</span><span class="p">(</span><span class="n">bbox1</span><span class="p">,</span> <span class="n">bbox2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the intersection of the two bboxes or None</span>
<span class="sd">        if they do not intersect.</span>

<span class="sd">        Implements the algorithm described at:</span>

<span class="sd">            http://www.tekpool.com/node/2687</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intersects</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">bbox2</span><span class="o">.</span><span class="n">xmin</span> <span class="o">&gt;</span> <span class="n">bbox1</span><span class="o">.</span><span class="n">xmax</span> <span class="ow">or</span>
                          <span class="n">bbox2</span><span class="o">.</span><span class="n">xmax</span> <span class="o">&lt;</span> <span class="n">bbox1</span><span class="o">.</span><span class="n">xmin</span> <span class="ow">or</span>
                          <span class="n">bbox2</span><span class="o">.</span><span class="n">ymin</span> <span class="o">&gt;</span> <span class="n">bbox1</span><span class="o">.</span><span class="n">ymax</span> <span class="ow">or</span>
                          <span class="n">bbox2</span><span class="o">.</span><span class="n">ymax</span> <span class="o">&lt;</span> <span class="n">bbox1</span><span class="o">.</span><span class="n">ymin</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">intersects</span><span class="p">:</span>
            <span class="n">x0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">bbox1</span><span class="o">.</span><span class="n">xmin</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">xmin</span><span class="p">])</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">bbox1</span><span class="o">.</span><span class="n">xmax</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">xmax</span><span class="p">])</span>
            <span class="n">y0</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">bbox1</span><span class="o">.</span><span class="n">ymin</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">ymin</span><span class="p">])</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">bbox1</span><span class="o">.</span><span class="n">ymax</span><span class="p">,</span> <span class="n">bbox2</span><span class="o">.</span><span class="n">ymax</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">from_extents</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="Bbox"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.html#matplotlib.artist.Bbox">[docs]</a><span class="k">class</span> <span class="nc">Bbox</span><span class="p">(</span><span class="n">BboxBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mutable bounding box.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *points*: a 2x2 numpy array of the form [[x0, y0], [x1, y1]]</span>

<span class="sd">        If you need to create a :class:`Bbox` object from another form</span>
<span class="sd">        of data, consider the static methods :meth:`unit`,</span>
<span class="sd">        :meth:`from_bounds` and :meth:`from_extents`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">BboxBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Bbox points must be of the form &#39;</span>
                             <span class="s1">&#39;&quot;[[x0, y0], [x1, y1]]&quot;.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0000001</span><span class="p">,</span> <span class="mf">0.0000001</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># it is helpful in some contexts to know if the bbox is a</span>
        <span class="c1"># default or has been mutated; we store the orig points to</span>
        <span class="c1"># support the mutated methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">___init__</span> <span class="o">=</span> <span class="n">__init__</span>

<div class="viewcode-block" id="Bbox.__init__"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.__init__.html#matplotlib.artist.Bbox.__init__">[docs]</a>        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">___init__</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Bbox.invalidate"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.invalidate.html#matplotlib.artist.Bbox.invalidate">[docs]</a>        <span class="k">def</span> <span class="nf">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">)</span>
            <span class="n">TransformNode</span><span class="o">.</span><span class="n">invalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Bbox.unit"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.unit.html#matplotlib.artist.Bbox.unit">[docs]</a>    <span class="k">def</span> <span class="nf">unit</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (staticmethod) Create a new unit :class:`Bbox` from (0, 0) to</span>
<span class="sd">        (1, 1).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Bbox.null"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.null.html#matplotlib.artist.Bbox.null">[docs]</a>    <span class="k">def</span> <span class="nf">null</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (staticmethod) Create a new null :class:`Bbox` from (inf, inf) to</span>
<span class="sd">        (-inf, -inf).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">))</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Bbox.from_bounds"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.from_bounds.html#matplotlib.artist.Bbox.from_bounds">[docs]</a>    <span class="k">def</span> <span class="nf">from_bounds</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (staticmethod) Create a new :class:`Bbox` from *x0*, *y0*,</span>
<span class="sd">        *width* and *height*.</span>

<span class="sd">        *width* and *height* may be negative.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">from_extents</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">,</span> <span class="n">x0</span> <span class="o">+</span> <span class="n">width</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">height</span><span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Bbox.from_extents"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.from_extents.html#matplotlib.artist.Bbox.from_extents">[docs]</a>    <span class="k">def</span> <span class="nf">from_extents</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (staticmethod) Create a new Bbox from *left*, *bottom*,</span>
<span class="sd">        *right* and *top*.</span>

<span class="sd">        The *y*-axis increases upwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__format__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s1">&#39;Bbox(x0={0.x0:</span><span class="si">{1}</span><span class="s1">}, y0={0.y0:</span><span class="si">{1}</span><span class="s1">}, x1={0.x1:</span><span class="si">{1}</span><span class="s1">}, y1={0.y1:</span><span class="si">{1}</span><span class="s1">})&#39;</span><span class="o">.</span>
            <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fmt</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;Bbox([[</span><span class="si">{0.x0}</span><span class="s1">, </span><span class="si">{0.y0}</span><span class="s1">], [</span><span class="si">{0.x1}</span><span class="s1">, </span><span class="si">{0.y1}</span><span class="s1">]])&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Bbox.ignore"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.ignore.html#matplotlib.artist.Bbox.ignore">[docs]</a>    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set whether the existing bounds of the box should be ignored</span>
<span class="sd">        by subsequent calls to :meth:`update_from_data` or</span>
<span class="sd">        :meth:`update_from_data_xy`.</span>

<span class="sd">        *value*:</span>

<span class="sd">           - When True, subsequent calls to :meth:`update_from_data`</span>
<span class="sd">             will ignore the existing bounds of the :class:`Bbox`.</span>

<span class="sd">           - When False, subsequent calls to :meth:`update_from_data`</span>
<span class="sd">             will include the existing bounds of the :class:`Bbox`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Bbox.update_from_data"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.update_from_data.html#matplotlib.artist.Bbox.update_from_data">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the bounds of the :class:`Bbox` based on the passed in</span>
<span class="sd">        data.  After updating, the bounds will have positive *width*</span>
<span class="sd">        and *height*; *x0* and *y0* will be the minimal values.</span>

<span class="sd">        *x*: a numpy array of *x*-values</span>

<span class="sd">        *y*: a numpy array of *y*-values</span>

<span class="sd">        *ignore*:</span>
<span class="sd">           - when True, ignore the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - when False, include the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - when None, use the last value passed to :meth:`ignore`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;update_from_data requires a memory copy -- please replace with &quot;</span>
            <span class="s2">&quot;update_from_data_xy&quot;</span><span class="p">)</span>

        <span class="n">xy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">y</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="mi">1</span><span class="p">))))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_from_data_xy</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span></div>

<div class="viewcode-block" id="Bbox.update_from_path"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.update_from_path.html#matplotlib.artist.Bbox.update_from_path">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the bounds of the :class:`Bbox` based on the passed in</span>
<span class="sd">        data.  After updating, the bounds will have positive *width*</span>
<span class="sd">        and *height*; *x0* and *y0* will be the minimal values.</span>

<span class="sd">        *path*: a :class:`~matplotlib.path.Path` instance</span>

<span class="sd">        *ignore*:</span>
<span class="sd">           - when True, ignore the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - when False, include the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - when None, use the last value passed to :meth:`ignore`.</span>

<span class="sd">        *updatex*: when True, update the x values</span>

<span class="sd">        *updatey*: when True, update the y values</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ignore</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ignore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignore</span>

        <span class="k">if</span> <span class="n">path</span><span class="o">.</span><span class="n">vertices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">points</span><span class="p">,</span> <span class="n">minpos</span><span class="p">,</span> <span class="n">changed</span> <span class="o">=</span> <span class="n">update_path_extents</span><span class="p">(</span>
            <span class="n">path</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">,</span> <span class="n">ignore</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">changed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">updatex</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">minpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">updatey</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">minpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span></div>

<div class="viewcode-block" id="Bbox.update_from_data_xy"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.update_from_data_xy.html#matplotlib.artist.Bbox.update_from_data_xy">[docs]</a>    <span class="k">def</span> <span class="nf">update_from_data_xy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xy</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">updatex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the bounds of the :class:`Bbox` based on the passed in</span>
<span class="sd">        data.  After updating, the bounds will have positive *width*</span>
<span class="sd">        and *height*; *x0* and *y0* will be the minimal values.</span>

<span class="sd">        *xy*: a numpy array of 2D points</span>

<span class="sd">        *ignore*:</span>
<span class="sd">           - when True, ignore the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - when False, include the existing bounds of the :class:`Bbox`.</span>
<span class="sd">           - when None, use the last value passed to :meth:`ignore`.</span>

<span class="sd">        *updatex*: when True, update the x values</span>

<span class="sd">        *updatey*: when True, update the y values</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">xy</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_from_path</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="n">ignore</span><span class="p">,</span>
                                    <span class="n">updatex</span><span class="o">=</span><span class="n">updatex</span><span class="p">,</span> <span class="n">updatey</span><span class="o">=</span><span class="n">updatey</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_set_x0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">BboxBase</span><span class="o">.</span><span class="n">_get_x0</span><span class="p">,</span> <span class="n">_set_x0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_y0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
    <span class="n">y0</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">BboxBase</span><span class="o">.</span><span class="n">_get_y0</span><span class="p">,</span> <span class="n">_set_y0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_x1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">BboxBase</span><span class="o">.</span><span class="n">_get_x1</span><span class="p">,</span> <span class="n">_set_x1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_y1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">BboxBase</span><span class="o">.</span><span class="n">_get_y1</span><span class="p">,</span> <span class="n">_set_y1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_p0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
    <span class="n">p0</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">BboxBase</span><span class="o">.</span><span class="n">_get_p0</span><span class="p">,</span> <span class="n">_set_p0</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_p1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">BboxBase</span><span class="o">.</span><span class="n">_get_p1</span><span class="p">,</span> <span class="n">_set_p1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_intervalx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
    <span class="n">intervalx</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">BboxBase</span><span class="o">.</span><span class="n">_get_intervalx</span><span class="p">,</span> <span class="n">_set_intervalx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_intervaly</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">interval</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
    <span class="n">intervaly</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">BboxBase</span><span class="o">.</span><span class="n">_get_intervaly</span><span class="p">,</span> <span class="n">_set_intervaly</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bounds</span><span class="p">):</span>
        <span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">bounds</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">l</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="p">[</span><span class="n">l</span> <span class="o">+</span> <span class="n">w</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">h</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">!=</span> <span class="n">points</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">BboxBase</span><span class="o">.</span><span class="n">_get_bounds</span><span class="p">,</span> <span class="n">_set_bounds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_minpos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span>
    <span class="n">minpos</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_minpos</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_minposx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">minposx</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_minposx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_minposy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_minpos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">minposy</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_minposy</span><span class="p">)</span>

<div class="viewcode-block" id="Bbox.get_points"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.get_points.html#matplotlib.artist.Bbox.get_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the points of the bounding box directly as a numpy array</span>
<span class="sd">        of the form: [[x0, y0], [x1, y1]].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span></div>

<div class="viewcode-block" id="Bbox.set_points"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.set_points.html#matplotlib.artist.Bbox.set_points">[docs]</a>    <span class="k">def</span> <span class="nf">set_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the points of the bounding box directly from a numpy array</span>
<span class="sd">        of the form: [[x0, y0], [x1, y1]].  No error checking is</span>
<span class="sd">        performed, as this method is mainly for internal use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">!=</span> <span class="n">points</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bbox.set"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.set.html#matplotlib.artist.Bbox.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set this bounding box from the &quot;frozen&quot; bounds of another</span>
<span class="sd">        :class:`Bbox`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_points</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bbox.mutated"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.mutated.html#matplotlib.artist.Bbox.mutated">[docs]</a>    <span class="k">def</span> <span class="nf">mutated</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;return whether the bbox has changed since init&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutatedx</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">mutatedy</span><span class="p">()</span></div>

<div class="viewcode-block" id="Bbox.mutatedx"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.mutatedx.html#matplotlib.artist.Bbox.mutatedx">[docs]</a>    <span class="k">def</span> <span class="nf">mutatedx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;return whether the x-limits have changed since init&#39;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="Bbox.mutatedy"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.Bbox.mutatedy.html#matplotlib.artist.Bbox.mutatedy">[docs]</a>    <span class="k">def</span> <span class="nf">mutatedy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s1">&#39;return whether the y-limits have changed since init&#39;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">or</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_points</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points_orig</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="TransformedBbox"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.TransformedBbox.html#matplotlib.artist.TransformedBbox">[docs]</a><span class="k">class</span> <span class="nc">TransformedBbox</span><span class="p">(</span><span class="n">BboxBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`Bbox` that is automatically transformed by a given</span>
<span class="sd">    transform.  When either the child bounding box or transform</span>
<span class="sd">    changes, the bounds of this bbox will update accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TransformedBbox.__init__"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.TransformedBbox.__init__.html#matplotlib.artist.TransformedBbox.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox</span><span class="p">,</span> <span class="n">transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *bbox*: a child :class:`Bbox`</span>

<span class="sd">        *transform*: a 2D :class:`Transform`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bbox</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;bbox&#39; is not a bbox&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;transform&#39; must be an instance of&quot;</span>
                   <span class="s2">&quot; &#39;matplotlib.transform.Transform&#39;&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transform</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">transform</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The input and output dimensions of &#39;transform&#39; must be 2&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">BboxBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span> <span class="o">=</span> <span class="n">bbox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">bbox</span><span class="p">,</span> <span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;TransformedBbox(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_bbox</span><span class="o">.</span><span class="n">get_points</span><span class="p">())</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_points</span> <span class="o">=</span> <span class="n">points</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_points</span>
    <span class="n">get_points</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Bbox</span><span class="o">.</span><span class="n">get_points</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_get_points</span> <span class="o">=</span> <span class="n">get_points</span>

<div class="viewcode-block" id="TransformedBbox.get_points"><a class="viewcode-back" href="../../generated/generated/matplotlib.tight_layout.TransformedBbox.get_points.html#matplotlib.artist.TransformedBbox.get_points">[docs]</a>        <span class="k">def</span> <span class="nf">get_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_points</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">points</span></div></div>


<div class="viewcode-block" id="Transform"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.html#matplotlib.artist.Transform">[docs]</a><span class="k">class</span> <span class="nc">Transform</span><span class="p">(</span><span class="n">TransformNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class of all :class:`TransformNode` instances that</span>
<span class="sd">    actually perform a transformation.</span>

<span class="sd">    All non-affine transformations should be subclasses of this class.</span>
<span class="sd">    New affine transformations should be subclasses of</span>
<span class="sd">    :class:`Affine2D`.</span>

<span class="sd">    Subclasses of this class should override the following members (at</span>
<span class="sd">    minimum):</span>

<span class="sd">      - :attr:`input_dims`</span>
<span class="sd">      - :attr:`output_dims`</span>
<span class="sd">      - :meth:`transform`</span>
<span class="sd">      - :attr:`is_separable`</span>
<span class="sd">      - :attr:`has_inverse`</span>
<span class="sd">      - :meth:`inverted` (if :attr:`has_inverse` is True)</span>

<span class="sd">    If the transform needs to do something non-standard with</span>
<span class="sd">    :class:`matplotlib.path.Path` objects, such as adding curves</span>
<span class="sd">    where there were once line segments, it should override:</span>

<span class="sd">      - :meth:`transform_path`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The number of input dimensions of this transform.</span>
<span class="sd">    Must be overridden (with integers) in the subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output_dims</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The number of output dimensions of this transform.</span>
<span class="sd">    Must be overridden (with integers) in the subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">has_inverse</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;True if this transform has a corresponding inverse transform.&quot;&quot;&quot;</span>

    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="sd">&quot;&quot;&quot;True if this transform is separable in the x- and y- dimensions.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Composes two transforms together such that *self* is followed</span>
<span class="sd">        by *other*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">composite_transform_factory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Can not add Transform to object of type &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Composes two transforms together such that *self* is followed</span>
<span class="sd">        by *other*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">composite_transform_factory</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;Can not add Transform to object of type &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># equality is based on transform object id. Hence:</span>
        <span class="c1"># Transform() != Transform().</span>
        <span class="c1"># Some classes, such as TransformWrapper &amp; AffineBase, will override.</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">_iter_break_from_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator breaking down this transform stack from left to</span>
<span class="sd">        right recursively. If self == ((A, N), A) then the result will be an</span>
<span class="sd">        iterator which yields I : ((A, N), A), followed by A : (N, A),</span>
<span class="sd">        followed by (A, N) : (A), but not ((A, N), A) : I.</span>

<span class="sd">        This is equivalent to flattening the stack then yielding</span>
<span class="sd">        ``flat_stack[:i], flat_stack[i:]`` where i=0..(n-1).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="n">IdentityTransform</span><span class="p">(),</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of transforms which have been chained</span>
<span class="sd">        together to form this Transform instance.</span>

<span class="sd">        .. note::</span>

<span class="sd">            For the special case of a Composite transform, the maximum depth</span>
<span class="sd">            of the two is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

<div class="viewcode-block" id="Transform.contains_branch"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.contains_branch.html#matplotlib.artist.Transform.contains_branch">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return whether the given transform is a sub-tree of this transform.</span>

<span class="sd">        This routine uses transform equality to identify sub-trees, therefore</span>
<span class="sd">        in many situations it is object id which will be used.</span>

<span class="sd">        For the case where the given transform represents the whole</span>
<span class="sd">        of this transform, returns True.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">depth</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># check that a subtree is equal to other (starting from self)</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub_tree</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Transform.contains_branch_seperately"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.contains_branch_seperately.html#matplotlib.artist.Transform.contains_branch_seperately">[docs]</a>    <span class="k">def</span> <span class="nf">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the given branch is a sub-tree of this transform on</span>
<span class="sd">        each seperate dimension.</span>

<span class="sd">        A common use for this method is to identify if a transform is a blended</span>
<span class="sd">        transform containing an axes&#39; data transform. e.g.::</span>

<span class="sd">            x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;contains_branch_seperately only supports &#39;</span>
                             <span class="s1">&#39;transforms with 2 output dimensions&#39;</span><span class="p">)</span>
        <span class="c1"># for a non-blended transform each seperate dimension is the same, so</span>
        <span class="c1"># just return the appropriate shape.</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">other_transform</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span></div>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a transform stack which goes all the way down self&#39;s transform</span>
<span class="sd">        stack, and then ascends back up other&#39;s stack. If it can, this is</span>
<span class="sd">        optimised::</span>

<span class="sd">            # normally</span>
<span class="sd">            A - B == a + b.inverted()</span>

<span class="sd">            # sometimes, when A contains the tree B there is no need to</span>
<span class="sd">            # descend all the way down to the base of A (via B), instead we</span>
<span class="sd">            # can just stop at B.</span>

<span class="sd">            (A + B) - (B)^-1 == A</span>

<span class="sd">            # similarly, when B contains tree A, we can avoid decending A at</span>
<span class="sd">            # all, basically:</span>
<span class="sd">            A - (A + B) == ((B + A) - A).inverted() or B^-1</span>

<span class="sd">        For clarity, the result of ``(A + B) - B + B == (A + B)``.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we only know how to do this operation if other is a Transform.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

        <span class="k">for</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub_tree</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">remainder</span>

        <span class="k">for</span> <span class="n">remainder</span><span class="p">,</span> <span class="n">sub_tree</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sub_tree</span> <span class="o">==</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">remainder</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The shortcut cannot be computed since &quot;</span>
                     <span class="s2">&quot;other&#39;s transform includes a non-invertable component.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">remainder</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>

        <span class="c1"># if we have got this far, then there was no shortcut possible</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">has_inverse</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;It is not possible to compute transA - transB &#39;</span>
                             <span class="s1">&#39;since transB cannot be inverted and there is no &#39;</span>
                             <span class="s1">&#39;shortcut possible.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Array interface to get at this Transform&#39;s affine matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>

<div class="viewcode-block" id="Transform.transform"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.transform.html#matplotlib.artist.Transform.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the transformation on the given array of values.</span>

<span class="sd">        Accepts a numpy array of shape (N x :attr:`input_dims`) and</span>
<span class="sd">        returns a numpy array of shape (N x :attr:`output_dims`).</span>

<span class="sd">        Alternatively, accepts a numpy array of length :attr:`input_dims`</span>
<span class="sd">        and returns a numpy array of length :attr:`output_dims`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure that values is a 2d array (but remember whether</span>
        <span class="c1"># we started with a 1d or 2d array).</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">ndim</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">))</span>

        <span class="c1"># Transform the values</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>

        <span class="c1"># Convert the result back to the shape of the input values.</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">assert</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>  <span class="c1"># just to be on the safe side</span>
            <span class="k">return</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Input values must have shape (N x </span><span class="si">{dims}</span><span class="s2">) &quot;</span>
                <span class="s2">&quot;or (</span><span class="si">{dims}</span><span class="s2">).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="Transform.transform_affine"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.transform_affine.html#matplotlib.artist.Transform.transform_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs only the affine part of this transformation on the</span>
<span class="sd">        given array of values.</span>

<span class="sd">        ``transform(values)`` is always equivalent to</span>
<span class="sd">        ``transform_affine(transform_non_affine(values))``.</span>

<span class="sd">        In non-affine transformations, this is generally a no-op.  In</span>
<span class="sd">        affine transformations, this is equivalent to</span>
<span class="sd">        ``transform(values)``.</span>

<span class="sd">        Accepts a numpy array of shape (N x :attr:`input_dims`) and</span>
<span class="sd">        returns a numpy array of shape (N x :attr:`output_dims`).</span>

<span class="sd">        Alternatively, accepts a numpy array of length :attr:`input_dims`</span>
<span class="sd">        and returns a numpy array of length :attr:`output_dims`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transform.transform_non_affine"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.transform_non_affine.html#matplotlib.artist.Transform.transform_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs only the non-affine part of the transformation.</span>

<span class="sd">        ``transform(values)`` is always equivalent to</span>
<span class="sd">        ``transform_affine(transform_non_affine(values))``.</span>

<span class="sd">        In non-affine transformations, this is generally equivalent to</span>
<span class="sd">        ``transform(values)``.  In affine transformations, this is</span>
<span class="sd">        always a no-op.</span>

<span class="sd">        Accepts a numpy array of shape (N x :attr:`input_dims`) and</span>
<span class="sd">        returns a numpy array of shape (N x :attr:`output_dims`).</span>

<span class="sd">        Alternatively, accepts a numpy array of length :attr:`input_dims`</span>
<span class="sd">        and returns a numpy array of length :attr:`output_dims`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">values</span></div>

<div class="viewcode-block" id="Transform.transform_bbox"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.transform_bbox.html#matplotlib.artist.Transform.transform_bbox">[docs]</a>    <span class="k">def</span> <span class="nf">transform_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bbox</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform the given bounding box.</span>

<span class="sd">        Note, for smarter transforms including caching (a common</span>
<span class="sd">        requirement for matplotlib figures), see :class:`TransformedBbox`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Bbox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">bbox</span><span class="o">.</span><span class="n">get_points</span><span class="p">()))</span></div>

<div class="viewcode-block" id="Transform.get_affine"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.get_affine.html#matplotlib.artist.Transform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the affine part of this transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">IdentityTransform</span><span class="p">()</span></div>

<div class="viewcode-block" id="Transform.get_matrix"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.get_matrix.html#matplotlib.artist.Transform.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the Affine transformation array for the affine part</span>
<span class="sd">        of this transform.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span></div>

<div class="viewcode-block" id="Transform.transform_point"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.transform_point.html#matplotlib.artist.Transform.transform_point">[docs]</a>    <span class="k">def</span> <span class="nf">transform_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A convenience function that returns the transformed copy of a</span>
<span class="sd">        single point.</span>

<span class="sd">        The point is given as a sequence of length :attr:`input_dims`.</span>
<span class="sd">        The transformed point is returned as a sequence of length</span>
<span class="sd">        :attr:`output_dims`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">point</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The length of &#39;point&#39; must be &#39;self.input_dims&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">point</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Transform.transform_path"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.transform_path.html#matplotlib.artist.Transform.transform_path">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a transformed path.</span>

<span class="sd">        *path*: a :class:`~matplotlib.path.Path` instance.</span>

<span class="sd">        In some cases, this transform may insert curves into the path</span>
<span class="sd">        that began as line segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">path</span><span class="p">))</span></div>

<div class="viewcode-block" id="Transform.transform_path_affine"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.transform_path_affine.html#matplotlib.artist.Transform.transform_path_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a path, transformed only by the affine part of</span>
<span class="sd">        this transform.</span>

<span class="sd">        *path*: a :class:`~matplotlib.path.Path` instance.</span>

<span class="sd">        ``transform_path(path)`` is equivalent to</span>
<span class="sd">        ``transform_path_affine(transform_path_non_affine(values))``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Transform.transform_path_non_affine"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.transform_path_non_affine.html#matplotlib.artist.Transform.transform_path_non_affine">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a path, transformed only by the non-affine</span>
<span class="sd">        part of this transform.</span>

<span class="sd">        *path*: a :class:`~matplotlib.path.Path` instance.</span>

<span class="sd">        ``transform_path(path)`` is equivalent to</span>
<span class="sd">        ``transform_path_affine(transform_path_non_affine(values))``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Path</span><span class="o">.</span><span class="n">_fast_from_codes_and_verts</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span>
                <span class="p">{</span><span class="s1">&#39;interpolation_steps&#39;</span><span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="n">_interpolation_steps</span><span class="p">,</span>
                 <span class="s1">&#39;should_simplify&#39;</span><span class="p">:</span> <span class="n">path</span><span class="o">.</span><span class="n">should_simplify</span><span class="p">})</span></div>

<div class="viewcode-block" id="Transform.transform_angles"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.transform_angles.html#matplotlib.artist.Transform.transform_angles">[docs]</a>    <span class="k">def</span> <span class="nf">transform_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angles</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">radians</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">pushoff</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs transformation on a set of angles anchored at</span>
<span class="sd">        specific locations.</span>

<span class="sd">        The *angles* must be a column vector (i.e., numpy array).</span>

<span class="sd">        The *pts* must be a two-column numpy array of x,y positions</span>
<span class="sd">        (angle transforms currently only work in 2D).  This array must</span>
<span class="sd">        have the same number of rows as *angles*.</span>

<span class="sd">        *radians* indicates whether or not input angles are given in</span>
<span class="sd">         radians (True) or degrees (False; the default).</span>

<span class="sd">        *pushoff* is the distance to move away from *pts* for</span>
<span class="sd">         determining transformed angles (see discussion of method</span>
<span class="sd">         below).</span>

<span class="sd">        The transformed angles are returned in an array with the same</span>
<span class="sd">        size as *angles*.</span>

<span class="sd">        The generic version of this method uses a very generic</span>
<span class="sd">        algorithm that transforms *pts*, as well as locations very</span>
<span class="sd">        close to *pts*, to find the angle in the transformed system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Must be 2D</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Only defined in 2D&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;pts&#39; must be array with 2 columns for x,y&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">angles</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">angles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;angles&#39; must be a column vector and have same number of&quot;</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot; rows as &#39;pts&#39;&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># Convert to radians if desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">radians</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span> <span class="o">/</span> <span class="mf">180.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># Move a short distance away</span>
        <span class="n">pts2</span> <span class="o">=</span> <span class="n">pts</span> <span class="o">+</span> <span class="n">pushoff</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angles</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angles</span><span class="p">)]</span>

        <span class="c1"># Transform both sets of points</span>
        <span class="n">tpts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">tpts2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">pts2</span><span class="p">)</span>

        <span class="c1"># Calculate transformed angles</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">tpts2</span> <span class="o">-</span> <span class="n">tpts</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">d</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Convert back to degrees if desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">radians</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="mf">180.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="Transform.inverted"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Transform.inverted.html#matplotlib.artist.Transform.inverted">[docs]</a>    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the corresponding inverse transformation.</span>

<span class="sd">        The return value of this method should be treated as</span>
<span class="sd">        temporary.  An update to *self* does not cause a corresponding</span>
<span class="sd">        update to its inverted copy.</span>

<span class="sd">        ``x === self.inverted().transform(self.transform(x))``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span></div></div>


<span class="k">class</span> <span class="nc">TransformWrapper</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A helper class that holds a single child transform and acts</span>
<span class="sd">    equivalently to it.</span>

<span class="sd">    This is useful if a node of the transform tree must be replaced at</span>
<span class="sd">    run time with a transform of a different type.  This class allows</span>
<span class="sd">    that replacement to correctly trigger invalidation.</span>

<span class="sd">    Note that :class:`TransformWrapper` instances must have the same</span>
<span class="sd">    input and output dimensions during their entire lifetime, so the</span>
<span class="sd">    child transform may only be replaced with another child transform</span>
<span class="sd">    of the same dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *child*: A class:`Transform` instance.  This child may later</span>
<span class="sd">        be replaced with :meth:`set`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;child&#39; must be an instance of&quot;</span>
                   <span class="s2">&quot; &#39;matplotlib.transform.Transform&#39;&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="n">Transform</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">input_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">output_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>

        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="p">)</span>

    <span class="c1"># NOTE: Transform.__[gs]etstate__ should be sufficient when using only</span>
    <span class="c1"># Python 3.4+.</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># only store the child information and parents</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s1">&#39;child&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="p">,</span>
            <span class="s1">&#39;input_dims&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span><span class="p">,</span>
            <span class="s1">&#39;output_dims&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span><span class="p">,</span>
            <span class="c1"># turn the weakkey dictionary into a normal dictionary</span>
            <span class="s1">&#39;parents&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">))</span>
        <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># re-initialise the TransformWrapper with the state&#39;s child</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;child&#39;</span><span class="p">])</span>
        <span class="c1"># The child may not be unpickled yet, so restore its information.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;input_dims&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;output_dims&#39;</span><span class="p">]</span>
        <span class="c1"># turn the normal dictionary back into a WeakValueDictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="n">WeakValueDictionary</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s1">&#39;parents&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;TransformWrapper(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span>

    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">frozen</span><span class="p">()</span>
    <span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">_set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_child</span> <span class="o">=</span> <span class="n">child</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">transform</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_non_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_non_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_path</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_path_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_non_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">transform_path_non_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">get_affine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inverted</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">inverted</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">get_matrix</span>

        <span class="c1"># note we do not wrap other properties here since the transform&#39;s</span>
        <span class="c1"># child can be changed with WrappedTransform.set and so checking</span>
        <span class="c1"># is_affine and other such properties may be dangerous.</span>

    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the current child of this transform with another one.</span>

<span class="sd">        The new child must have the same number of input and output</span>
<span class="sd">        dimensions as the current child.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="ow">or</span>
                <span class="n">child</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The new child must have the same number of input and&quot;</span>
                   <span class="s2">&quot; output dimensions as the current child.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_get_is_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">is_affine</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_affine</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_is_separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">is_separable</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_separable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_has_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_child</span><span class="o">.</span><span class="n">has_inverse</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_has_inverse</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">AffineBase</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class of all affine transformations of any number of</span>
<span class="sd">    dimensions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Transform</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__array__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># optimises the access of the transform matrix vs the superclass</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_concat</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenates two transformation matrices (represented as numpy</span>
<span class="sd">        arrays) together.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;is_affine&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
    <span class="n">transform</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Affine subclasses should override this &#39;</span>
                                  <span class="s1">&#39;method.&#39;</span><span class="p">)</span>
    <span class="n">transform_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">points</span>
    <span class="n">transform_non_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">transform_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
    <span class="n">transform_path</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_path</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">transform_affine</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span>
                    <span class="n">path</span><span class="o">.</span><span class="n">codes</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">_interpolation_steps</span><span class="p">)</span>
    <span class="n">transform_path_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="n">transform_path_non_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>
    <span class="n">get_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">get_affine</span><span class="o">.</span><span class="n">__doc__</span>


<span class="k">class</span> <span class="nc">Affine2DBase</span><span class="p">(</span><span class="n">AffineBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class of all 2D affine transformations.</span>

<span class="sd">    2D affine transformations are performed using a 3x3 numpy array::</span>

<span class="sd">        a c e</span>
<span class="sd">        b d f</span>
<span class="sd">        0 0 1</span>

<span class="sd">    This class provides the read-only interface.  For a mutable 2D</span>
<span class="sd">    affine transformation, use :class:`Affine2D`.</span>

<span class="sd">    Subclasses of this class will generally only need to override a</span>
<span class="sd">    constructor and :meth:`get_matrix` that generates a custom 3x3 matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">input_dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">output_dims</span> <span class="o">=</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">AffineBase</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">_get_is_separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_separable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">to_values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the values of the matrix as a sequence (a,b,c,d,e,f)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mtx</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">matrix_from_values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (staticmethod) Create a new transformation matrix as a 3x3</span>
<span class="sd">        numpy array of the form::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">tpoints</span> <span class="o">=</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mtx</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ma</span><span class="o">.</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">tpoints</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">affine_transform</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">mtx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">affine_transform</span><span class="p">([</span><span class="n">point</span><span class="p">],</span> <span class="n">mtx</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">transform_point</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">AffineBase</span><span class="o">.</span><span class="n">transform_point</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="n">_transform_affine</span> <span class="o">=</span> <span class="n">transform_affine</span>

        <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
            <span class="c1"># The major speed trap here is just converting to the</span>
            <span class="c1"># points to an array in the first place.  If we can use</span>
            <span class="c1"># more arrays upstream, that should help here.</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">ma</span><span class="o">.</span><span class="n">isMaskedArray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="p">(</span><span class="s1">&#39;A non-numpy array of type </span><span class="si">%s</span><span class="s1"> was passed in for &#39;</span> <span class="o">+</span>
                     <span class="s1">&#39;transformation.  Please correct this.&#39;</span><span class="p">)</span>
                    <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">transform_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">AffineBase</span><span class="o">.</span><span class="n">transform_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
            <span class="n">shorthand_name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span><span class="p">:</span>
                <span class="n">shorthand_name</span> <span class="o">=</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">)-1&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_shorthand_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">mtx</span><span class="p">),</span> <span class="n">shorthand_name</span><span class="o">=</span><span class="n">shorthand_name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span>
    <span class="n">inverted</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">AffineBase</span><span class="o">.</span><span class="n">inverted</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="Affine2D"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.html#matplotlib.artist.Affine2D">[docs]</a><span class="k">class</span> <span class="nc">Affine2D</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A mutable 2D affine transformation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Affine2D.__init__"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.__init__.html#matplotlib.artist.Affine2D.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize an Affine transform from a 3x3 numpy float array::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        If *matrix* is None, initialize with the identity transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">DEBUG</span><span class="p">:</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Affine2D(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>

<span class="c1">#    def __cmp__(self, other):</span>
<span class="c1">#        # XXX redundant. this only tells us eq.</span>
<span class="c1">#        if (isinstance(other, Affine2D) and</span>
<span class="c1">#            (self.get_matrix() == other.get_matrix()).all()):</span>
<span class="c1">#            return 0</span>
<span class="c1">#        return -1</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Affine2D.from_values"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.from_values.html#matplotlib.artist.Affine2D.from_values">[docs]</a>    <span class="k">def</span> <span class="nf">from_values</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (staticmethod) Create a new Affine2D instance from the given</span>
<span class="sd">        values::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)))</span></div>

<div class="viewcode-block" id="Affine2D.get_matrix"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.get_matrix.html#matplotlib.artist.Affine2D.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the underlying transformation matrix as a 3x3 numpy array::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>

<div class="viewcode-block" id="Affine2D.set_matrix"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.set_matrix.html#matplotlib.artist.Affine2D.set_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">set_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mtx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the underlying transformation matrix from a 3x3 numpy array::</span>

<span class="sd">          a c e</span>
<span class="sd">          b d f</span>
<span class="sd">          0 0 1</span>

<span class="sd">        .</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">mtx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

<div class="viewcode-block" id="Affine2D.set"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.set.html#matplotlib.artist.Affine2D.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set this transformation from the frozen copy of another</span>
<span class="sd">        :class:`Affine2DBase` object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Affine2DBase</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;other&#39; must be an instance of&quot;</span>
                   <span class="s2">&quot; &#39;matplotlib.transform.Affine2DBase&#39;&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="Affine2D.identity"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.identity.html#matplotlib.artist.Affine2D.identity">[docs]</a>    <span class="k">def</span> <span class="nf">identity</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (staticmethod) Return a new :class:`Affine2D` object that is</span>
<span class="sd">        the identity transform.</span>

<span class="sd">        Unless this transform will be mutated later on, consider using</span>
<span class="sd">        the faster :class:`IdentityTransform` class instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span></div>

<div class="viewcode-block" id="Affine2D.clear"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.clear.html#matplotlib.artist.Affine2D.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reset the underlying matrix to the identity transform.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.rotate"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.rotate.html#matplotlib.artist.Affine2D.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a rotation (in radians) to this transform in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">rotate_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">b</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">rotate_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.rotate_deg"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.rotate_deg.html#matplotlib.artist.Affine2D.rotate_deg">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_deg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a rotation (in degrees) to this transform in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">degrees</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">180.</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine2D.rotate_around"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.rotate_around.html#matplotlib.artist.Affine2D.rotate_around">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_around</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">theta</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a rotation (in radians) around the point (x, y) in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine2D.rotate_deg_around"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.rotate_deg_around.html#matplotlib.artist.Affine2D.rotate_deg_around">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_deg_around</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">degrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a rotation (in degrees) around the point (x, y) in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">rotate_deg</span><span class="p">(</span><span class="n">degrees</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Affine2D.translate"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.translate.html#matplotlib.artist.Affine2D.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tx</span><span class="p">,</span> <span class="n">ty</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a translation in place.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">translate_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">tx</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">ty</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">translate_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.scale"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.scale.html#matplotlib.artist.Affine2D.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sx</span><span class="p">,</span> <span class="n">sy</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a scale in place.</span>

<span class="sd">        If *sy* is None, the same scale is applied in both the *x*- and</span>
<span class="sd">        *y*-directions.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">sy</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="n">sx</span>
        <span class="n">scale_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[[</span><span class="n">sx</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">sy</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
            <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">scale_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.skew"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.skew.html#matplotlib.artist.Affine2D.skew">[docs]</a>    <span class="k">def</span> <span class="nf">skew</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xShear</span><span class="p">,</span> <span class="n">yShear</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a skew in place.</span>

<span class="sd">        *xShear* and *yShear* are the shear angles along the *x*- and</span>
<span class="sd">        *y*-axes, respectively, in radians.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rotX</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">xShear</span><span class="p">)</span>
        <span class="n">rotY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">yShear</span><span class="p">)</span>
        <span class="n">skew_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[[</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">rotX</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="n">rotY</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">skew_mtx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Affine2D.skew_deg"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.Affine2D.skew_deg.html#matplotlib.artist.Affine2D.skew_deg">[docs]</a>    <span class="k">def</span> <span class="nf">skew_deg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xShear</span><span class="p">,</span> <span class="n">yShear</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a skew in place.</span>

<span class="sd">        *xShear* and *yShear* are the shear angles along the *x*- and</span>
<span class="sd">        *y*-axes, respectively, in degrees.</span>

<span class="sd">        Returns *self*, so this method can easily be chained with more</span>
<span class="sd">        calls to :meth:`rotate`, :meth:`rotate_deg`, :meth:`translate`</span>
<span class="sd">        and :meth:`scale`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">skew</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">xShear</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">yShear</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_get_is_separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_separable</span><span class="p">)</span></div>


<div class="viewcode-block" id="IdentityTransform"><a class="viewcode-back" href="../../generated/generated/matplotlib.markers.IdentityTransform.html#matplotlib.artist.IdentityTransform">[docs]</a><span class="k">class</span> <span class="nc">IdentityTransform</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A special class that does on thing, the identity transform, in a</span>
<span class="sd">    fast way.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<div class="viewcode-block" id="IdentityTransform.frozen"><a class="viewcode-back" href="../../generated/generated/matplotlib.markers.IdentityTransform.frozen.html#matplotlib.artist.IdentityTransform.frozen">[docs]</a>    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    <span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;IdentityTransform()&quot;</span>

<div class="viewcode-block" id="IdentityTransform.get_matrix"><a class="viewcode-back" href="../../generated/generated/matplotlib.markers.IdentityTransform.get_matrix.html#matplotlib.artist.IdentityTransform.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="IdentityTransform.transform"><a class="viewcode-back" href="../../generated/generated/matplotlib.markers.IdentityTransform.transform.html#matplotlib.artist.IdentityTransform.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>
    <span class="n">transform</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="n">transform_affine</span> <span class="o">=</span> <span class="n">transform</span>
    <span class="n">transform_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="n">transform_non_affine</span> <span class="o">=</span> <span class="n">transform</span>
    <span class="n">transform_non_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="IdentityTransform.transform_path"><a class="viewcode-back" href="../../generated/generated/matplotlib.markers.IdentityTransform.transform_path.html#matplotlib.artist.IdentityTransform.transform_path">[docs]</a>    <span class="k">def</span> <span class="nf">transform_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">path</span></div>
    <span class="n">transform_path</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_path</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="n">transform_path_affine</span> <span class="o">=</span> <span class="n">transform_path</span>
    <span class="n">transform_path_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="n">transform_path_non_affine</span> <span class="o">=</span> <span class="n">transform_path</span>
    <span class="n">transform_path_non_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="IdentityTransform.get_affine"><a class="viewcode-back" href="../../generated/generated/matplotlib.markers.IdentityTransform.get_affine.html#matplotlib.artist.IdentityTransform.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div>
    <span class="n">get_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="n">inverted</span> <span class="o">=</span> <span class="n">get_affine</span>
    <span class="n">inverted</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">inverted</span><span class="o">.</span><span class="n">__doc__</span></div>


<span class="k">class</span> <span class="nc">BlendedGenericTransform</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A &quot;blended&quot; transform uses one transform for the *x*-direction, and</span>
<span class="sd">    another transform for the *y*-direction.</span>

<span class="sd">    This &quot;generic&quot; version can handle any given child transform in the</span>
<span class="sd">    *x*- and *y*-directions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">output_dims</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new &quot;blended&quot; transform using *x_transform* to</span>
<span class="sd">        transform the *x*-axis and *y_transform* to transform the</span>
<span class="sd">        *y*-axis.</span>

<span class="sd">        You will generally not call this constructor directly but use</span>
<span class="sd">        the :func:`blended_transform_factory` function instead, which</span>
<span class="sd">        can determine automatically which kind of blended transform to</span>
<span class="sd">        create.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Here we ask: &quot;Does it blend?&quot;</span>

        <span class="n">Transform</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">x_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">y_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Note, this is an exact copy of BlendedAffine2D.__eq__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">BlendedAffine2D</span><span class="p">,</span> <span class="n">BlendedGenericTransform</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_x</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="c1"># Note, this is an exact copy of BlendedAffine2D.contains_branch_seperately</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">depth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">depth</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">contains_branch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># a blended transform cannot possibly contain a branch from two different transforms.</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_get_is_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">is_affine</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_affine</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_has_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">has_inverse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">has_inverse</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_has_inverse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">blended_transform_factory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
    <span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;BlendedGenericTransform(</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span>

        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">x_points</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_points</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">x_points</span> <span class="o">=</span> <span class="n">x_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">x_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">y_points</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)[:,</span> <span class="mi">1</span><span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">y_points</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">y_points</span> <span class="o">=</span> <span class="n">y_points</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">y_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x_points</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_points</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x_points</span><span class="p">,</span> <span class="n">y_points</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">transform_non_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">BlendedGenericTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">inverted</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span>
    <span class="n">inverted</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">inverted</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="n">y_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="c1"># This works because we already know the transforms are</span>
                <span class="c1"># separable, though normally one would want to set b and</span>
                <span class="c1"># c to zero.</span>
                <span class="n">mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span> <span class="o">=</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">mtx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_affine</span>
    <span class="n">get_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">get_affine</span><span class="o">.</span><span class="n">__doc__</span>


<span class="k">class</span> <span class="nc">BlendedAffine2D</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A &quot;blended&quot; transform uses one transform for the *x*-direction, and</span>
<span class="sd">    another transform for the *y*-direction.</span>

<span class="sd">    This version is an optimization for the case where both child</span>
<span class="sd">    transforms are of type :class:`Affine2DBase`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new &quot;blended&quot; transform using *x_transform* to</span>
<span class="sd">        transform the *x*-axis and *y_transform* to transform the</span>
<span class="sd">        *y*-axis.</span>

<span class="sd">        Both *x_transform* and *y_transform* must be 2D affine</span>
<span class="sd">        transforms.</span>

<span class="sd">        You will generally not call this constructor directly but use</span>
<span class="sd">        the :func:`blended_transform_factory` function instead, which</span>
<span class="sd">        can determine automatically which kind of blended transform to</span>
<span class="sd">        create.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_affine</span> <span class="o">=</span> <span class="n">x_transform</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="n">y_transform</span><span class="o">.</span><span class="n">is_affine</span>
        <span class="n">is_separable</span> <span class="o">=</span> <span class="n">x_transform</span><span class="o">.</span><span class="n">is_separable</span> <span class="ow">and</span> <span class="n">y_transform</span><span class="o">.</span><span class="n">is_separable</span>
        <span class="n">is_correct</span> <span class="o">=</span> <span class="n">is_affine</span> <span class="ow">and</span> <span class="n">is_separable</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_correct</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Both *x_transform* and *y_transform* must be 2D affine&quot;</span>
                   <span class="s2">&quot; transforms.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">Transform</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">=</span> <span class="n">x_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">=</span> <span class="n">y_transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># Note, this is an exact copy of BlendedGenericTransform.__eq__</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">BlendedAffine2D</span><span class="p">,</span> <span class="n">BlendedGenericTransform</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_x</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_y</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="n">other</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

    <span class="k">def</span> <span class="nf">contains_branch_seperately</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="c1"># Note, this is an exact copy of BlendedTransform.contains_branch_seperately</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">contains_branch</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;BlendedAffine2D(</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">x_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_x</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="n">y_mtx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_y</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()</span>
                <span class="c1"># This works because we already know the transforms are</span>
                <span class="c1"># separable, though normally one would want to set b and</span>
                <span class="c1"># c to zero.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x_mtx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y_mtx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span>
    <span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="blended_transform_factory"><a class="viewcode-back" href="../../generated/matplotlib.widgets.blended_transform_factory.html#matplotlib.artist.blended_transform_factory">[docs]</a><span class="k">def</span> <span class="nf">blended_transform_factory</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new &quot;blended&quot; transform using *x_transform* to transform</span>
<span class="sd">    the *x*-axis and *y_transform* to transform the *y*-axis.</span>

<span class="sd">    A faster version of the blended transform is returned for the case</span>
<span class="sd">    where both child transforms are affine.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">Affine2DBase</span><span class="p">)</span>
        <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">y_transform</span><span class="p">,</span> <span class="n">Affine2DBase</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">BlendedAffine2D</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">BlendedGenericTransform</span><span class="p">(</span><span class="n">x_transform</span><span class="p">,</span> <span class="n">y_transform</span><span class="p">)</span></div>


<span class="k">class</span> <span class="nc">CompositeGenericTransform</span><span class="p">(</span><span class="n">Transform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A composite transform formed by applying transform *a* then</span>
<span class="sd">    transform *b*.</span>

<span class="sd">    This &quot;generic&quot; version can handle any two arbitrary</span>
<span class="sd">    transformations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pass_through</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new composite transform that is the result of</span>
<span class="sd">        applying transform *a* then transform *b*.</span>

<span class="sd">        You will generally not call this constructor directly but use</span>
<span class="sd">        the :func:`composite_transform_factory` function instead,</span>
<span class="sd">        which can automatically choose the best kind of composite</span>
<span class="sd">        transform instance to create.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">input_dims</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The output dimension of &#39;a&#39; must be equal to the input&quot;</span>
                   <span class="s2">&quot; dimensions of &#39;b&#39;&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">input_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">output_dims</span>

        <span class="n">Transform</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">frozen</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">frozen</span> <span class="o">=</span> <span class="n">composite_transform_factory</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">frozen</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">frozen</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frozen</span><span class="p">,</span> <span class="n">CompositeGenericTransform</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">frozen</span><span class="o">.</span><span class="n">frozen</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">frozen</span>
    <span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">frozen</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">_invalidate_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">invalidating_node</span><span class="p">):</span>
        <span class="c1"># In some cases for a composite transform, an invalidating call to AFFINE_ONLY needs</span>
        <span class="c1"># to be extended to invalidate the NON_AFFINE part too. These cases are when the right</span>
        <span class="c1"># hand transform is non-affine and either:</span>
        <span class="c1"># (a) the left hand transform is non affine</span>
        <span class="c1"># (b) it is the left hand node which has triggered the invalidation</span>
        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">Transform</span><span class="o">.</span><span class="n">INVALID_AFFINE</span> \
            <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span> \
            <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">or</span> <span class="n">invalidating_node</span> <span class="ow">is</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">):</span>

            <span class="n">value</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">INVALID</span>

        <span class="n">Transform</span><span class="o">.</span><span class="n">_invalidate_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span>
                                       <span class="n">invalidating_node</span><span class="o">=</span><span class="n">invalidating_node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="n">CompositeGenericTransform</span><span class="p">,</span> <span class="n">CompositeAffine2D</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_a</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_iter_break_from_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span>
        <span class="k">for</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">+</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">depth</span>

    <span class="k">def</span> <span class="nf">_get_is_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span>
    <span class="n">is_affine</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_affine</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_is_separable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_separable</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_separable</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_is_separable</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;CompositeGenericTransform(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">transform_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
    <span class="n">transform_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">points</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">points</span><span class="p">))</span>
    <span class="n">transform_non_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">path</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">transform_path</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
    <span class="n">transform_path_non_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Affine2D</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">()))</span>
    <span class="n">get_affine</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">get_affine</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">inverted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CompositeGenericTransform</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">inverted</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">inverted</span><span class="p">())</span>
    <span class="n">inverted</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Transform</span><span class="o">.</span><span class="n">inverted</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">_get_has_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">has_inverse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">has_inverse</span>
    <span class="n">has_inverse</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_has_inverse</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">CompositeAffine2D</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A composite transform formed by applying transform *a* then transform *b*.</span>

<span class="sd">    This version is an optimization that handles the case where both *a*</span>
<span class="sd">    and *b* are 2D affines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new composite transform that is the result of</span>
<span class="sd">        applying transform *a* then transform *b*.</span>

<span class="sd">        Both *a* and *b* must be instances of :class:`Affine2DBase`.</span>

<span class="sd">        You will generally not call this constructor directly but use</span>
<span class="sd">        the :func:`composite_transform_factory` function instead,</span>
<span class="sd">        which can automatically choose the best kind of composite</span>
<span class="sd">        transform instance to create.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">is_affine</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">b</span><span class="o">.</span><span class="n">is_affine</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;a&#39; and &#39;b&#39; must be affine transforms&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">input_dims</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;The output dimension of &#39;a&#39; must be equal to the input&quot;</span>
                   <span class="s2">&quot; dimensions of &#39;b&#39;&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_dims</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">input_dims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output_dims</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">output_dims</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_b</span> <span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="s1">&#39;(</span><span class="si">%s</span><span class="s1">, </span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">depth</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">depth</span>

    <span class="k">def</span> <span class="nf">_iter_break_from_left_to_right</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span>
        <span class="k">for</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">_iter_break_from_left_to_right</span><span class="p">():</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_a</span> <span class="o">+</span> <span class="n">lh_compliment</span><span class="p">,</span> <span class="n">rh_compliment</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;CompositeAffine2D(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_b</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">(),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_a</span><span class="o">.</span><span class="n">get_matrix</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span>
    <span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span>


<span class="k">def</span> <span class="nf">composite_transform_factory</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new composite transform that is the result of applying</span>
<span class="sd">    transform a then transform b.</span>

<span class="sd">    Shortcut versions of the blended transform are provided for the</span>
<span class="sd">    case where both child transforms are affine, or one or the other</span>
<span class="sd">    is the identity transform.</span>

<span class="sd">    Composite transforms may also be created using the &#39;+&#39; operator,</span>
<span class="sd">    e.g.::</span>

<span class="sd">      c = a + b</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check to see if any of a or b are IdentityTransforms. We use</span>
    <span class="c1"># isinstance here to guarantee that the transforms will *always*</span>
    <span class="c1"># be IdentityTransforms. Since TransformWrappers are mutable,</span>
    <span class="c1"># use of equality here would be wrong.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">IdentityTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">IdentityTransform</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Affine2D</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Affine2D</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CompositeAffine2D</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CompositeGenericTransform</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">BboxTransform</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :class:`BboxTransform` linearly transforms points from one</span>
<span class="sd">    :class:`Bbox` to another :class:`Bbox`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxin</span><span class="p">,</span> <span class="n">boxout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new :class:`BboxTransform` that linearly transforms</span>
<span class="sd">        points from *boxin* to *boxout*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxin</span><span class="o">.</span><span class="n">is_bbox</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">boxout</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;boxin&#39; and &#39;boxout&#39; must be bbox&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span> <span class="o">=</span> <span class="n">boxin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span> <span class="o">=</span> <span class="n">boxout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">boxin</span><span class="p">,</span> <span class="n">boxout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;BboxTransform(</span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">inl</span><span class="p">,</span> <span class="n">inb</span><span class="p">,</span> <span class="n">inw</span><span class="p">,</span> <span class="n">inh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">outl</span><span class="p">,</span> <span class="n">outb</span><span class="p">,</span> <span class="n">outw</span><span class="p">,</span> <span class="n">outh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">x_scale</span> <span class="o">=</span> <span class="n">outw</span> <span class="o">/</span> <span class="n">inw</span>
            <span class="n">y_scale</span> <span class="o">=</span> <span class="n">outh</span> <span class="o">/</span> <span class="n">inh</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">x_scale</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">y_scale</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transforming from or to a singular bounding box.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x_scale</span><span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inl</span><span class="o">*</span><span class="n">x_scale</span><span class="o">+</span><span class="n">outl</span><span class="p">)],</span>
                                   <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="n">y_scale</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inb</span><span class="o">*</span><span class="n">y_scale</span><span class="o">+</span><span class="n">outb</span><span class="p">)],</span>
                                   <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">1.0</span>        <span class="p">]],</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span>
    <span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="BboxTransformTo"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxTransformTo.html#matplotlib.artist.BboxTransformTo">[docs]</a><span class="k">class</span> <span class="nc">BboxTransformTo</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :class:`BboxTransformTo` is a transformation that linearly</span>
<span class="sd">    transforms points from the unit bounding box to a given</span>
<span class="sd">    :class:`Bbox`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BboxTransformTo.__init__"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxTransformTo.__init__.html#matplotlib.artist.BboxTransformTo.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxout</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new :class:`BboxTransformTo` that linearly transforms</span>
<span class="sd">        points from the unit bounding box to *boxout*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxout</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;boxout&#39; must be bbox&quot;</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span> <span class="o">=</span> <span class="n">boxout</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">boxout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;BboxTransformTo(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="p">)</span>

<div class="viewcode-block" id="BboxTransformTo.get_matrix"><a class="viewcode-back" href="../../generated/generated/matplotlib.text.BboxTransformTo.get_matrix.html#matplotlib.artist.BboxTransformTo.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">outl</span><span class="p">,</span> <span class="n">outb</span><span class="p">,</span> <span class="n">outw</span><span class="p">,</span> <span class="n">outh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">outw</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">outh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transforming to a singular bounding box.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">outw</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="n">outl</span><span class="p">],</span>
                                   <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">outh</span><span class="p">,</span> <span class="n">outb</span><span class="p">],</span>
                                   <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">1.0</span><span class="p">]],</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span></div>


<span class="k">class</span> <span class="nc">BboxTransformToMaxOnly</span><span class="p">(</span><span class="n">BboxTransformTo</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :class:`BboxTransformTo` is a transformation that linearly</span>
<span class="sd">    transforms points from the unit bounding box to a given</span>
<span class="sd">    :class:`Bbox` with a fixed upper left of (0, 0).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;BboxTransformToMaxOnly(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxout</span><span class="o">.</span><span class="n">max</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">xmax</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ymax</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transforming to a singular bounding box.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">xmax</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">ymax</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span>
                                  <span class="p">[</span> <span class="mf">0.0</span><span class="p">,</span>  <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span>
    <span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="BboxTransformFrom"><a class="viewcode-back" href="../../generated/generated/matplotlib.legend.BboxTransformFrom.html#matplotlib.artist.BboxTransformFrom">[docs]</a><span class="k">class</span> <span class="nc">BboxTransformFrom</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    :class:`BboxTransformFrom` linearly transforms points from a given</span>
<span class="sd">    :class:`Bbox` to the unit bounding box.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_separable</span> <span class="o">=</span> <span class="kc">True</span>

<div class="viewcode-block" id="BboxTransformFrom.__init__"><a class="viewcode-back" href="../../generated/generated/matplotlib.legend.BboxTransformFrom.__init__.html#matplotlib.artist.BboxTransformFrom.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boxin</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">boxin</span><span class="o">.</span><span class="n">is_bbox</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;boxin&#39; must be bbox&quot;</span><span class="p">)</span>

        <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span> <span class="o">=</span> <span class="n">boxin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">boxin</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;BboxTransformFrom(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="p">)</span>

<div class="viewcode-block" id="BboxTransformFrom.get_matrix"><a class="viewcode-back" href="../../generated/generated/matplotlib.legend.BboxTransformFrom.get_matrix.html#matplotlib.artist.BboxTransformFrom.get_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">inl</span><span class="p">,</span> <span class="n">inb</span><span class="p">,</span> <span class="n">inw</span><span class="p">,</span> <span class="n">inh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_boxin</span><span class="o">.</span><span class="n">bounds</span>
            <span class="k">if</span> <span class="n">DEBUG</span> <span class="ow">and</span> <span class="p">(</span><span class="n">inw</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">inh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Transforming from a singular bounding box.&quot;</span><span class="p">)</span>
            <span class="n">x_scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">inw</span>
            <span class="n">y_scale</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">inh</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">x_scale</span><span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inl</span><span class="o">*</span><span class="n">x_scale</span><span class="p">)],</span>
                                   <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="n">y_scale</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="n">inb</span><span class="o">*</span><span class="n">y_scale</span><span class="p">)],</span>
                                   <span class="p">[</span><span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">0.0</span>    <span class="p">,</span> <span class="mf">1.0</span>        <span class="p">]],</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span></div>
    <span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span></div>


<span class="k">class</span> <span class="nc">ScaledTranslation</span><span class="p">(</span><span class="n">Affine2DBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A transformation that translates by *xt* and *yt*, after *xt* and *yt*</span>
<span class="sd">    have been transformad by the given transform *scale_trans*.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">,</span> <span class="n">scale_trans</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">yt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_trans</span> <span class="o">=</span> <span class="n">scale_trans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">scale_trans</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;ScaledTranslation(</span><span class="si">%r</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">get_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span><span class="p">:</span>
            <span class="n">xt</span><span class="p">,</span> <span class="n">yt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_trans</span><span class="o">.</span><span class="n">transform_point</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">xt</span><span class="p">],</span>
                                   <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">yt</span><span class="p">],</span>
                                   <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]],</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_inverted</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mtx</span>
    <span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">Affine2DBase</span><span class="o">.</span><span class="n">get_matrix</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="TransformedPath"><a class="viewcode-back" href="../../generated/generated/matplotlib.lines.TransformedPath.html#matplotlib.artist.TransformedPath">[docs]</a><span class="k">class</span> <span class="nc">TransformedPath</span><span class="p">(</span><span class="n">TransformNode</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A :class:`TransformedPath` caches a non-affine transformed copy of</span>
<span class="sd">    the :class:`~matplotlib.path.Path`.  This cached copy is</span>
<span class="sd">    automatically updated when the non-affine part of the transform</span>
<span class="sd">    changes.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Paths are considered immutable by this class. Any update to the</span>
<span class="sd">        path&#39;s vertices/codes will not trigger a transform recomputation.</span>

<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TransformedPath.__init__"><a class="viewcode-back" href="../../generated/generated/matplotlib.lines.TransformedPath.__init__.html#matplotlib.artist.TransformedPath.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">transform</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new :class:`TransformedPath` from the given</span>
<span class="sd">        :class:`~matplotlib.path.Path` and :class:`Transform`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transform</span><span class="p">,</span> <span class="n">Transform</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&#39;transform&#39; must be an instance of&quot;</span>
                   <span class="s2">&quot; &#39;matplotlib.transform.Transform&#39;&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">TransformNode</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span> <span class="o">=</span> <span class="n">transform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_children</span><span class="p">(</span><span class="n">transform</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">_revalidate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># only recompute if the invalidation includes the non_affine part of the transform</span>
        <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">INVALID_NON_AFFINE</span><span class="p">)</span>
            <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span> <span class="o">=</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_path_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span> <span class="o">=</span> \
                <span class="n">Path</span><span class="o">.</span><span class="n">_fast_from_codes_and_verts</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_non_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span>
                    <span class="kc">None</span><span class="p">,</span>
                    <span class="p">{</span><span class="s1">&#39;interpolation_steps&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">_interpolation_steps</span><span class="p">,</span>
                     <span class="s1">&#39;should_simplify&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_path</span><span class="o">.</span><span class="n">should_simplify</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_invalid</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="TransformedPath.get_transformed_points_and_affine"><a class="viewcode-back" href="../../generated/generated/matplotlib.lines.TransformedPath.get_transformed_points_and_affine.html#matplotlib.artist.TransformedPath.get_transformed_points_and_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_transformed_points_and_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the child path, with the non-affine part of</span>
<span class="sd">        the transform already applied, along with the affine part of</span>
<span class="sd">        the path necessary to complete the transformation.  Unlike</span>
<span class="sd">        :meth:`get_transformed_path_and_affine`, no interpolation will</span>
<span class="sd">        be performed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_points</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span></div>

<div class="viewcode-block" id="TransformedPath.get_transformed_path_and_affine"><a class="viewcode-back" href="../../generated/generated/matplotlib.lines.TransformedPath.get_transformed_path_and_affine.html#matplotlib.artist.TransformedPath.get_transformed_path_and_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_transformed_path_and_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of the child path, with the non-affine part of</span>
<span class="sd">        the transform already applied, along with the affine part of</span>
<span class="sd">        the path necessary to complete the transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span></div>

<div class="viewcode-block" id="TransformedPath.get_fully_transformed_path"><a class="viewcode-back" href="../../generated/generated/matplotlib.lines.TransformedPath.get_fully_transformed_path.html#matplotlib.artist.TransformedPath.get_fully_transformed_path">[docs]</a>    <span class="k">def</span> <span class="nf">get_fully_transformed_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a fully-transformed copy of the child path.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revalidate</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">transform_path_affine</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transformed_path</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransformedPath.get_affine"><a class="viewcode-back" href="../../generated/generated/matplotlib.lines.TransformedPath.get_affine.html#matplotlib.artist.TransformedPath.get_affine">[docs]</a>    <span class="k">def</span> <span class="nf">get_affine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transform</span><span class="o">.</span><span class="n">get_affine</span><span class="p">()</span></div></div>


<span class="k">def</span> <span class="nf">nonsingular</span><span class="p">(</span><span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">expander</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">tiny</span><span class="o">=</span><span class="mi">1</span><span class="n">e</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="n">increasing</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Modify the endpoints of a range as needed to avoid singularities.</span>

<span class="sd">    *vmin*, *vmax*</span>
<span class="sd">        the initial endpoints.</span>

<span class="sd">    *tiny*</span>
<span class="sd">        threshold for the ratio of the interval to the maximum absolute</span>
<span class="sd">        value of its endpoints.  If the interval is smaller than</span>
<span class="sd">        this, it will be expanded.  This value should be around</span>
<span class="sd">        1e-15 or larger; otherwise the interval will be approaching</span>
<span class="sd">        the double precision resolution limit.</span>

<span class="sd">    *expander*</span>
<span class="sd">        fractional amount by which *vmin* and *vmax* are expanded if</span>
<span class="sd">        the original interval is too small, based on *tiny*.</span>

<span class="sd">    *increasing*: [True | False]</span>
<span class="sd">        If True (default), swap *vmin*, *vmax* if *vmin* &gt; *vmax*</span>

<span class="sd">    Returns *vmin*, *vmax*, expanded and/or swapped if necessary.</span>

<span class="sd">    If either input is inf or NaN, or if both inputs are 0 or very</span>
<span class="sd">    close to zero, it returns -*expander*, *expander*.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmin</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">vmax</span><span class="p">)):</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">expander</span><span class="p">,</span> <span class="n">expander</span>

    <span class="n">swapped</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">vmax</span> <span class="o">&lt;</span> <span class="n">vmin</span><span class="p">:</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
        <span class="n">swapped</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">maxabsvalue</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">vmin</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">vmax</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">maxabsvalue</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span><span class="n">e6</span> <span class="o">/</span> <span class="n">tiny</span><span class="p">)</span> <span class="o">*</span> <span class="n">MINFLOAT</span><span class="p">:</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">expander</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">expander</span>

    <span class="k">elif</span> <span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span> <span class="o">&lt;=</span> <span class="n">maxabsvalue</span> <span class="o">*</span> <span class="n">tiny</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">vmax</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">vmin</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">=</span> <span class="o">-</span><span class="n">expander</span>
            <span class="n">vmax</span> <span class="o">=</span> <span class="n">expander</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">vmin</span> <span class="o">-=</span> <span class="n">expander</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">vmin</span><span class="p">)</span>
            <span class="n">vmax</span> <span class="o">+=</span> <span class="n">expander</span><span class="o">*</span><span class="nb">abs</span><span class="p">(</span><span class="n">vmax</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">swapped</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">increasing</span><span class="p">:</span>
        <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span> <span class="o">=</span> <span class="n">vmax</span><span class="p">,</span> <span class="n">vmin</span>
    <span class="k">return</span> <span class="n">vmin</span><span class="p">,</span> <span class="n">vmax</span>


<span class="k">def</span> <span class="nf">interval_contains</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">interval</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">((</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&gt;=</span> <span class="n">val</span><span class="p">))</span>
        <span class="ow">or</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="n">val</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">val</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">interval_contains_open</span><span class="p">(</span><span class="n">interval</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">interval</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="p">((</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">))</span>
        <span class="ow">or</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">val</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">offset_copy</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">units</span><span class="o">=</span><span class="s1">&#39;inches&#39;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return a new transform with an added offset.</span>
<span class="sd">      args:</span>
<span class="sd">        trans is any transform</span>
<span class="sd">      kwargs:</span>
<span class="sd">        fig is the current figure; it can be None if units are &#39;dots&#39;</span>
<span class="sd">        x, y give the offset</span>
<span class="sd">        units is &#39;inches&#39;, &#39;points&#39; or &#39;dots&#39;</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;dots&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">trans</span> <span class="o">+</span> <span class="n">Affine2D</span><span class="p">()</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;For units of inches or points a fig kwarg is needed&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;points&#39;</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">/=</span> <span class="mf">72.0</span>
        <span class="n">y</span> <span class="o">/=</span> <span class="mf">72.0</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="n">units</span> <span class="o">==</span> <span class="s1">&#39;inches&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;units must be dots, points, or inches&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">trans</span> <span class="o">+</span> <span class="n">ScaledTranslation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">fig</span><span class="o">.</span><span class="n">dpi_scale_trans</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>
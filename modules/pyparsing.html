

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>pyparsing &mdash; PROJECT_NAME 1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="PROJECT_NAME 1 documentation" href="../index.html"/>
        <link rel="up" title="Module code" href="index.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> PROJECT_NAME
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.html">1. matplotlib</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.pyplot.html">2. matplotlib.pyplot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.axes.html">3. matplotlib.axes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.axis.html">4. matplotlib.axis</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.cm.html">5. matplotlib.cm</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.colorbar.html">6. matplotlib.colorbar</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.colors.html">7. matplotlib.colors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.figure.html">8. matplotlib.figure</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.legend.html">9. matplotlib.legend</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.lines.html">10. matplotlib.lines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.markers.html">11. matplotlib.markers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.patches.html">12. matplotlib.patches</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.style.html">13. matplotlib.style</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.text.html">14. matplotlib.text</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.widgets.html">15. matplotlib.widgets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../separator.html">16. ===== INFREQ =====</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.animation.html">17. matplotlib.animation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.artist.html">18. matplotlib.artist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.backends.html">19. matplotlib.backends</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.cbook.html">20. matplotlib.cbook</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.collections.html">21. matplotlib.collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.dates.html">22. matplotlib.dates</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.dviread.html">23. matplotlib.dviread</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.finance.html">24. matplotlib.finance</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.font_manager.html">25. matplotlib.font_manager</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.gridspec.html">26. matplotlib.gridspec</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.image.html">27. matplotlib.image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.mathtext.html">28. matplotlib.mathtext</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.mlab.html">29. matplotlib.mlab</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.offsetbox.html">30. matplotlib.offsetbox</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.path.html">31. matplotlib.path</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.patheffects.html">32. matplotlib.patheffects</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.sankey.html">33. matplotlib.sankey</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.spines.html">34. matplotlib.spines</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.ticker.html">35. matplotlib.ticker</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.tight_layout.html">36. matplotlib.tight_layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.tri.html">37. matplotlib.tri</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.type1font.html">38. matplotlib.type1font</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/matplotlib.units.html">39. matplotlib.units</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PROJECT_NAME</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Module code</a> &raquo;</li>
        
      <li>pyparsing</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for pyparsing</h1><div class="highlight"><pre>
<span></span><span class="c1"># module pyparsing.py</span>
<span class="c1">#</span>
<span class="c1"># Copyright (c) 2003-2015  Paul T. McGuire</span>
<span class="c1">#</span>
<span class="c1"># Permission is hereby granted, free of charge, to any person obtaining</span>
<span class="c1"># a copy of this software and associated documentation files (the</span>
<span class="c1"># &quot;Software&quot;), to deal in the Software without restriction, including</span>
<span class="c1"># without limitation the rights to use, copy, modify, merge, publish,</span>
<span class="c1"># distribute, sublicense, and/or sell copies of the Software, and to</span>
<span class="c1"># permit persons to whom the Software is furnished to do so, subject to</span>
<span class="c1"># the following conditions:</span>
<span class="c1">#</span>
<span class="c1"># The above copyright notice and this permission notice shall be</span>
<span class="c1"># included in all copies or substantial portions of the Software.</span>
<span class="c1">#</span>
<span class="c1"># THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,</span>
<span class="c1"># EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF</span>
<span class="c1"># MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.</span>
<span class="c1"># IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY</span>
<span class="c1"># CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,</span>
<span class="c1"># TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE</span>
<span class="c1"># SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</span>
<span class="c1">#</span>

<span class="n">__doc__</span> <span class="o">=</span> \
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">pyparsing module - Classes and methods to define and execute parsing grammars</span>

<span class="sd">The pyparsing module is an alternative approach to creating and executing simple grammars,</span>
<span class="sd">vs. the traditional lex/yacc approach, or the use of regular expressions.  With pyparsing, you</span>
<span class="sd">don&#39;t need to learn a new syntax for defining grammars or matching expressions - the parsing module</span>
<span class="sd">provides a library of classes that you use to construct the grammar directly in Python.</span>

<span class="sd">Here is a program to parse &quot;Hello, World!&quot; (or any greeting of the form C{&quot;&lt;salutation&gt;, &lt;addressee&gt;!&quot;})::</span>

<span class="sd">    from pyparsing import Word, alphas</span>

<span class="sd">    # define grammar of a greeting</span>
<span class="sd">    greet = Word( alphas ) + &quot;,&quot; + Word( alphas ) + &quot;!&quot;</span>

<span class="sd">    hello = &quot;Hello, World!&quot;</span>
<span class="sd">    print (hello, &quot;-&gt;&quot;, greet.parseString( hello ))</span>

<span class="sd">The program outputs the following::</span>

<span class="sd">    Hello, World! -&gt; [&#39;Hello&#39;, &#39;,&#39;, &#39;World&#39;, &#39;!&#39;]</span>

<span class="sd">The Python representation of the grammar is quite readable, owing to the self-explanatory</span>
<span class="sd">class names, and the use of &#39;+&#39;, &#39;|&#39; and &#39;^&#39; operators.</span>

<span class="sd">The parsed results returned from C{parseString()} can be accessed as a nested list, a dictionary, or an</span>
<span class="sd">object with named attributes.</span>

<span class="sd">The pyparsing module handles some of the problems that are typically vexing when writing text parsers:</span>
<span class="sd"> - extra or missing whitespace (the above program will also handle &quot;Hello,World!&quot;, &quot;Hello  ,  World  !&quot;, etc.)</span>
<span class="sd"> - quoted strings</span>
<span class="sd"> - embedded comments</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;2.1.5&quot;</span>
<span class="n">__versionTime__</span> <span class="o">=</span> <span class="s2">&quot;13 Jun 2016 19:59 UTC&quot;</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Paul McGuire &lt;ptmcg@users.sourceforge.net&gt;&quot;</span>

<span class="kn">import</span> <span class="nn">string</span>
<span class="kn">from</span> <span class="nn">weakref</span> <span class="k">import</span> <span class="n">ref</span> <span class="k">as</span> <span class="n">wkref</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sre_constants</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">pprint</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span>

<span class="c1">#~ sys.stderr.write( &quot;testing pyparsing module, version %s, %s\n&quot; % (__version__,__versionTime__ ) )</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
<span class="s1">&#39;And&#39;</span><span class="p">,</span> <span class="s1">&#39;CaselessKeyword&#39;</span><span class="p">,</span> <span class="s1">&#39;CaselessLiteral&#39;</span><span class="p">,</span> <span class="s1">&#39;CharsNotIn&#39;</span><span class="p">,</span> <span class="s1">&#39;Combine&#39;</span><span class="p">,</span> <span class="s1">&#39;Dict&#39;</span><span class="p">,</span> <span class="s1">&#39;Each&#39;</span><span class="p">,</span> <span class="s1">&#39;Empty&#39;</span><span class="p">,</span>
<span class="s1">&#39;FollowedBy&#39;</span><span class="p">,</span> <span class="s1">&#39;Forward&#39;</span><span class="p">,</span> <span class="s1">&#39;GoToColumn&#39;</span><span class="p">,</span> <span class="s1">&#39;Group&#39;</span><span class="p">,</span> <span class="s1">&#39;Keyword&#39;</span><span class="p">,</span> <span class="s1">&#39;LineEnd&#39;</span><span class="p">,</span> <span class="s1">&#39;LineStart&#39;</span><span class="p">,</span> <span class="s1">&#39;Literal&#39;</span><span class="p">,</span>
<span class="s1">&#39;MatchFirst&#39;</span><span class="p">,</span> <span class="s1">&#39;NoMatch&#39;</span><span class="p">,</span> <span class="s1">&#39;NotAny&#39;</span><span class="p">,</span> <span class="s1">&#39;OneOrMore&#39;</span><span class="p">,</span> <span class="s1">&#39;OnlyOnce&#39;</span><span class="p">,</span> <span class="s1">&#39;Optional&#39;</span><span class="p">,</span> <span class="s1">&#39;Or&#39;</span><span class="p">,</span>
<span class="s1">&#39;ParseBaseException&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseElementEnhance&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseException&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseExpression&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseFatalException&#39;</span><span class="p">,</span>
<span class="s1">&#39;ParseResults&#39;</span><span class="p">,</span> <span class="s1">&#39;ParseSyntaxException&#39;</span><span class="p">,</span> <span class="s1">&#39;ParserElement&#39;</span><span class="p">,</span> <span class="s1">&#39;QuotedString&#39;</span><span class="p">,</span> <span class="s1">&#39;RecursiveGrammarException&#39;</span><span class="p">,</span>
<span class="s1">&#39;Regex&#39;</span><span class="p">,</span> <span class="s1">&#39;SkipTo&#39;</span><span class="p">,</span> <span class="s1">&#39;StringEnd&#39;</span><span class="p">,</span> <span class="s1">&#39;StringStart&#39;</span><span class="p">,</span> <span class="s1">&#39;Suppress&#39;</span><span class="p">,</span> <span class="s1">&#39;Token&#39;</span><span class="p">,</span> <span class="s1">&#39;TokenConverter&#39;</span><span class="p">,</span> 
<span class="s1">&#39;White&#39;</span><span class="p">,</span> <span class="s1">&#39;Word&#39;</span><span class="p">,</span> <span class="s1">&#39;WordEnd&#39;</span><span class="p">,</span> <span class="s1">&#39;WordStart&#39;</span><span class="p">,</span> <span class="s1">&#39;ZeroOrMore&#39;</span><span class="p">,</span>
<span class="s1">&#39;alphanums&#39;</span><span class="p">,</span> <span class="s1">&#39;alphas&#39;</span><span class="p">,</span> <span class="s1">&#39;alphas8bit&#39;</span><span class="p">,</span> <span class="s1">&#39;anyCloseTag&#39;</span><span class="p">,</span> <span class="s1">&#39;anyOpenTag&#39;</span><span class="p">,</span> <span class="s1">&#39;cStyleComment&#39;</span><span class="p">,</span> <span class="s1">&#39;col&#39;</span><span class="p">,</span>
<span class="s1">&#39;commaSeparatedList&#39;</span><span class="p">,</span> <span class="s1">&#39;commonHTMLEntity&#39;</span><span class="p">,</span> <span class="s1">&#39;countedArray&#39;</span><span class="p">,</span> <span class="s1">&#39;cppStyleComment&#39;</span><span class="p">,</span> <span class="s1">&#39;dblQuotedString&#39;</span><span class="p">,</span>
<span class="s1">&#39;dblSlashComment&#39;</span><span class="p">,</span> <span class="s1">&#39;delimitedList&#39;</span><span class="p">,</span> <span class="s1">&#39;dictOf&#39;</span><span class="p">,</span> <span class="s1">&#39;downcaseTokens&#39;</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="s1">&#39;hexnums&#39;</span><span class="p">,</span>
<span class="s1">&#39;htmlComment&#39;</span><span class="p">,</span> <span class="s1">&#39;javaStyleComment&#39;</span><span class="p">,</span> <span class="s1">&#39;line&#39;</span><span class="p">,</span> <span class="s1">&#39;lineEnd&#39;</span><span class="p">,</span> <span class="s1">&#39;lineStart&#39;</span><span class="p">,</span> <span class="s1">&#39;lineno&#39;</span><span class="p">,</span>
<span class="s1">&#39;makeHTMLTags&#39;</span><span class="p">,</span> <span class="s1">&#39;makeXMLTags&#39;</span><span class="p">,</span> <span class="s1">&#39;matchOnlyAtCol&#39;</span><span class="p">,</span> <span class="s1">&#39;matchPreviousExpr&#39;</span><span class="p">,</span> <span class="s1">&#39;matchPreviousLiteral&#39;</span><span class="p">,</span>
<span class="s1">&#39;nestedExpr&#39;</span><span class="p">,</span> <span class="s1">&#39;nullDebugAction&#39;</span><span class="p">,</span> <span class="s1">&#39;nums&#39;</span><span class="p">,</span> <span class="s1">&#39;oneOf&#39;</span><span class="p">,</span> <span class="s1">&#39;opAssoc&#39;</span><span class="p">,</span> <span class="s1">&#39;operatorPrecedence&#39;</span><span class="p">,</span> <span class="s1">&#39;printables&#39;</span><span class="p">,</span>
<span class="s1">&#39;punc8bit&#39;</span><span class="p">,</span> <span class="s1">&#39;pythonStyleComment&#39;</span><span class="p">,</span> <span class="s1">&#39;quotedString&#39;</span><span class="p">,</span> <span class="s1">&#39;removeQuotes&#39;</span><span class="p">,</span> <span class="s1">&#39;replaceHTMLEntity&#39;</span><span class="p">,</span> 
<span class="s1">&#39;replaceWith&#39;</span><span class="p">,</span> <span class="s1">&#39;restOfLine&#39;</span><span class="p">,</span> <span class="s1">&#39;sglQuotedString&#39;</span><span class="p">,</span> <span class="s1">&#39;srange&#39;</span><span class="p">,</span> <span class="s1">&#39;stringEnd&#39;</span><span class="p">,</span>
<span class="s1">&#39;stringStart&#39;</span><span class="p">,</span> <span class="s1">&#39;traceParseAction&#39;</span><span class="p">,</span> <span class="s1">&#39;unicodeString&#39;</span><span class="p">,</span> <span class="s1">&#39;upcaseTokens&#39;</span><span class="p">,</span> <span class="s1">&#39;withAttribute&#39;</span><span class="p">,</span>
<span class="s1">&#39;indentedBlock&#39;</span><span class="p">,</span> <span class="s1">&#39;originalTextFor&#39;</span><span class="p">,</span> <span class="s1">&#39;ungroup&#39;</span><span class="p">,</span> <span class="s1">&#39;infixNotation&#39;</span><span class="p">,</span><span class="s1">&#39;locatedExpr&#39;</span><span class="p">,</span> <span class="s1">&#39;withClass&#39;</span><span class="p">,</span>
<span class="s1">&#39;tokenMap&#39;</span><span class="p">,</span> <span class="s1">&#39;pyparsing_common&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="n">system_version</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">)[:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">PY_3</span> <span class="o">=</span> <span class="n">system_version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>
<span class="k">if</span> <span class="n">PY_3</span><span class="p">:</span>
    <span class="n">_MAX_INT</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
    <span class="n">basestring</span> <span class="o">=</span> <span class="nb">str</span>
    <span class="n">unichr</span> <span class="o">=</span> <span class="nb">chr</span>
    <span class="n">_ustr</span> <span class="o">=</span> <span class="nb">str</span>

    <span class="c1"># build list of single arg builtins, that can be used as parse actions</span>
    <span class="n">singleArgBuiltins</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sum</span><span class="p">,</span> <span class="nb">len</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">,</span> <span class="nb">reversed</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">set</span><span class="p">,</span> <span class="nb">any</span><span class="p">,</span> <span class="nb">all</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">]</span>

<span class="k">else</span><span class="p">:</span>
    <span class="n">_MAX_INT</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxint</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="n">xrange</span>

    <span class="k">def</span> <span class="nf">_ustr</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Drop-in replacement for str(obj) that tries to be Unicode friendly. It first tries</span>
<span class="sd">           str(obj). If that fails with a UnicodeEncodeError, then it tries unicode(obj). It</span>
<span class="sd">           then &lt; returns the unicode object | encodes it with the default encoding | ... &gt;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span><span class="n">unicode</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">obj</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># If this works, then _ustr(obj) has the same behaviour as str(obj), so</span>
            <span class="c1"># it won&#39;t break any existing code.</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">except</span> <span class="ne">UnicodeEncodeError</span><span class="p">:</span>
            <span class="c1"># Else encode it</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">unicode</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">getdefaultencoding</span><span class="p">(),</span> <span class="s1">&#39;xmlcharrefreplace&#39;</span><span class="p">)</span>
            <span class="n">xmlcharref</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">&#39;&amp;#\d+;&#39;</span><span class="p">)</span>
            <span class="n">xmlcharref</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">u&#39;</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">2</span><span class="p">:])</span>
            <span class="k">return</span> <span class="n">xmlcharref</span><span class="o">.</span><span class="n">transformString</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

    <span class="c1"># build list of single arg builtins, tolerant of Python version, that can be used as parse actions</span>
    <span class="n">singleArgBuiltins</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="kn">import</span> <span class="nn">__builtin__</span>
    <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="s2">&quot;sum len sorted reversed list tuple set any all min max&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">singleArgBuiltins</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">__builtin__</span><span class="p">,</span><span class="n">fname</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">continue</span>
            
<span class="n">_generatorType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">((</span><span class="n">y</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
 
<span class="k">def</span> <span class="nf">_xml_escape</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Escape &amp;, &lt;, &gt;, &quot;, &#39;, etc. in a string of data.&quot;&quot;&quot;</span>

    <span class="c1"># ampersand must be replaced first</span>
    <span class="n">from_symbols</span> <span class="o">=</span> <span class="s1">&#39;&amp;&gt;&lt;&quot;</span><span class="se">\&#39;</span><span class="s1">&#39;</span>
    <span class="n">to_symbols</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="o">+</span><span class="n">s</span><span class="o">+</span><span class="s1">&#39;;&#39;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="s2">&quot;amp gt lt quot apos&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">from_</span><span class="p">,</span><span class="n">to_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">from_symbols</span><span class="p">,</span> <span class="n">to_symbols</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">from_</span><span class="p">,</span> <span class="n">to_</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span>

<span class="k">class</span> <span class="nc">_Constants</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="n">alphas</span>     <span class="o">=</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_uppercase</span> <span class="o">+</span> <span class="n">string</span><span class="o">.</span><span class="n">ascii_lowercase</span>
<span class="n">nums</span>       <span class="o">=</span> <span class="s2">&quot;0123456789&quot;</span>
<span class="n">hexnums</span>    <span class="o">=</span> <span class="n">nums</span> <span class="o">+</span> <span class="s2">&quot;ABCDEFabcdef&quot;</span>
<span class="n">alphanums</span>  <span class="o">=</span> <span class="n">alphas</span> <span class="o">+</span> <span class="n">nums</span>
<span class="n">_bslash</span>    <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="mi">92</span><span class="p">)</span>
<span class="n">printables</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">printable</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">string</span><span class="o">.</span><span class="n">whitespace</span><span class="p">)</span>

<div class="viewcode-block" id="ParseBaseException"><a class="viewcode-back" href="../generated/matplotlib.mathtext.ParseBaseException.html#matplotlib.mathtext.ParseBaseException">[docs]</a><span class="k">class</span> <span class="nc">ParseBaseException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;base exception class for all parsing runtime exceptions&quot;&quot;&quot;</span>
    <span class="c1"># Performance tuning: we construct a *lot* of these, so keep this</span>
    <span class="c1"># constructor as small and fast as possible</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pstr</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">msg</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">elem</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">pstr</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="n">msg</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span> <span class="o">=</span> <span class="n">pstr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parserElement</span> <span class="o">=</span> <span class="n">elem</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">aname</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;supported attributes by name are:</span>
<span class="sd">            - lineno - returns the line number of the exception text</span>
<span class="sd">            - col - returns the column number of the exception text</span>
<span class="sd">            - line - returns the line containing the exception text</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span><span class="p">(</span> <span class="n">aname</span> <span class="o">==</span> <span class="s2">&quot;lineno&quot;</span> <span class="p">):</span>
            <span class="k">return</span> <span class="n">lineno</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span> <span class="p">)</span>
        <span class="k">elif</span><span class="p">(</span> <span class="n">aname</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;col&quot;</span><span class="p">,</span> <span class="s2">&quot;column&quot;</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">return</span> <span class="n">col</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span> <span class="p">)</span>
        <span class="k">elif</span><span class="p">(</span> <span class="n">aname</span> <span class="o">==</span> <span class="s2">&quot;line&quot;</span> <span class="p">):</span>
            <span class="k">return</span> <span class="n">line</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pstr</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">aname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> (at char </span><span class="si">%d</span><span class="s2">), (line:</span><span class="si">%d</span><span class="s2">, col:</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> \
                <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">msg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">markInputline</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">markerString</span> <span class="o">=</span> <span class="s2">&quot;&gt;!&lt;&quot;</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extracts the exception line from the input string, and marks</span>
<span class="sd">           the location of the exception with a special symbol.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">line_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span>
        <span class="n">line_column</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">markerString</span><span class="p">:</span>
            <span class="n">line_str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">line_str</span><span class="p">[:</span><span class="n">line_column</span><span class="p">],</span>
                                <span class="n">markerString</span><span class="p">,</span> <span class="n">line_str</span><span class="p">[</span><span class="n">line_column</span><span class="p">:]))</span>
        <span class="k">return</span> <span class="n">line_str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;lineno col line&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="o">+</span> <span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

<div class="viewcode-block" id="ParseException"><a class="viewcode-back" href="../generated/matplotlib.mathtext.ParseException.html#matplotlib.mathtext.ParseException">[docs]</a><span class="k">class</span> <span class="nc">ParseException</span><span class="p">(</span><span class="n">ParseBaseException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;exception thrown when parse expressions don&#39;t match class;</span>
<span class="sd">       supported attributes by name are:</span>
<span class="sd">        - lineno - returns the line number of the exception text</span>
<span class="sd">        - col - returns the column number of the exception text</span>
<span class="sd">        - line - returns the line containing the exception text</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="ParseFatalException"><a class="viewcode-back" href="../generated/matplotlib.mathtext.ParseFatalException.html#matplotlib.mathtext.ParseFatalException">[docs]</a><span class="k">class</span> <span class="nc">ParseFatalException</span><span class="p">(</span><span class="n">ParseBaseException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;user-throwable exception thrown when inconsistent parse content</span>
<span class="sd">       is found; stops all parsing immediately&quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

<span class="k">class</span> <span class="nc">ParseSyntaxException</span><span class="p">(</span><span class="n">ParseFatalException</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;just like C{L{ParseFatalException}}, but thrown internally when an</span>
<span class="sd">       C{L{ErrorStop&lt;And._ErrorStop&gt;}} (&#39;-&#39; operator) indicates that parsing is to stop immediately because</span>
<span class="sd">       an unbacktrackable syntax error has been found&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pe</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParseSyntaxException</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
                                    <span class="n">pe</span><span class="o">.</span><span class="n">pstr</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">msg</span><span class="p">,</span> <span class="n">pe</span><span class="o">.</span><span class="n">parserElement</span><span class="p">)</span>

<span class="c1">#~ class ReparseException(ParseBaseException):</span>
    <span class="c1">#~ &quot;&quot;&quot;Experimental class - parse actions can raise this exception to cause</span>
       <span class="c1">#~ pyparsing to reparse the input string:</span>
        <span class="c1">#~ - with a modified input string, and/or</span>
        <span class="c1">#~ - with a modified start location</span>
       <span class="c1">#~ Set the values of the ReparseException in the constructor, and raise the</span>
       <span class="c1">#~ exception in a parse action to cause pyparsing to use the new string/location.</span>
       <span class="c1">#~ Setting the values as None causes no change to be made.</span>
       <span class="c1">#~ &quot;&quot;&quot;</span>
    <span class="c1">#~ def __init_( self, newstring, restartLoc ):</span>
        <span class="c1">#~ self.newParseText = newstring</span>
        <span class="c1">#~ self.reparseLoc = restartLoc</span>

<span class="k">class</span> <span class="nc">RecursiveGrammarException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;exception thrown by C{validate()} if the grammar could be improperly recursive&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseElementTrace</span> <span class="o">=</span> <span class="n">parseElementList</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;RecursiveGrammarException: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseElementTrace</span>

<span class="k">class</span> <span class="nc">_ParseResultsWithOffset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tup</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tup</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">setOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">)</span>

<div class="viewcode-block" id="ParseResults"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.html#matplotlib.mathtext.ParseResults">[docs]</a><span class="k">class</span> <span class="nc">ParseResults</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Structured parse results, to provide multiple means of access to the parsed data:</span>
<span class="sd">       - as a list (C{len(results)})</span>
<span class="sd">       - by list index (C{results[0], results[1]}, etc.)</span>
<span class="sd">       - by attribute (C{results.&lt;resultsName&gt;})</span>
<span class="sd">       &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">toklist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asList</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">modal</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">toklist</span>
        <span class="n">retobj</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">retobj</span><span class="o">.</span><span class="n">__doinit</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">retobj</span>

    <span class="c1"># Performance tuning: we construct a *lot* of these, so keep this</span>
    <span class="c1"># constructor as small and fast as possible</span>
<div class="viewcode-block" id="ParseResults.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.__init__.html#matplotlib.mathtext.ParseResults.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">toklist</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">asList</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">modal</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="nb">isinstance</span><span class="o">=</span><span class="nb">isinstance</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__doinit</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__doinit</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__asList</span> <span class="o">=</span> <span class="n">asList</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__modal</span> <span class="o">=</span> <span class="n">modal</span>
            <span class="k">if</span> <span class="n">toklist</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">toklist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">=</span> <span class="n">toklist</span><span class="p">[:]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="n">_generatorType</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">toklist</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">=</span> <span class="p">[</span><span class="n">toklist</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">name</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">modal</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="c1"># will always return a str, but use _ustr for consistency</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="n">basestring</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="n">toklist</span> <span class="ow">in</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">,[])):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span><span class="n">basestring</span><span class="p">):</span>
                    <span class="n">toklist</span> <span class="o">=</span> <span class="p">[</span> <span class="n">toklist</span> <span class="p">]</span>
                <span class="k">if</span> <span class="n">asList</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toklist</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">):</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">toklist</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">ParseResults</span><span class="p">(</span><span class="n">toklist</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="mi">0</span><span class="p">)</span>
                    <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="n">name</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">toklist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span><span class="ne">TypeError</span><span class="p">,</span><span class="ne">IndexError</span><span class="p">):</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">toklist</span></div>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">i</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">slice</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ParseResults</span><span class="p">([</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">])</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="nb">isinstance</span><span class="o">=</span><span class="nb">isinstance</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">_ParseResultsWithOffset</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="nb">list</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="n">v</span><span class="p">]</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,(</span><span class="nb">int</span><span class="p">,</span><span class="nb">slice</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="nb">list</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">):</span>
            <span class="n">sub</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="n">wkref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">i</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,(</span><span class="nb">int</span><span class="p">,</span><span class="nb">slice</span><span class="p">)):</span>
            <span class="n">mylen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># convert int to slice</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="n">mylen</span>
                <span class="n">i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># get removed indices</span>
            <span class="n">removed</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">mylen</span><span class="p">)))</span>
            <span class="n">removed</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="c1"># fixup indices in token dictionary</span>
            <span class="c1">#~ for name in self.__tokdict:</span>
                <span class="c1">#~ occurrences = self.__tokdict[name]</span>
                <span class="c1">#~ for j in removed:</span>
                    <span class="c1">#~ for k, (value, position) in enumerate(occurrences):</span>
                        <span class="c1">#~ occurrences[k] = _ParseResultsWithOffset(value, position - (position &gt; j))</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">occurrences</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">removed</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">occurrences</span><span class="p">):</span>
                        <span class="n">occurrences</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">-</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">k</span> <span class="p">):</span>
        <span class="k">return</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span> <span class="ow">not</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="p">)</span>
    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="n">__bool__</span>
    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">__reversed__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span> <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">def</span> <span class="nf">_iterkeys</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">,</span> <span class="s2">&quot;iterkeys&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_itervalues</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iterkeys</span><span class="p">())</span>
            
    <span class="k">def</span> <span class="nf">_iteritems</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iterkeys</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">PY_3</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">_iterkeys</span>       
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result keys (Python 3.x only).&quot;&quot;&quot;</span>

        <span class="n">values</span> <span class="o">=</span> <span class="n">_itervalues</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result values (Python 3.x only).&quot;&quot;&quot;</span>

        <span class="n">items</span> <span class="o">=</span> <span class="n">_iteritems</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result key-value tuples (Python 3.x only).&quot;&quot;&quot;</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">iterkeys</span> <span class="o">=</span> <span class="n">_iterkeys</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result keys (Python 2.x only).&quot;&quot;&quot;</span>

        <span class="n">itervalues</span> <span class="o">=</span> <span class="n">_itervalues</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result values (Python 2.x only).&quot;&quot;&quot;</span>

        <span class="n">iteritems</span> <span class="o">=</span> <span class="n">_iteritems</span>
        <span class="sd">&quot;&quot;&quot;Returns an iterator of all named result key-value tuples (Python 2.x only).&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ParseResults.keys"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.keys.html#matplotlib.mathtext.ParseResults.keys">[docs]</a>        <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns all named result keys (as a list in Python 2.x, as an iterator in Python 3.x).&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iterkeys</span><span class="p">())</span></div>

<div class="viewcode-block" id="ParseResults.values"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.values.html#matplotlib.mathtext.ParseResults.values">[docs]</a>        <span class="k">def</span> <span class="nf">values</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns all named result values (as a list in Python 2.x, as an iterator in Python 3.x).&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">itervalues</span><span class="p">())</span></div>
                
<div class="viewcode-block" id="ParseResults.items"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.items.html#matplotlib.mathtext.ParseResults.items">[docs]</a>        <span class="k">def</span> <span class="nf">items</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Returns all named result key-values (as a list of tuples in Python 2.x, as an iterator in Python 3.x).&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span><span class="p">())</span></div>

<div class="viewcode-block" id="ParseResults.haskeys"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.haskeys.html#matplotlib.mathtext.ParseResults.haskeys">[docs]</a>    <span class="k">def</span> <span class="nf">haskeys</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Since keys() returns an iterator, this method is helpful in bypassing</span>
<span class="sd">           code that looks for the existence of any defined results names.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ParseResults.pop"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.pop.html#matplotlib.mathtext.ParseResults.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Removes and returns item at specified index (default=last).</span>
<span class="sd">           Supports both list and dict semantics for pop(). If passed no</span>
<span class="sd">           argument or an integer argument, it will use list semantics</span>
<span class="sd">           and pop tokens from the list of parsed tokens. If passed a </span>
<span class="sd">           non-integer argument (most likely a string), it will use dict</span>
<span class="sd">           semantics and pop the corresponding value from any defined </span>
<span class="sd">           results names. A second default return value argument is </span>
<span class="sd">           supported, just as in dict.pop().&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;pop() got an unexpected keyword argument &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> 
                        <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> 
                        <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">defaultvalue</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">defaultvalue</span></div>

<div class="viewcode-block" id="ParseResults.get"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.get.html#matplotlib.mathtext.ParseResults.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">defaultValue</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns named result matching the given key, or if there is no</span>
<span class="sd">           such name, then returns the given C{defaultValue} or C{None} if no</span>
<span class="sd">           C{defaultValue} is specified.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">defaultValue</span></div>

<div class="viewcode-block" id="ParseResults.insert"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.insert.html#matplotlib.mathtext.ParseResults.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">insStr</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Inserts new element at location index in the list of parsed tokens.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">insStr</span><span class="p">)</span>
        <span class="c1"># fixup indices in token dictionary</span>
        <span class="c1">#~ for name in self.__tokdict:</span>
            <span class="c1">#~ occurrences = self.__tokdict[name]</span>
            <span class="c1">#~ for k, (value, position) in enumerate(occurrences):</span>
                <span class="c1">#~ occurrences[k] = _ParseResultsWithOffset(value, position + (position &gt; index))</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">occurrences</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">position</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">occurrences</span><span class="p">):</span>
                <span class="n">occurrences</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">position</span> <span class="o">+</span> <span class="p">(</span><span class="n">position</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">))</span></div>

<div class="viewcode-block" id="ParseResults.append"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.append.html#matplotlib.mathtext.ParseResults.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">item</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add single element to end of ParseResults list of elements.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParseResults.extend"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.extend.html#matplotlib.mathtext.ParseResults.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">itemseq</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add sequence of elements to end of ParseResults list of elements.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">itemseq</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
            <span class="bp">self</span> <span class="o">+=</span> <span class="n">itemseq</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">itemseq</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParseResults.clear"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.clear.html#matplotlib.mathtext.ParseResults.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clear all elements and results names.&quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>
            
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ParseResults</span><span class="p">([</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">+=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">other</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">)</span>
            <span class="n">addoffset</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">offset</span> <span class="k">if</span> <span class="n">a</span><span class="o">&lt;</span><span class="mi">0</span> <span class="k">else</span> <span class="n">a</span><span class="o">+</span><span class="n">offset</span>
            <span class="n">otheritems</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="n">otherdictitems</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">addoffset</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">)</span>
                                <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">vlist</span><span class="p">)</span> <span class="ow">in</span> <span class="n">otheritems</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">otherdictitems</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ParseResults</span><span class="p">):</span>
                    <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="n">wkref</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            
        <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">__toklist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="n">other</span><span class="o">.</span><span class="n">__accumNames</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># useful for merging many ParseResults using sum() builtin</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># this may raise a TypeError - so be it</span>
            <span class="k">return</span> <span class="n">other</span> <span class="o">+</span> <span class="bp">self</span>
        
    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;(</span><span class="si">%s</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="nb">repr</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="p">),</span> <span class="nb">repr</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;[&#39;</span> <span class="o">+</span> <span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">)</span> <span class="k">else</span> <span class="nb">repr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;]&#39;</span>

    <span class="k">def</span> <span class="nf">_asStringList</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">and</span> <span class="n">sep</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">item</span><span class="p">,</span> <span class="n">ParseResults</span> <span class="p">):</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="n">item</span><span class="o">.</span><span class="n">_asStringList</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="ParseResults.asList"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.asList.html#matplotlib.mathtext.ParseResults.asList">[docs]</a>    <span class="k">def</span> <span class="nf">asList</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the parse results as a nested list of matching tokens, all converted to strings.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">res</span><span class="o">.</span><span class="n">asList</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">)</span> <span class="k">else</span> <span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">]</span></div>

<div class="viewcode-block" id="ParseResults.asDict"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.asDict.html#matplotlib.mathtext.ParseResults.asDict">[docs]</a>    <span class="k">def</span> <span class="nf">asDict</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the named parse results as a nested dictionary.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">PY_3</span><span class="p">:</span>
            <span class="n">item_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">items</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">item_fn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteritems</span>
            
        <span class="k">def</span> <span class="nf">toItem</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ParseResults</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
                    <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">asDict</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">toItem</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">obj</span>
                
        <span class="k">return</span> <span class="nb">dict</span><span class="p">((</span><span class="n">k</span><span class="p">,</span><span class="n">toItem</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">item_fn</span><span class="p">())</span></div>

<div class="viewcode-block" id="ParseResults.copy"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.copy.html#matplotlib.mathtext.ParseResults.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a new copy of a C{ParseResults} object.&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">__tokdict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">__accumNames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span> <span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">__name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="ParseResults.asXML"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.asXML.html#matplotlib.mathtext.ParseResults.asXML">[docs]</a>    <span class="k">def</span> <span class="nf">asXML</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">doctag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">namedItemsOnly</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">formatted</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the parse results as XML. Tags are created for tokens and lists that have defined results names.&quot;&quot;&quot;</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">namedItems</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">vlist</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                                                            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">)</span>
        <span class="n">nextLevelIndent</span> <span class="o">=</span> <span class="n">indent</span> <span class="o">+</span> <span class="s2">&quot;  &quot;</span>

        <span class="c1"># collapse out indents if formatting is not desired</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">formatted</span><span class="p">:</span>
            <span class="n">indent</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">nextLevelIndent</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">nl</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">selfTag</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">doctag</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">selfTag</span> <span class="o">=</span> <span class="n">doctag</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">:</span>
                <span class="n">selfTag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">selfTag</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">namedItemsOnly</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">selfTag</span> <span class="o">=</span> <span class="s2">&quot;ITEM&quot;</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">nl</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">selfTag</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span> <span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">res</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">namedItems</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">res</span><span class="o">.</span><span class="n">asXML</span><span class="p">(</span><span class="n">namedItems</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                                        <span class="n">namedItemsOnly</span> <span class="ow">and</span> <span class="n">doctag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">nextLevelIndent</span><span class="p">,</span>
                                        <span class="n">formatted</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">res</span><span class="o">.</span><span class="n">asXML</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span>
                                        <span class="n">namedItemsOnly</span> <span class="ow">and</span> <span class="n">doctag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
                                        <span class="n">nextLevelIndent</span><span class="p">,</span>
                                        <span class="n">formatted</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># individual token, see if there is a name for it</span>
                <span class="n">resTag</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">namedItems</span><span class="p">:</span>
                    <span class="n">resTag</span> <span class="o">=</span> <span class="n">namedItems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">resTag</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">namedItemsOnly</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">resTag</span> <span class="o">=</span> <span class="s2">&quot;ITEM&quot;</span>
                <span class="n">xmlBodyText</span> <span class="o">=</span> <span class="n">_xml_escape</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">nl</span><span class="p">,</span> <span class="n">nextLevelIndent</span><span class="p">,</span> <span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">resTag</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">,</span>
                                                <span class="n">xmlBodyText</span><span class="p">,</span>
                                                <span class="s2">&quot;&lt;/&quot;</span><span class="p">,</span> <span class="n">resTag</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span> <span class="p">]</span>

        <span class="n">out</span> <span class="o">+=</span> <span class="p">[</span> <span class="n">nl</span><span class="p">,</span> <span class="n">indent</span><span class="p">,</span> <span class="s2">&quot;&lt;/&quot;</span><span class="p">,</span> <span class="n">selfTag</span><span class="p">,</span> <span class="s2">&quot;&gt;&quot;</span> <span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sub</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">vlist</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">v</span><span class="p">,</span><span class="n">loc</span> <span class="ow">in</span> <span class="n">vlist</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sub</span> <span class="ow">is</span> <span class="n">v</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">k</span>
        <span class="k">return</span> <span class="kc">None</span>

<div class="viewcode-block" id="ParseResults.getName"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.getName.html#matplotlib.mathtext.ParseResults.getName">[docs]</a>    <span class="k">def</span> <span class="nf">getName</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the results name for this token expression.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span><span class="p">:</span>
            <span class="n">par</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">par</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">par</span><span class="o">.</span><span class="n">__lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
               <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
               <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">values</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">keys</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="ParseResults.dump"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.dump.html#matplotlib.mathtext.ParseResults.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">indent</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span><span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Diagnostic method for listing out the contents of a C{ParseResults}.</span>
<span class="sd">           Accepts an optional C{indent} argument so that this string can be embedded</span>
<span class="sd">           in a nested display of other data.&quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">NL</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">indent</span><span class="o">+</span><span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asList</span><span class="p">())</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
            <span class="n">items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">out</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NL</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2">- </span><span class="si">%s</span><span class="s2">: &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,(</span><span class="s1">&#39;  &#39;</span><span class="o">*</span><span class="n">depth</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">v</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">v</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">,</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">)</span> <span class="k">for</span> <span class="n">vv</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">vv</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vv</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">):</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]:</span><span class="se">\n</span><span class="si">%s%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,(</span><span class="s1">&#39;  &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">depth</span><span class="p">)),</span><span class="n">i</span><span class="p">,</span><span class="n">indent</span><span class="p">,(</span><span class="s1">&#39;  &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span><span class="n">vv</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">indent</span><span class="p">,</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">%s%s</span><span class="s2">[</span><span class="si">%d</span><span class="s2">]:</span><span class="se">\n</span><span class="si">%s%s%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">indent</span><span class="p">,(</span><span class="s1">&#39;  &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">depth</span><span class="p">)),</span><span class="n">i</span><span class="p">,</span><span class="n">indent</span><span class="p">,(</span><span class="s1">&#39;  &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">depth</span><span class="o">+</span><span class="mi">1</span><span class="p">)),</span><span class="n">_ustr</span><span class="p">(</span><span class="n">vv</span><span class="p">)))</span>
            
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="ParseResults.pprint"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParseResults.pprint.html#matplotlib.mathtext.ParseResults.pprint">[docs]</a>    <span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pretty-printer for parsed results as a list, using the C{pprint} module.</span>
<span class="sd">           Accepts additional positional or keyword args as defined for the </span>
<span class="sd">           C{pprint.pprint} method. (U{http://docs.python.org/3/library/pprint.html#pprint.pprint})&quot;&quot;&quot;</span>
        <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">asList</span><span class="p">(),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="c1"># add support for pickle protocol</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">,</span>
                 <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span><span class="p">()</span> <span class="ow">or</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="p">,</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">__name</span> <span class="p">)</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">state</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__tokdict</span><span class="p">,</span>
         <span class="n">par</span><span class="p">,</span>
         <span class="n">inAccumNames</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__accumNames</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">inAccumNames</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">par</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="n">wkref</span><span class="p">(</span><span class="n">par</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__parent</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__toklist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__asList</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__modal</span>

    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">dir</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span></div>

<span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ParseResults</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">col</span> <span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="n">strg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns current column within a string, counting newlines as line separators.</span>
<span class="sd">   The first column is number 1.</span>

<span class="sd">   Note: the default parsing behavior is to expand tabs in the input string</span>
<span class="sd">   before starting the parsing process.  See L{I{ParserElement.parseString}&lt;ParserElement.parseString&gt;} for more information</span>
<span class="sd">   on parsing strings containing C{&lt;TAB&gt;}s, and suggested methods to maintain a</span>
<span class="sd">   consistent view of the parsed string, the parse location, and line and column</span>
<span class="sd">   positions within the parsed string.</span>
<span class="sd">   &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">strg</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">loc</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="k">else</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">s</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">lineno</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="n">strg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns current line number within a string, counting newlines as line separators.</span>
<span class="sd">   The first line is number 1.</span>

<span class="sd">   Note: the default parsing behavior is to expand tabs in the input string</span>
<span class="sd">   before starting the parsing process.  See L{I{ParserElement.parseString}&lt;ParserElement.parseString&gt;} for more information</span>
<span class="sd">   on parsing strings containing C{&lt;TAB&gt;}s, and suggested methods to maintain a</span>
<span class="sd">   consistent view of the parsed string, the parse location, and line and column</span>
<span class="sd">   positions within the parsed string.</span>
<span class="sd">   &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">strg</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">loc</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">line</span><span class="p">(</span> <span class="n">loc</span><span class="p">,</span> <span class="n">strg</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the line of text containing loc within a string, counting newlines as line separators.</span>
<span class="sd">       &quot;&quot;&quot;</span>
    <span class="n">lastCR</span> <span class="o">=</span> <span class="n">strg</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
    <span class="n">nextCR</span> <span class="o">=</span> <span class="n">strg</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nextCR</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">strg</span><span class="p">[</span><span class="n">lastCR</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">nextCR</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">strg</span><span class="p">[</span><span class="n">lastCR</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">_defaultStartDebugAction</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">expr</span> <span class="p">):</span>
    <span class="nb">print</span> <span class="p">((</span><span class="s2">&quot;Match &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; at loc &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;(</span><span class="si">%d</span><span class="s2">,</span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">lineno</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="n">instring</span><span class="p">),</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="n">instring</span><span class="p">)</span> <span class="p">)))</span>

<span class="k">def</span> <span class="nf">_defaultSuccessDebugAction</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">startloc</span><span class="p">,</span> <span class="n">endloc</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">toks</span> <span class="p">):</span>
    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Matched &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; -&gt; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">toks</span><span class="o">.</span><span class="n">asList</span><span class="p">()))</span>

<span class="k">def</span> <span class="nf">_defaultExceptionDebugAction</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">exc</span> <span class="p">):</span>
    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Exception raised:&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">exc</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">nullDebugAction</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&#39;Do-nothing&#39; debug action, to suppress debugging output during parsing.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="c1"># Only works on Python 3.x - nonlocal is toxic to Python 2 installs</span>
<span class="c1">#~ &#39;decorator to trim function calls to match the arity of the target&#39;</span>
<span class="c1">#~ def _trim_arity(func, maxargs=3):</span>
    <span class="c1">#~ if func in singleArgBuiltins:</span>
        <span class="c1">#~ return lambda s,l,t: func(t)</span>
    <span class="c1">#~ limit = 0</span>
    <span class="c1">#~ foundArity = False</span>
    <span class="c1">#~ def wrapper(*args):</span>
        <span class="c1">#~ nonlocal limit,foundArity</span>
        <span class="c1">#~ while 1:</span>
            <span class="c1">#~ try:</span>
                <span class="c1">#~ ret = func(*args[limit:])</span>
                <span class="c1">#~ foundArity = True</span>
                <span class="c1">#~ return ret</span>
            <span class="c1">#~ except TypeError:</span>
                <span class="c1">#~ if limit == maxargs or foundArity:</span>
                    <span class="c1">#~ raise</span>
                <span class="c1">#~ limit += 1</span>
                <span class="c1">#~ continue</span>
    <span class="c1">#~ return wrapper</span>

<span class="c1"># this version is Python 2.x-3.x cross-compatible</span>
<span class="s1">&#39;decorator to trim function calls to match the arity of the target&#39;</span>
<span class="k">def</span> <span class="nf">_trim_arity</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">maxargs</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">singleArgBuiltins</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">limit</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">foundArity</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span>
    
    <span class="c1"># traceback return data structure changed in Py3.5 - normalize back to plain tuples</span>
    <span class="k">if</span> <span class="n">system_version</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">extract_stack</span><span class="p">():</span>
            <span class="c1"># special handling for Python 3.5.0 - extra deep call stack by 1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">3</span> <span class="k">if</span> <span class="n">system_version</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">2</span>
            <span class="n">frame_summary</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">()[</span><span class="n">offset</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">frame_summary</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">frame_summary</span><span class="o">.</span><span class="n">lineno</span><span class="p">)]</span>
        <span class="k">def</span> <span class="nf">extract_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">):</span>
            <span class="n">frames</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">)</span>
            <span class="n">frame_summary</span> <span class="o">=</span> <span class="n">frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">[(</span><span class="n">frame_summary</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span> <span class="n">frame_summary</span><span class="o">.</span><span class="n">lineno</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">extract_stack</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span>
        <span class="n">extract_tb</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_tb</span>
    
    <span class="c1"># synthesize what would be returned by traceback.extract_stack at the call to </span>
    <span class="c1"># user&#39;s parse action &#39;func&#39;, so that we don&#39;t incur call penalty at parse time</span>
    
    <span class="n">LINE_DIFF</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="c1"># IF ANY CODE CHANGES, EVEN JUST COMMENTS OR BLANK LINES, BETWEEN THE NEXT LINE AND </span>
    <span class="c1"># THE CALL TO FUNC INSIDE WRAPPER, LINE_DIFF MUST BE MODIFIED!!!!</span>
    <span class="n">this_line</span> <span class="o">=</span> <span class="n">extract_stack</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pa_call_line_synth</span> <span class="o">=</span> <span class="p">(</span><span class="n">this_line</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">this_line</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">LINE_DIFF</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]:])</span>
                <span class="n">foundArity</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="c1"># re-raise TypeErrors if they did not come from our arity testing</span>
                <span class="k">if</span> <span class="n">foundArity</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">tb</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">extract_tb</span><span class="p">(</span><span class="n">tb</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">pa_call_line_synth</span><span class="p">:</span>
                            <span class="k">raise</span>
                    <span class="k">finally</span><span class="p">:</span>
                        <span class="k">del</span> <span class="n">tb</span>

                <span class="k">if</span> <span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">maxargs</span><span class="p">:</span>
                    <span class="n">limit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">continue</span>
                <span class="k">raise</span>

    <span class="c1"># copy func name to wrapper for sensible debug output</span>
    <span class="n">func_name</span> <span class="o">=</span> <span class="s2">&quot;&lt;parse action&gt;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> 
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__class__&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">func_name</span>

    <span class="k">return</span> <span class="n">wrapper</span>

<div class="viewcode-block" id="ParserElement"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.html#matplotlib.mathtext.ParserElement">[docs]</a><span class="k">class</span> <span class="nc">ParserElement</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract base level parser element class.&quot;&quot;&quot;</span>
    <span class="n">DEFAULT_WHITE_CHARS</span> <span class="o">=</span> <span class="s2">&quot; </span><span class="se">\n\t\r</span><span class="s2">&quot;</span>
    <span class="n">verbose_stacktrace</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="ParserElement.setDefaultWhitespaceChars"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.setDefaultWhitespaceChars.html#matplotlib.mathtext.ParserElement.setDefaultWhitespaceChars">[docs]</a>    <span class="k">def</span> <span class="nf">setDefaultWhitespaceChars</span><span class="p">(</span> <span class="n">chars</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overrides the default whitespace chars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span> <span class="o">=</span> <span class="n">chars</span></div>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="ParserElement.inlineLiteralsUsing"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.inlineLiteralsUsing.html#matplotlib.mathtext.ParserElement.inlineLiteralsUsing">[docs]</a>    <span class="k">def</span> <span class="nf">inlineLiteralsUsing</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set class to be used for inclusion of string literals into a parser.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span> <span class="o">=</span> <span class="n">cls</span></div>

<div class="viewcode-block" id="ParserElement.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.__init__.html#matplotlib.mathtext.ParserElement.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#~ self.name = &quot;&lt;unknown&gt;&quot;  # don&#39;t define self.name, let subclasses try/except upcall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="n">savelist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># used when checking for left-recursion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># used to optimize exception handling for subclasses that don&#39;t advance parse index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># used to mark results names as modal (report only last) or cumulative (list all)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span> <span class="o">=</span> <span class="p">(</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span> <span class="p">)</span> <span class="c1">#custom debug actions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># used to avoid redundant calls to preParse</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="ParserElement.copy"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.copy.html#matplotlib.mathtext.ParserElement.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a copy of this C{ParserElement}.  Useful for defining different parse actions</span>
<span class="sd">           for the same parsing pattern, using copies of the original parse element.&quot;&quot;&quot;</span>
        <span class="n">cpy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="n">cpy</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">[:]</span>
        <span class="n">cpy</span><span class="o">.</span><span class="n">ignoreExprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[:]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span><span class="p">:</span>
            <span class="n">cpy</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span>
        <span class="k">return</span> <span class="n">cpy</span></div>

<div class="viewcode-block" id="ParserElement.setName"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.setName.html#matplotlib.mathtext.ParserElement.setName">[docs]</a>    <span class="k">def</span> <span class="nf">setName</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define name for this expression, for use in debugging.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;exception&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.setResultsName"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.setResultsName.html#matplotlib.mathtext.ParserElement.setResultsName">[docs]</a>    <span class="k">def</span> <span class="nf">setResultsName</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define name for referencing matching tokens as a nested attribute</span>
<span class="sd">           of the returned parse results.</span>
<span class="sd">           NOTE: this returns a *copy* of the original C{ParserElement} object;</span>
<span class="sd">           this is so that the client can define a basic element, such as an</span>
<span class="sd">           integer, and reference it in multiple places with different names.</span>
<span class="sd">           </span>
<span class="sd">           You can also set results names using the abbreviated syntax,</span>
<span class="sd">           C{expr(&quot;name&quot;)} in place of C{expr.setResultsName(&quot;name&quot;)} - </span>
<span class="sd">           see L{I{__call__}&lt;__call__&gt;}.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newself</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">True</span>
        <span class="n">newself</span><span class="o">.</span><span class="n">resultsName</span> <span class="o">=</span> <span class="n">name</span>
        <span class="n">newself</span><span class="o">.</span><span class="n">modalResults</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">listAllMatches</span>
        <span class="k">return</span> <span class="n">newself</span></div>

<div class="viewcode-block" id="ParserElement.setBreak"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.setBreak.html#matplotlib.mathtext.ParserElement.setBreak">[docs]</a>    <span class="k">def</span> <span class="nf">setBreak</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">breakFlag</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method to invoke the Python pdb debugger when this element is</span>
<span class="sd">           about to be parsed. Set C{breakFlag} to True to enable, False to</span>
<span class="sd">           disable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">breakFlag</span><span class="p">:</span>
            <span class="n">_parseMethod</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span>
            <span class="k">def</span> <span class="nf">breaker</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">pdb</span>
                <span class="n">pdb</span><span class="o">.</span><span class="n">set_trace</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">_parseMethod</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span> <span class="p">)</span>
            <span class="n">breaker</span><span class="o">.</span><span class="n">_originalParseMethod</span> <span class="o">=</span> <span class="n">_parseMethod</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="n">breaker</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">,</span><span class="s2">&quot;_originalParseMethod&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="o">.</span><span class="n">_originalParseMethod</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.setParseAction"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.setParseAction.html#matplotlib.mathtext.ParserElement.setParseAction">[docs]</a>    <span class="k">def</span> <span class="nf">setParseAction</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fns</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define action to perform when successfully matching parse element definition.</span>
<span class="sd">           Parse action fn is a callable method with 0-3 arguments, called as C{fn(s,loc,toks)},</span>
<span class="sd">           C{fn(loc,toks)}, C{fn(toks)}, or just C{fn()}, where:</span>
<span class="sd">            - s   = the original string being parsed (see note below)</span>
<span class="sd">            - loc = the location of the matching substring</span>
<span class="sd">            - toks = a list of the matched tokens, packaged as a C{L{ParseResults}} object</span>
<span class="sd">           If the functions in fns modify the tokens, they can return them as the return</span>
<span class="sd">           value from fn, and the modified list of tokens will replace the original.</span>
<span class="sd">           Otherwise, fn does not need to return any value.</span>
<span class="sd">           </span>
<span class="sd">           Optional keyword arguments:</span>
<span class="sd">            - callDuringTry = (default=False) indicate if parse action should be run during lookaheads and alternate testing</span>

<span class="sd">           Note: the default parsing behavior is to expand tabs in the input string</span>
<span class="sd">           before starting the parsing process.  See L{I{parseString}&lt;parseString&gt;} for more information</span>
<span class="sd">           on parsing strings containing C{&lt;TAB&gt;}s, and suggested methods to maintain a</span>
<span class="sd">           consistent view of the parsed string, the parse location, and line and column</span>
<span class="sd">           positions within the parsed string.</span>
<span class="sd">           &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_trim_arity</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">fns</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.addParseAction"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.addParseAction.html#matplotlib.mathtext.ParserElement.addParseAction">[docs]</a>    <span class="k">def</span> <span class="nf">addParseAction</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fns</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add parse action to expression&#39;s list of parse actions. See L{I{setParseAction}&lt;setParseAction&gt;}.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_trim_arity</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">fns</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.addCondition"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.addCondition.html#matplotlib.mathtext.ParserElement.addCondition">[docs]</a>    <span class="k">def</span> <span class="nf">addCondition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">fns</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Add a boolean predicate function to expression&#39;s list of parse actions. See </span>
<span class="sd">        L{I{setParseAction}&lt;setParseAction&gt;} for function call signatures. Unlike C{setParseAction}, </span>
<span class="sd">        functions passed to C{addCondition} need to return boolean success/fail of the condition.</span>

<span class="sd">        Optional keyword arguments:</span>
<span class="sd">         - message = define a custom message to be used in the raised exception</span>
<span class="sd">         - fatal   = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise ParseException</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;message&quot;</span><span class="p">,</span> <span class="s2">&quot;failed user-defined condition&quot;</span><span class="p">)</span>
        <span class="n">exc_type</span> <span class="o">=</span> <span class="n">ParseFatalException</span> <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fatal&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">else</span> <span class="n">ParseException</span>
        <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">fns</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_trim_arity</span><span class="p">(</span><span class="n">fn</span><span class="p">)(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">)):</span>
                    <span class="k">raise</span> <span class="n">exc_type</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">msg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pa</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span> <span class="ow">or</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;callDuringTry&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.setFailAction"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.setFailAction.html#matplotlib.mathtext.ParserElement.setFailAction">[docs]</a>    <span class="k">def</span> <span class="nf">setFailAction</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fn</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define action to perform if parsing fails at this expression.</span>
<span class="sd">           Fail acton fn is a callable function that takes the arguments</span>
<span class="sd">           C{fn(s,loc,expr,err)} where:</span>
<span class="sd">            - s = string being parsed</span>
<span class="sd">            - loc = location where expression match was attempted and failed</span>
<span class="sd">            - expr = the parse expression that failed</span>
<span class="sd">            - err = the exception thrown</span>
<span class="sd">           The function returns no value.  It may throw C{L{ParseFatalException}}</span>
<span class="sd">           if it is desired to stop parsing immediately.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span> <span class="o">=</span> <span class="n">fn</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">_skipIgnorables</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">):</span>
        <span class="n">exprsFound</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">exprsFound</span><span class="p">:</span>
            <span class="n">exprsFound</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">loc</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
                        <span class="n">exprsFound</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                    <span class="k">pass</span>
        <span class="k">return</span> <span class="n">loc</span>

<div class="viewcode-block" id="ParserElement.preParse"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.preParse.html#matplotlib.mathtext.ParserElement.preParse">[docs]</a>    <span class="k">def</span> <span class="nf">preParse</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipIgnorables</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span><span class="p">:</span>
            <span class="n">wt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span>
            <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">wt</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">loc</span></div>

<div class="viewcode-block" id="ParserElement.parseImpl"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.parseImpl.html#matplotlib.mathtext.ParserElement.parseImpl">[docs]</a>    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="ParserElement.postParse"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.postParse.html#matplotlib.mathtext.ParserElement.postParse">[docs]</a>    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span> <span class="p">):</span>
        <span class="k">return</span> <span class="n">tokenlist</span></div>

    <span class="c1">#~ @profile</span>
    <span class="k">def</span> <span class="nf">_parseNoCache</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">debugging</span> <span class="o">=</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="p">)</span> <span class="c1">#and doActions )</span>

        <span class="k">if</span> <span class="n">debugging</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">:</span>
            <span class="c1">#~ print (&quot;Match&quot;,self,&quot;at loc&quot;,loc,&quot;(%d,%d)&quot; % ( lineno(loc,instring), col(loc,instring) ))</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">callPreParse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span><span class="p">:</span>
                <span class="n">preloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preloc</span> <span class="o">=</span> <span class="n">loc</span>
            <span class="n">tokensStart</span> <span class="o">=</span> <span class="n">preloc</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">loc</span><span class="p">,</span><span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span> <span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span> <span class="p">)</span>
            <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="c1">#~ print (&quot;Exception raised:&quot;, err)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span> <span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span> <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">failAction</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span> <span class="p">)</span>
                <span class="k">raise</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">callPreParse</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span><span class="p">:</span>
                <span class="n">preloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">preloc</span> <span class="o">=</span> <span class="n">loc</span>
            <span class="n">tokensStart</span> <span class="o">=</span> <span class="n">preloc</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="ow">or</span> <span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">loc</span><span class="p">,</span><span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span> <span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span><span class="p">,</span><span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span> <span class="p">)</span>

        <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">postParse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="p">)</span>

        <span class="n">retTokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span> <span class="n">tokens</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span> <span class="n">asList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span><span class="p">,</span> <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span> <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span> <span class="ow">and</span> <span class="p">(</span><span class="n">doActions</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">callDuringTry</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">debugging</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">:</span>
                        <span class="n">tokens</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="n">retTokens</span> <span class="p">)</span>
                        <span class="k">if</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">retTokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span> <span class="n">tokens</span><span class="p">,</span>
                                                      <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span>
                                                      <span class="n">asList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens</span><span class="p">,(</span><span class="n">ParseResults</span><span class="p">,</span><span class="nb">list</span><span class="p">)),</span>
                                                      <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span> <span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="c1">#~ print &quot;Exception raised in user parse action:&quot;, err</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span> <span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span> <span class="p">)</span>
                    <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseAction</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="n">fn</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="n">retTokens</span> <span class="p">)</span>
                    <span class="k">if</span> <span class="n">tokens</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">retTokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span> <span class="n">tokens</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">,</span>
                                                  <span class="n">asList</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tokens</span><span class="p">,(</span><span class="n">ParseResults</span><span class="p">,</span><span class="nb">list</span><span class="p">)),</span>
                                                  <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span> <span class="p">)</span>

        <span class="k">if</span> <span class="n">debugging</span><span class="p">:</span>
            <span class="c1">#~ print (&quot;Matched&quot;,self,&quot;-&gt;&quot;,retTokens.asList())</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span> <span class="n">instring</span><span class="p">,</span> <span class="n">tokensStart</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">retTokens</span> <span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">retTokens</span>

<div class="viewcode-block" id="ParserElement.tryParse"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.tryParse.html#matplotlib.mathtext.ParserElement.tryParse">[docs]</a>    <span class="k">def</span> <span class="nf">tryParse</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">False</span> <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="n">ParseFatalException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ParserElement.canParseNext"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.canParseNext.html#matplotlib.mathtext.ParserElement.canParseNext">[docs]</a>    <span class="k">def</span> <span class="nf">canParseNext</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tryParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span></div>

    <span class="c1"># this method gets repeatedly called during backtracking with the same arguments -</span>
    <span class="c1"># we can cache these arguments and save ourselves the trouble of re-parsing the contained expression</span>
    <span class="k">def</span> <span class="nf">_parseCache</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">lookup</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">instring</span><span class="p">,</span><span class="n">loc</span><span class="p">,</span><span class="n">callPreParse</span><span class="p">,</span><span class="n">doActions</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lookup</span> <span class="ow">in</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_exprArgCache</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_exprArgCache</span><span class="p">[</span> <span class="n">lookup</span> <span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">value</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parseNoCache</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span> <span class="p">)</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">_exprArgCache</span><span class="p">[</span> <span class="n">lookup</span> <span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
                <span class="k">return</span> <span class="n">value</span>
            <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
                <span class="n">pe</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ParserElement</span><span class="o">.</span><span class="n">_exprArgCache</span><span class="p">[</span> <span class="n">lookup</span> <span class="p">]</span> <span class="o">=</span> <span class="n">pe</span>
                <span class="k">raise</span>

    <span class="n">_parse</span> <span class="o">=</span> <span class="n">_parseNoCache</span>

    <span class="c1"># argument cache for optimizing repeated calls when backtracking through recursive expressions</span>
    <span class="n">_exprArgCache</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="ParserElement.resetCache"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.resetCache.html#matplotlib.mathtext.ParserElement.resetCache">[docs]</a>    <span class="k">def</span> <span class="nf">resetCache</span><span class="p">():</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">_exprArgCache</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

    <span class="n">_packratEnabled</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="ParserElement.enablePackrat"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.enablePackrat.html#matplotlib.mathtext.ParserElement.enablePackrat">[docs]</a>    <span class="k">def</span> <span class="nf">enablePackrat</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;Enables &quot;packrat&quot; parsing, which adds memoizing to the parsing logic.</span>
<span class="sd">           Repeated parse attempts at the same string location (which happens</span>
<span class="sd">           often in many complex grammars) can immediately return a cached value,</span>
<span class="sd">           instead of re-executing parsing/validating code.  Memoizing is done of</span>
<span class="sd">           both valid results and parsing exceptions.</span>

<span class="sd">           This speedup may break existing programs that use parse actions that</span>
<span class="sd">           have side-effects.  For this reason, packrat parsing is disabled when</span>
<span class="sd">           you first import pyparsing.  To activate the packrat feature, your</span>
<span class="sd">           program must call the class method C{ParserElement.enablePackrat()}.  If</span>
<span class="sd">           your program uses C{psyco} to &quot;compile as you go&quot;, you must call</span>
<span class="sd">           C{enablePackrat} before calling C{psyco.full()}.  If you do not do this,</span>
<span class="sd">           Python will crash.  For best results, call C{enablePackrat()} immediately</span>
<span class="sd">           after importing pyparsing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">_packratEnabled</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parse</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_parseCache</span></div>

<div class="viewcode-block" id="ParserElement.parseString"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.parseString.html#matplotlib.mathtext.ParserElement.parseString">[docs]</a>    <span class="k">def</span> <span class="nf">parseString</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute the parse expression with the given string.</span>
<span class="sd">           This is the main interface to the client code, once the complete</span>
<span class="sd">           expression has been built.</span>

<span class="sd">           If you want the grammar to require that the entire input string be</span>
<span class="sd">           successfully parsed, then set C{parseAll} to True (equivalent to ending</span>
<span class="sd">           the grammar with C{L{StringEnd()}}).</span>

<span class="sd">           Note: C{parseString} implicitly calls C{expandtabs()} on the input string,</span>
<span class="sd">           in order to report proper column numbers in parse actions.</span>
<span class="sd">           If the input string contains tabs and</span>
<span class="sd">           the grammar uses parse actions that use the C{loc} argument to index into the</span>
<span class="sd">           string being parsed, you can ensure you have a consistent view of the input</span>
<span class="sd">           string by:</span>
<span class="sd">            - calling C{parseWithTabs} on your grammar before calling C{parseString}</span>
<span class="sd">              (see L{I{parseWithTabs}&lt;parseWithTabs&gt;})</span>
<span class="sd">            - define your parse action using the full C{(s,loc,toks)} signature, and</span>
<span class="sd">              reference the input string using the parse action&#39;s C{s} argument</span>
<span class="sd">            - explictly expand the tabs in your input string before calling</span>
<span class="sd">              C{parseString}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">resetCache</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
            <span class="c1">#~ self.saveAsList = True</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span><span class="p">:</span>
            <span class="n">instring</span> <span class="o">=</span> <span class="n">instring</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="mi">0</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">parseAll</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
                <span class="n">se</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span> <span class="o">+</span> <span class="n">StringEnd</span><span class="p">()</span>
                <span class="n">se</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tokens</span></div>

<div class="viewcode-block" id="ParserElement.scanString"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.scanString.html#matplotlib.mathtext.ParserElement.scanString">[docs]</a>    <span class="k">def</span> <span class="nf">scanString</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">maxMatches</span><span class="o">=</span><span class="n">_MAX_INT</span><span class="p">,</span> <span class="n">overlap</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Scan the input string for expression matches.  Each match will return the</span>
<span class="sd">           matching tokens, start location, and end location.  May be called with optional</span>
<span class="sd">           C{maxMatches} argument, to clip scanning after &#39;n&#39; matches are found.  If</span>
<span class="sd">           C{overlap} is specified, then overlapping matches will be reported.</span>

<span class="sd">           Note that the start and end locations are reported relative to the string</span>
<span class="sd">           being parsed.  See L{I{parseString}&lt;parseString&gt;} for more information on parsing</span>
<span class="sd">           strings with embedded tabs.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span><span class="p">:</span>
            <span class="n">instring</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span><span class="o">.</span><span class="n">expandtabs</span><span class="p">()</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">preparseFn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span>
        <span class="n">parseFn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span>
        <span class="n">ParserElement</span><span class="o">.</span><span class="n">resetCache</span><span class="p">()</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;=</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">matches</span> <span class="o">&lt;</span> <span class="n">maxMatches</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">preparseFn</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
                    <span class="n">nextLoc</span><span class="p">,</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">parseFn</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                    <span class="n">loc</span> <span class="o">=</span> <span class="n">preloc</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">nextLoc</span> <span class="o">&gt;</span> <span class="n">loc</span><span class="p">:</span>
                        <span class="n">matches</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">yield</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">nextLoc</span>
                        <span class="k">if</span> <span class="n">overlap</span><span class="p">:</span>
                            <span class="n">nextloc</span> <span class="o">=</span> <span class="n">preparseFn</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
                            <span class="k">if</span> <span class="n">nextloc</span> <span class="o">&gt;</span> <span class="n">loc</span><span class="p">:</span>
                                <span class="n">loc</span> <span class="o">=</span> <span class="n">nextLoc</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">loc</span> <span class="o">=</span> <span class="n">nextLoc</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">loc</span> <span class="o">=</span> <span class="n">preloc</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span></div>

<div class="viewcode-block" id="ParserElement.transformString"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.transformString.html#matplotlib.mathtext.ParserElement.transformString">[docs]</a>    <span class="k">def</span> <span class="nf">transformString</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extension to C{L{scanString}}, to modify matching text with modified tokens that may</span>
<span class="sd">           be returned from a parse action.  To use C{transformString}, define a grammar and</span>
<span class="sd">           attach a parse action to it that modifies the returned token list.</span>
<span class="sd">           Invoking C{transformString()} on a target string will then scan for matches,</span>
<span class="sd">           and replace the matched text patterns according to the logic in the parse</span>
<span class="sd">           action.  C{transformString()} returns the resulting transformed string.&quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lastE</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># force preservation of &lt;TAB&gt;s, to minimize unwanted transformation of string, and to</span>
        <span class="c1"># keep string locs straight between transformString and scanString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scanString</span><span class="p">(</span> <span class="n">instring</span> <span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">instring</span><span class="p">[</span><span class="n">lastE</span><span class="p">:</span><span class="n">s</span><span class="p">]</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">):</span>
                        <span class="n">out</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">asList</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
                        <span class="n">out</span> <span class="o">+=</span> <span class="n">t</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="n">lastE</span> <span class="o">=</span> <span class="n">e</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">lastE</span><span class="p">:])</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">out</span> <span class="k">if</span> <span class="n">o</span><span class="p">]</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_ustr</span><span class="p">,</span><span class="n">_flatten</span><span class="p">(</span><span class="n">out</span><span class="p">)))</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span></div>

<div class="viewcode-block" id="ParserElement.searchString"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.searchString.html#matplotlib.mathtext.ParserElement.searchString">[docs]</a>    <span class="k">def</span> <span class="nf">searchString</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">maxMatches</span><span class="o">=</span><span class="n">_MAX_INT</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Another extension to C{L{scanString}}, simplifying the access to the tokens found</span>
<span class="sd">           to match the given parse expression.  May be called with optional</span>
<span class="sd">           C{maxMatches} argument, to clip searching after &#39;n&#39; matches are found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ParseResults</span><span class="p">([</span> <span class="n">t</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scanString</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">maxMatches</span> <span class="p">)</span> <span class="p">])</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span></div>

<div class="viewcode-block" id="ParserElement.split"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.split.html#matplotlib.mathtext.ParserElement.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">maxsplit</span><span class="o">=</span><span class="n">_MAX_INT</span><span class="p">,</span> <span class="n">includeSeparators</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator method to split a string using the given expression as a separator.</span>
<span class="sd">           May be called with optional C{maxsplit} argument, to limit the number of splits;</span>
<span class="sd">           and the optional C{includeSeparators} argument (default=C{False}), if the separating</span>
<span class="sd">           matching text should be included in the split results.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">splits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">t</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">scanString</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">maxMatches</span><span class="o">=</span><span class="n">maxsplit</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">instring</span><span class="p">[</span><span class="n">last</span><span class="p">:</span><span class="n">s</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">includeSeparators</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">e</span>
        <span class="k">yield</span> <span class="n">instring</span><span class="p">[</span><span class="n">last</span><span class="p">:]</span></div>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of + operator - returns C{L{And}}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">(</span> <span class="p">[</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">]</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of + operator when left operand is not a C{L{ParserElement}}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">+</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of - operator, returns C{L{And}} with error stop&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">And</span><span class="p">(</span> <span class="p">[</span> <span class="bp">self</span><span class="p">,</span> <span class="n">And</span><span class="o">.</span><span class="n">_ErrorStop</span><span class="p">(),</span> <span class="n">other</span> <span class="p">]</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of - operator when left operand is not a C{L{ParserElement}}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">-</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of * operator, allows use of C{expr * 3} in place of</span>
<span class="sd">           C{expr + expr + expr}.  Expressions may also me multiplied by a 2-integer</span>
<span class="sd">           tuple, similar to C{{min,max}} multipliers in regular expressions.  Tuples</span>
<span class="sd">           may also include C{None} as in:</span>
<span class="sd">            - C{expr*(n,None)} or C{expr*(n,)} is equivalent</span>
<span class="sd">              to C{expr*n + L{ZeroOrMore}(expr)}</span>
<span class="sd">              (read as &quot;at least n instances of C{expr}&quot;)</span>
<span class="sd">            - C{expr*(None,n)} is equivalent to C{expr*(0,n)}</span>
<span class="sd">              (read as &quot;0 to n instances of C{expr}&quot;)</span>
<span class="sd">            - C{expr*(None,None)} is equivalent to C{L{ZeroOrMore}(expr)}</span>
<span class="sd">            - C{expr*(1,None)} is equivalent to C{L{OneOrMore}(expr)}</span>

<span class="sd">           Note that C{expr*(None,n)} does not raise an exception if</span>
<span class="sd">           more than n exprs exist in the input stream; that is,</span>
<span class="sd">           C{expr*(None,n)} does not enforce a maximum number of expr</span>
<span class="sd">           occurrences.  If this behavior is desired, then write</span>
<span class="sd">           C{expr*(None,n) + ~expr}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
            <span class="n">minElements</span><span class="p">,</span> <span class="n">optElements</span> <span class="o">=</span> <span class="n">other</span><span class="p">,</span><span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="nb">tuple</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">))[:</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">*</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">int</span><span class="p">):</span>
                <span class="n">minElements</span><span class="p">,</span> <span class="n">optElements</span> <span class="o">=</span> <span class="n">other</span>
                <span class="n">optElements</span> <span class="o">-=</span> <span class="n">minElements</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot multiply &#39;ParserElement&#39; and (&#39;</span><span class="si">%s</span><span class="s2">&#39;,&#39;</span><span class="si">%s</span><span class="s2">&#39;) objects&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;cannot multiply &#39;ParserElement&#39; and &#39;</span><span class="si">%s</span><span class="s2">&#39; objects&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">minElements</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot multiply ParserElement by negative value&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">optElements</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;second tuple value must be greater or equal to first tuple value&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">minElements</span> <span class="o">==</span> <span class="n">optElements</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot multiply ParserElement by 0 or (0,0)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">optElements</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">makeOptionalList</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Optional</span><span class="p">(</span><span class="bp">self</span> <span class="o">+</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">Optional</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">minElements</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">minElements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">optElements</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">And</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span><span class="o">*</span><span class="n">minElements</span><span class="p">)</span> <span class="o">+</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">optElements</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">makeOptionalList</span><span class="p">(</span><span class="n">optElements</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">minElements</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">And</span><span class="p">([</span><span class="bp">self</span><span class="p">]</span><span class="o">*</span><span class="n">minElements</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mul__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of | operator - returns C{L{MatchFirst}}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">MatchFirst</span><span class="p">(</span> <span class="p">[</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">]</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ror__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of | operator when left operand is not a C{L{ParserElement}}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">|</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__xor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of ^ operator - returns C{L{Or}}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Or</span><span class="p">(</span> <span class="p">[</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">]</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rxor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of ^ operator when left operand is not a C{L{ParserElement}}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">^</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of &amp; operator - returns C{L{Each}}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Each</span><span class="p">(</span> <span class="p">[</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">]</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__rand__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of &amp; operator when left operand is not a C{L{ParserElement}}&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span> <span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Cannot combine element of type </span><span class="si">%s</span><span class="s2"> with ParserElement&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">),</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">other</span> <span class="o">&amp;</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__invert__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implementation of ~ operator - returns C{L{NotAny}}&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">NotAny</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shortcut for C{L{setResultsName}}, with C{listAllMatches=default}::</span>
<span class="sd">             userdata = Word(alphas).setResultsName(&quot;name&quot;) + Word(nums+&quot;-&quot;).setResultsName(&quot;socsecno&quot;)</span>
<span class="sd">           could be written as::</span>
<span class="sd">             userdata = Word(alphas)(&quot;name&quot;) + Word(nums+&quot;-&quot;)(&quot;socsecno&quot;)</span>
<span class="sd">             </span>
<span class="sd">           If C{name} is given with a trailing C{&#39;*&#39;} character, then C{listAllMatches} will be</span>
<span class="sd">           passed as C{True}.</span>
<span class="sd">           </span>
<span class="sd">           If C{name} is omitted, same as calling C{L{copy}}.</span>
<span class="sd">           &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="ParserElement.suppress"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.suppress.html#matplotlib.mathtext.ParserElement.suppress">[docs]</a>    <span class="k">def</span> <span class="nf">suppress</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Suppresses the output of this C{ParserElement}; useful to keep punctuation from</span>
<span class="sd">           cluttering up returned output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Suppress</span><span class="p">(</span> <span class="bp">self</span> <span class="p">)</span></div>

<div class="viewcode-block" id="ParserElement.leaveWhitespace"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.leaveWhitespace.html#matplotlib.mathtext.ParserElement.leaveWhitespace">[docs]</a>    <span class="k">def</span> <span class="nf">leaveWhitespace</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Disables the skipping of whitespace before matching the characters in the</span>
<span class="sd">           C{ParserElement}&#39;s defined pattern.  This is normally only used internally by</span>
<span class="sd">           the pyparsing module, but may be needed in some whitespace-sensitive grammars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.setWhitespaceChars"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.setWhitespaceChars.html#matplotlib.mathtext.ParserElement.setWhitespaceChars">[docs]</a>    <span class="k">def</span> <span class="nf">setWhitespaceChars</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">chars</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overrides the default whitespace chars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span> <span class="o">=</span> <span class="n">chars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copyDefaultWhiteChars</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.parseWithTabs"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.parseWithTabs.html#matplotlib.mathtext.ParserElement.parseWithTabs">[docs]</a>    <span class="k">def</span> <span class="nf">parseWithTabs</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overrides default behavior to expand C{&lt;TAB&gt;}s to spaces before parsing the input string.</span>
<span class="sd">           Must be called before C{parseString} when the input grammar contains elements that</span>
<span class="sd">           match C{&lt;TAB&gt;} characters.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keepTabs</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.ignore"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.ignore.html#matplotlib.mathtext.ParserElement.ignore">[docs]</a>    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Define expression to be ignored (e.g., comments) while doing pattern</span>
<span class="sd">           matching; may be called repeatedly, to define multiple comment or other</span>
<span class="sd">           ignorable patterns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">Suppress</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">Suppress</span><span class="p">(</span> <span class="n">other</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.setDebugActions"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.setDebugActions.html#matplotlib.mathtext.ParserElement.setDebugActions">[docs]</a>    <span class="k">def</span> <span class="nf">setDebugActions</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">startAction</span><span class="p">,</span> <span class="n">successAction</span><span class="p">,</span> <span class="n">exceptionAction</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enable display of debugging messages while doing pattern matching.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debugActions</span> <span class="o">=</span> <span class="p">(</span><span class="n">startAction</span> <span class="ow">or</span> <span class="n">_defaultStartDebugAction</span><span class="p">,</span>
                             <span class="n">successAction</span> <span class="ow">or</span> <span class="n">_defaultSuccessDebugAction</span><span class="p">,</span>
                             <span class="n">exceptionAction</span> <span class="ow">or</span> <span class="n">_defaultExceptionDebugAction</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.setDebug"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.setDebug.html#matplotlib.mathtext.ParserElement.setDebug">[docs]</a>    <span class="k">def</span> <span class="nf">setDebug</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">flag</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Enable display of debugging messages while doing pattern matching.</span>
<span class="sd">           Set C{flag} to True to enable, False to disable.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">flag</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setDebugActions</span><span class="p">(</span> <span class="n">_defaultStartDebugAction</span><span class="p">,</span> <span class="n">_defaultSuccessDebugAction</span><span class="p">,</span> <span class="n">_defaultExceptionDebugAction</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">debug</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="ParserElement.streamline"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.streamline.html#matplotlib.mathtext.ParserElement.streamline">[docs]</a>    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="ParserElement.checkRecursion"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.checkRecursion.html#matplotlib.mathtext.ParserElement.checkRecursion">[docs]</a>    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span> <span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="ParserElement.validate"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.validate.html#matplotlib.mathtext.ParserElement.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="p">[]</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check defined expressions for valid structure, check for infinite recursive definitions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span></div>

<div class="viewcode-block" id="ParserElement.parseFile"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.parseFile.html#matplotlib.mathtext.ParserElement.parseFile">[docs]</a>    <span class="k">def</span> <span class="nf">parseFile</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">file_or_filename</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute the parse expression on the given file or filename.</span>
<span class="sd">           If a filename is specified (instead of a file object),</span>
<span class="sd">           the entire file is opened, read, and closed before parsing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">file_contents</span> <span class="o">=</span> <span class="n">file_or_filename</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_or_filename</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">file_contents</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">file_contents</span><span class="p">,</span> <span class="n">parseAll</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">verbose_stacktrace</span><span class="p">:</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># catch and re-raise exception from here, clears out pyparsing internal stack trace</span>
                <span class="k">raise</span> <span class="n">exc</span></div>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ParserElement</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">other</span> <span class="ow">or</span> <span class="nb">vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">vars</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">==</span><span class="n">other</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__req__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

    <span class="k">def</span> <span class="nf">__rne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="ParserElement.matches"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.matches.html#matplotlib.mathtext.ParserElement.matches">[docs]</a>    <span class="k">def</span> <span class="nf">matches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testString</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Method for quick testing of a parser against a test string. Good for simple </span>
<span class="sd">           inline microtests of sub expressions while building up larger parser, as in::</span>
<span class="sd">           </span>
<span class="sd">               expr = Word(nums)</span>
<span class="sd">               assert expr.matches(&quot;100&quot;)</span>
<span class="sd">           </span>
<span class="sd">           Parameters:</span>
<span class="sd">            - testString - to test against this expression for a match</span>
<span class="sd">            - parseAll - (default=True) - flag to pass to C{L{parseString}} when running tests           </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">testString</span><span class="p">),</span> <span class="n">parseAll</span><span class="o">=</span><span class="n">parseAll</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="n">ParseBaseException</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>
                
<div class="viewcode-block" id="ParserElement.runTests"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ParserElement.runTests.html#matplotlib.mathtext.ParserElement.runTests">[docs]</a>    <span class="k">def</span> <span class="nf">runTests</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tests</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">printResults</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">failureTests</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Execute the parse expression on a series of test strings, showing each</span>
<span class="sd">           test, the parsed results or where the parse failed. Quick and easy way to</span>
<span class="sd">           run a parse expression against a list of sample strings.</span>
<span class="sd">           </span>
<span class="sd">           Parameters:</span>
<span class="sd">            - tests - a list of separate test strings, or a multiline string of test strings</span>
<span class="sd">            - parseAll - (default=True) - flag to pass to C{L{parseString}} when running tests           </span>
<span class="sd">            - comment - (default=&#39;#&#39;) - expression for indicating embedded comments in the test </span>
<span class="sd">              string; pass None to disable comment filtering</span>
<span class="sd">            - printResults - (default=True) prints test output to stdout</span>
<span class="sd">            - failureTests - (default=False) indicates if these tests are expected to fail parsing</span>

<span class="sd">            Returns: a (success, results) tuple, where success indicates that all tests succeeded</span>
<span class="sd">            (or failed if C{failureTest} is True), and the results contain a list of lines of each </span>
<span class="sd">            test&#39;s output</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tests</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">tests</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">strip</span><span class="p">,</span> <span class="n">tests</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
        <span class="n">allResults</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">comment</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">comments</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
                <span class="n">comments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">t</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">out</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comments</span><span class="p">),</span> <span class="n">t</span><span class="p">]</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">parseAll</span><span class="o">=</span><span class="n">parseAll</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">dump</span><span class="p">())</span>
                <span class="n">success</span> <span class="o">=</span> <span class="n">success</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">failureTests</span>
            <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
                <span class="n">fatal</span> <span class="o">=</span> <span class="s2">&quot;(FATAL)&quot;</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="n">ParseFatalException</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">(</span><span class="n">pe</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="p">(</span><span class="n">col</span><span class="p">(</span><span class="n">pe</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="n">fatal</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">*</span><span class="n">pe</span><span class="o">.</span><span class="n">loc</span> <span class="o">+</span> <span class="s1">&#39;^&#39;</span> <span class="o">+</span> <span class="n">fatal</span><span class="p">)</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;FAIL: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pe</span><span class="p">))</span>
                <span class="n">success</span> <span class="o">=</span> <span class="n">success</span> <span class="ow">and</span> <span class="n">failureTests</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">pe</span>

            <span class="k">if</span> <span class="n">printResults</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>

            <span class="n">allResults</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">result</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">success</span><span class="p">,</span> <span class="n">allResults</span></div></div>

        
<span class="k">class</span> <span class="nc">Token</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract C{ParserElement} subclass, for defining atomic matching patterns.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Token</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>


<div class="viewcode-block" id="Empty"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Empty.html#matplotlib.mathtext.Empty">[docs]</a><span class="k">class</span> <span class="nc">Empty</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An empty token, will always match.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="Empty.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Empty.__init__.html#matplotlib.mathtext.Empty.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Empty</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;Empty&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span></div></div>


<span class="k">class</span> <span class="nc">NoMatch</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A token that will never match.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NoMatch</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;NoMatch&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Unmatchable token&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


<div class="viewcode-block" id="Literal"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Literal.html#matplotlib.mathtext.Literal">[docs]</a><span class="k">class</span> <span class="nc">Literal</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token to exactly match a specified string.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="Literal.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Literal.__init__.html#matplotlib.mathtext.Literal.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">matchString</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Literal</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">matchString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchString</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="o">=</span> <span class="n">matchString</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;null string passed to Literal; use Empty() instead&quot;</span><span class="p">,</span>
                            <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">=</span> <span class="n">Empty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span></div>

    <span class="c1"># Performance tuning: this routine gets called a *lot*</span>
    <span class="c1"># if this is a single character match string  and the first character matches,</span>
    <span class="c1"># short-circuit as quickly as possible, and avoid calling startswith</span>
    <span class="c1">#~ @profile</span>
<div class="viewcode-block" id="Literal.parseImpl"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Literal.parseImpl.html#matplotlib.mathtext.Literal.parseImpl">[docs]</a>    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="ow">and</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">instring</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">,</span><span class="n">loc</span><span class="p">))</span> <span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div></div>
<span class="n">_L</span> <span class="o">=</span> <span class="n">Literal</span>
<span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span> <span class="o">=</span> <span class="n">Literal</span>

<span class="k">class</span> <span class="nc">Keyword</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token to exactly match a specified string as a keyword, that is, it must be</span>
<span class="sd">       immediately followed by a non-keyword character.  Compare with C{L{Literal}}:</span>
<span class="sd">        - C{Literal(&quot;if&quot;)} will match the leading C{&#39;if&#39;} in C{&#39;ifAndOnlyIf&#39;}.</span>
<span class="sd">        - C{Keyword(&quot;if&quot;)} will not; it will only match the leading C{&#39;if&#39;} in C{&#39;if x=1&#39;}, or C{&#39;if(y==2)&#39;}</span>
<span class="sd">       Accepts two optional constructor arguments in addition to the keyword string:</span>
<span class="sd">        - C{identChars} is a string of characters that would be valid identifier characters,</span>
<span class="sd">          defaulting to all alphanumerics + &quot;_&quot; and &quot;$&quot;</span>
<span class="sd">        - C{caseless} allows case-insensitive matching, default is C{False}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DEFAULT_KEYWORD_CHARS</span> <span class="o">=</span> <span class="n">alphanums</span><span class="o">+</span><span class="s2">&quot;_$&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">matchString</span><span class="p">,</span> <span class="n">identChars</span><span class="o">=</span><span class="n">DEFAULT_KEYWORD_CHARS</span><span class="p">,</span> <span class="n">caseless</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Keyword</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">match</span> <span class="o">=</span> <span class="n">matchString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matchString</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="o">=</span> <span class="n">matchString</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;null string passed to Keyword; use Empty() instead&quot;</span><span class="p">,</span>
                            <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;&quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">caseless</span> <span class="o">=</span> <span class="n">caseless</span>
        <span class="k">if</span> <span class="n">caseless</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">caselessmatch</span> <span class="o">=</span> <span class="n">matchString</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">identChars</span> <span class="o">=</span> <span class="n">identChars</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">identChars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">caseless</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">instring</span><span class="p">[</span> <span class="n">loc</span><span class="p">:</span><span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">caselessmatch</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="p">(</span><span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">)</span> <span class="ow">and</span>
                 <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstMatchChar</span> <span class="ow">and</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="o">==</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">instring</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">,</span><span class="n">loc</span><span class="p">))</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">)</span> <span class="p">):</span>
                <span class="k">return</span> <span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">Keyword</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">c</span><span class="o">.</span><span class="n">identChars</span> <span class="o">=</span> <span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span>
        <span class="k">return</span> <span class="n">c</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">setDefaultKeywordChars</span><span class="p">(</span> <span class="n">chars</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overrides the default Keyword chars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span> <span class="o">=</span> <span class="n">chars</span>

<span class="k">class</span> <span class="nc">CaselessLiteral</span><span class="p">(</span><span class="n">Literal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token to match a specified string, ignoring case of letters.</span>
<span class="sd">       Note: the matched results will always be in the case of the given</span>
<span class="sd">       match string, NOT the case of the input text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">matchString</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CaselessLiteral</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">matchString</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="p">)</span>
        <span class="c1"># Preserve the defining literal.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">returnString</span> <span class="o">=</span> <span class="n">matchString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">returnString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span> <span class="n">loc</span><span class="p">:</span><span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">returnString</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">CaselessKeyword</span><span class="p">(</span><span class="n">Keyword</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">matchString</span><span class="p">,</span> <span class="n">identChars</span><span class="o">=</span><span class="n">Keyword</span><span class="o">.</span><span class="n">DEFAULT_KEYWORD_CHARS</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CaselessKeyword</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">matchString</span><span class="p">,</span> <span class="n">identChars</span><span class="p">,</span> <span class="n">caseless</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">instring</span><span class="p">[</span> <span class="n">loc</span><span class="p">:</span><span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">caselessmatch</span><span class="p">)</span> <span class="ow">and</span>
             <span class="p">(</span><span class="n">loc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span> <span class="ow">or</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">identChars</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">matchLen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">match</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Word</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token for matching words composed of allowed character sets.</span>
<span class="sd">       Defined with string containing all allowed initial characters,</span>
<span class="sd">       an optional string containing allowed body characters (if omitted,</span>
<span class="sd">       defaults to the initial character set), and an optional minimum,</span>
<span class="sd">       maximum, and/or exact length.  The default value for C{min} is 1 (a</span>
<span class="sd">       minimum value &lt; 1 is not valid); the default values for C{max} and C{exact}</span>
<span class="sd">       are 0, meaning no maximum or exact length restriction. An optional</span>
<span class="sd">       C{excludeChars} parameter can list characters that might be found in </span>
<span class="sd">       the input C{bodyChars} string; useful to define a word of all printables</span>
<span class="sd">       except for one or two characters, for instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">initChars</span><span class="p">,</span> <span class="n">bodyChars</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">asKeyword</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Word</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">excludeChars</span><span class="p">:</span>
            <span class="n">initChars</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">initChars</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excludeChars</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">bodyChars</span><span class="p">:</span>
                <span class="n">bodyChars</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bodyChars</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excludeChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span> <span class="o">=</span> <span class="n">initChars</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initChars</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bodyChars</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="o">=</span> <span class="n">bodyChars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">bodyChars</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="o">=</span> <span class="n">initChars</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">initChars</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">maxSpecified</span> <span class="o">=</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">min</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot specify a minimum length &lt; 1; use Optional(Word()) if zero-length word is permitted&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="nb">min</span>

        <span class="k">if</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">_MAX_INT</span>

        <span class="k">if</span> <span class="n">exact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">exact</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">exact</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asKeyword</span> <span class="o">=</span> <span class="n">asKeyword</span>

        <span class="k">if</span> <span class="s1">&#39; &#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">min</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">max</span><span class="o">==</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">exact</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]+&quot;</span> <span class="o">%</span> <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[</span><span class="si">%s</span><span class="s2">]*&quot;</span> <span class="o">%</span> \
                                      <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">),</span>
                                      <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span><span class="p">),)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">][</span><span class="si">%s</span><span class="s2">]*&quot;</span> <span class="o">%</span> \
                                      <span class="p">(</span><span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">),</span>
                                      <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span><span class="p">),)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asKeyword</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="s2">r&quot;\b&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">reString</span><span class="o">+</span><span class="s2">r&quot;\b&quot;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span><span class="n">loc</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

            <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">instring</span><span class="p">[</span> <span class="n">loc</span> <span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">initChars</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">bodychars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyChars</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">maxloc</span><span class="p">,</span> <span class="n">instrlen</span> <span class="p">)</span>
        <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">maxloc</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">throwException</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">:</span>
            <span class="n">throwException</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxSpecified</span> <span class="ow">and</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span><span class="p">:</span>
            <span class="n">throwException</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">asKeyword</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">start</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">loc</span><span class="o">&lt;</span><span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="n">bodychars</span><span class="p">):</span>
                <span class="n">throwException</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="n">throwException</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Word</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>


        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">charsAsStr</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">4</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">s</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;...&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">s</span>

            <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;W:(</span><span class="si">%s</span><span class="s2">,</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">charsAsStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">),</span> <span class="n">charsAsStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bodyCharsOrig</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;W:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">charsAsStr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">initCharsOrig</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>


<div class="viewcode-block" id="Regex"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Regex.html#matplotlib.mathtext.Regex">[docs]</a><span class="k">class</span> <span class="nc">Regex</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token for matching strings that match a given regular expression.</span>
<span class="sd">       Defined with string specifying the regular expression in a form recognized by the inbuilt Python re module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">compiledREtype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s2">&quot;[A-Z]&quot;</span><span class="p">))</span>
<div class="viewcode-block" id="Regex.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Regex.__init__.html#matplotlib.mathtext.Regex.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The parameters C{pattern} and C{flags} are passed to the C{re.compile()} function as-is. See the Python C{re} module for an explanation of the acceptable patterns and flags.&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Regex</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">pattern</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;null string passed to Regex; use Empty() instead&quot;</span><span class="p">,</span>
                        <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span>
            <span class="k">except</span> <span class="n">sre_constants</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;invalid pattern (</span><span class="si">%s</span><span class="s2">) passed to Regex&quot;</span> <span class="o">%</span> <span class="n">pattern</span><span class="p">,</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">raise</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">Regex</span><span class="o">.</span><span class="n">compiledREtype</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> \
            <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>
            
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Regex may only be constructed with a string or a compiled RE object&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Regex.parseImpl"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Regex.parseImpl.html#matplotlib.mathtext.Regex.parseImpl">[docs]</a>    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span><span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Regex</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;Re:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span></div>


<div class="viewcode-block" id="QuotedString"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.QuotedString.html#matplotlib.mathtext.QuotedString">[docs]</a><span class="k">class</span> <span class="nc">QuotedString</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token for matching strings that are delimited by quoting characters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="QuotedString.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.QuotedString.__init__.html#matplotlib.mathtext.QuotedString.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">quoteChar</span><span class="p">,</span> <span class="n">escChar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">escQuote</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiline</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unquoteResults</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">endQuoteChar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">convertWhitespaceEscapes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;Defined with the following parameters:</span>
<span class="sd">            - quoteChar - string of one or more characters defining the quote delimiting string</span>
<span class="sd">            - escChar - character to escape quotes, typically backslash (default=None)</span>
<span class="sd">            - escQuote - special quote sequence to escape an embedded quote string (such as SQL&#39;s &quot;&quot; to escape an embedded &quot;) (default=None)</span>
<span class="sd">            - multiline - boolean indicating whether quotes can span multiple lines (default=C{False})</span>
<span class="sd">            - unquoteResults - boolean indicating whether the matched text should be unquoted (default=C{True})</span>
<span class="sd">            - endQuoteChar - string of one or more characters defining the end of the quote delimited string (default=C{None} =&gt; same as quoteChar)</span>
<span class="sd">            - convertWhitespaceEscapes - convert escaped whitespace (C{&#39;\t&#39;}, C{&#39;\n&#39;}, etc.) to actual whitespace (default=C{True})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">QuotedString</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="c1"># remove white space from quote chars - wont work anyway</span>
        <span class="n">quoteChar</span> <span class="o">=</span> <span class="n">quoteChar</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">quoteChar</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;quoteChar cannot be the empty string&quot;</span><span class="p">,</span><span class="ne">SyntaxWarning</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">endQuoteChar</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">quoteChar</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">endQuoteChar</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">endQuoteChar</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;endQuoteChar cannot be the empty string&quot;</span><span class="p">,</span><span class="ne">SyntaxWarning</span><span class="p">,</span><span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span> <span class="o">=</span> <span class="n">quoteChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">quoteCharLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">quoteChar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firstQuoteChar</span> <span class="o">=</span> <span class="n">quoteChar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span> <span class="o">=</span> <span class="n">endQuoteChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteCharLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">endQuoteChar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escChar</span> <span class="o">=</span> <span class="n">escChar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">escQuote</span> <span class="o">=</span> <span class="n">escQuote</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unquoteResults</span> <span class="o">=</span> <span class="n">unquoteResults</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convertWhitespaceEscapes</span> <span class="o">=</span> <span class="n">convertWhitespaceEscapes</span>

        <span class="k">if</span> <span class="n">multiline</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span> <span class="o">|</span> <span class="n">re</span><span class="o">.</span><span class="n">DOTALL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="s1">r&#39;</span><span class="si">%s</span><span class="s1">(?:[^</span><span class="si">%s%s</span><span class="s1">]&#39;</span> <span class="o">%</span> \
                <span class="p">(</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">),</span>
                  <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                  <span class="p">(</span><span class="n">escChar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="n">escChar</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="s1">r&#39;</span><span class="si">%s</span><span class="s1">(?:[^</span><span class="si">%s</span><span class="s1">\n\r</span><span class="si">%s</span><span class="s1">]&#39;</span> <span class="o">%</span> \
                <span class="p">(</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">),</span>
                  <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
                  <span class="p">(</span><span class="n">escChar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="n">escChar</span><span class="p">)</span> <span class="ow">or</span> <span class="s1">&#39;&#39;</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s1">&#39;|(?:&#39;</span> <span class="o">+</span> <span class="s1">&#39;)|(?:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">[^</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[:</span><span class="n">i</span><span class="p">]),</span>
                                               <span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">escQuote</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">r&#39;|(?:</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">escQuote</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">escChar</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">r&#39;|(?:</span><span class="si">%s</span><span class="s1">.)&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">escChar</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">escCharReplacePattern</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escChar</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;(.)&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span> <span class="o">+=</span> <span class="p">(</span><span class="s1">r&#39;)*</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reString</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span>
        <span class="k">except</span> <span class="n">sre_constants</span><span class="o">.</span><span class="n">error</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;invalid pattern (</span><span class="si">%s</span><span class="s2">) passed to Regex&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern</span><span class="p">,</span>
                <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">raise</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="QuotedString.parseImpl"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.QuotedString.parseImpl.html#matplotlib.mathtext.QuotedString.parseImpl">[docs]</a>    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">firstQuoteChar</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span><span class="n">loc</span><span class="p">)</span> <span class="ow">or</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">loc</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">end</span><span class="p">()</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">unquoteResults</span><span class="p">:</span>

            <span class="c1"># strip off quotes</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteCharLen</span><span class="p">:</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">endQuoteCharLen</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span><span class="n">basestring</span><span class="p">):</span>
                <span class="c1"># replace escaped whitespace</span>
                <span class="k">if</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">ret</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">convertWhitespaceEscapes</span><span class="p">:</span>
                    <span class="n">ws_map</span> <span class="o">=</span> <span class="p">{</span>
                        <span class="s1">r&#39;\t&#39;</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="s1">r&#39;\n&#39;</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="s1">r&#39;\f&#39;</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="se">\f</span><span class="s1">&#39;</span><span class="p">,</span>
                        <span class="s1">r&#39;\r&#39;</span> <span class="p">:</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="p">}</span>
                    <span class="k">for</span> <span class="n">wslit</span><span class="p">,</span><span class="n">wschar</span> <span class="ow">in</span> <span class="n">ws_map</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">wslit</span><span class="p">,</span> <span class="n">wschar</span><span class="p">)</span>

                <span class="c1"># replace escaped characters</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escChar</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escCharReplacePattern</span><span class="p">,</span><span class="s2">&quot;\g&lt;1&gt;&quot;</span><span class="p">,</span><span class="n">ret</span><span class="p">)</span>

                <span class="c1"># replace escaped quotes</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">escQuote</span><span class="p">:</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">escQuote</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">QuotedString</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;quoted string, starting with </span><span class="si">%s</span><span class="s2"> ending with </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">quoteChar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">endQuoteChar</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span></div>


<span class="k">class</span> <span class="nc">CharsNotIn</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token for matching words composed of characters *not* in a given set.</span>
<span class="sd">       Defined with string containing all disallowed characters, and an optional</span>
<span class="sd">       minimum, maximum, and/or exact length.  The default value for C{min} is 1 (a</span>
<span class="sd">       minimum value &lt; 1 is not valid); the default values for C{max} and C{exact}</span>
<span class="sd">       are 0, meaning no maximum or exact length restriction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">notChars</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CharsNotIn</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span> <span class="o">=</span> <span class="n">notChars</span>

        <span class="k">if</span> <span class="nb">min</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;cannot specify a minimum length &lt; 1; use Optional(CharsNotIn()) if zero-length char group is permitted&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="nb">min</span>

        <span class="k">if</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">_MAX_INT</span>

        <span class="k">if</span> <span class="n">exact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">exact</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">exact</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">notchars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">start</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">maxlen</span> <span class="ow">and</span> \
              <span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">notchars</span><span class="p">):</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CharsNotIn</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;!W:(</span><span class="si">%s</span><span class="s2">...)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;!W:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">notChars</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

<span class="k">class</span> <span class="nc">White</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Special matching class for matching whitespace.  Normally, whitespace is ignored</span>
<span class="sd">       by pyparsing grammars.  This class is included when some whitespace structures</span>
<span class="sd">       are significant.  Define with a string containing the whitespace characters to be</span>
<span class="sd">       matched; default is C{&quot; \\t\\r\\n&quot;}.  Also takes optional C{min}, C{max}, and C{exact} arguments,</span>
<span class="sd">       as defined for the C{L{Word}} class.&quot;&quot;&quot;</span>
    <span class="n">whiteStrs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot; &quot;</span> <span class="p">:</span> <span class="s2">&quot;&lt;SPC&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;TAB&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;LF&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;CR&gt;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;</span><span class="se">\f</span><span class="s2">&quot;</span><span class="p">:</span> <span class="s2">&quot;&lt;FF&gt;&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ws</span><span class="o">=</span><span class="s2">&quot; </span><span class="se">\t\r\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">White</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span> <span class="o">=</span> <span class="n">ws</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">whiteChars</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">)</span> <span class="p">)</span>
        <span class="c1">#~ self.leaveWhitespace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">White</span><span class="o">.</span><span class="n">whiteStrs</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="nb">min</span>

        <span class="k">if</span> <span class="nb">max</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">_MAX_INT</span>

        <span class="k">if</span> <span class="n">exact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span> <span class="o">=</span> <span class="n">exact</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span> <span class="o">=</span> <span class="n">exact</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">instring</span><span class="p">[</span> <span class="n">loc</span> <span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxLen</span>
        <span class="n">maxloc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">maxloc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">maxloc</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matchWhite</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">minLen</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_PositionToken</span><span class="p">(</span><span class="n">Token</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">GoToColumn</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token to advance to a specific column of input text; useful for tabular report scraping.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">colno</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GoToColumn</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">colno</span>

    <span class="k">def</span> <span class="nf">preParse</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">(</span><span class="n">loc</span><span class="p">,</span><span class="n">instring</span><span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
            <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipIgnorables</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
            <span class="k">while</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="n">instrlen</span> <span class="ow">and</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">()</span> <span class="ow">and</span> <span class="n">col</span><span class="p">(</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span> <span class="p">)</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="p">:</span>
                <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">thiscol</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span> <span class="n">loc</span><span class="p">,</span> <span class="n">instring</span> <span class="p">)</span>
        <span class="k">if</span> <span class="n">thiscol</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;Text not in expected column&quot;</span><span class="p">,</span> <span class="bp">self</span> <span class="p">)</span>
        <span class="n">newloc</span> <span class="o">=</span> <span class="n">loc</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">-</span> <span class="n">thiscol</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span> <span class="n">loc</span><span class="p">:</span> <span class="n">newloc</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">newloc</span><span class="p">,</span> <span class="n">ret</span>

<span class="k">class</span> <span class="nc">LineStart</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if current position is at the beginning of a line within the parse string&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LineStart</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected start of line&quot;</span>

    <span class="k">def</span> <span class="nf">preParse</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">):</span>
        <span class="n">preloc</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">LineStart</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span><span class="n">loc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">preloc</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span>
            <span class="n">loc</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">loc</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span> <span class="n">loc</span><span class="o">==</span><span class="mi">0</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">loc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="mi">0</span> <span class="p">))</span> <span class="ow">or</span>
            <span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span> <span class="p">):</span> <span class="c1">#col(loc, instring) != 1:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

<span class="k">class</span> <span class="nc">LineEnd</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if current position is at the end of a line within the parse string&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LineEnd</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected end of line&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">StringStart</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if current position is at the beginning of the parse string&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StringStart</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected start of text&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># see if entire string up to here is just whitespace and ignoreables</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preParse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="mi">0</span> <span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

<div class="viewcode-block" id="StringEnd"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.StringEnd.html#matplotlib.mathtext.StringEnd">[docs]</a><span class="k">class</span> <span class="nc">StringEnd</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if current position is at the end of the parse string&quot;&quot;&quot;</span>
<div class="viewcode-block" id="StringEnd.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.StringEnd.__init__.html#matplotlib.mathtext.StringEnd.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">StringEnd</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected end of text&quot;</span></div>

<div class="viewcode-block" id="StringEnd.parseImpl"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.StringEnd.parseImpl.html#matplotlib.mathtext.StringEnd.parseImpl">[docs]</a>    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="n">loc</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div></div>

<span class="k">class</span> <span class="nc">WordStart</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if the current position is at the beginning of a Word, and</span>
<span class="sd">       is not preceded by any character in a given set of C{wordChars}</span>
<span class="sd">       (default=C{printables}). To emulate the C{\b} behavior of regular expressions,</span>
<span class="sd">       use C{WordStart(alphanums)}. C{WordStart} will also match at the beginning of</span>
<span class="sd">       the string being parsed, or at the beginning of a line.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordChars</span> <span class="o">=</span> <span class="n">printables</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WordStart</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Not at the start of a word&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="n">loc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span> <span class="ow">or</span>
                <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

<span class="k">class</span> <span class="nc">WordEnd</span><span class="p">(</span><span class="n">_PositionToken</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Matches if the current position is at the end of a Word, and</span>
<span class="sd">       is not followed by any character in a given set of C{wordChars}</span>
<span class="sd">       (default=C{printables}). To emulate the C{\b} behavior of regular expressions,</span>
<span class="sd">       use C{WordEnd(alphanums)}. C{WordEnd} will also match at the end of</span>
<span class="sd">       the string being parsed, or at the end of a line.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordChars</span> <span class="o">=</span> <span class="n">printables</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">WordEnd</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">wordChars</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Not at the end of a word&quot;</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">instrlen</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">loc</span><span class="o">&lt;</span><span class="n">instrlen</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span> <span class="ow">or</span>
                <span class="n">instring</span><span class="p">[</span><span class="n">loc</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">wordChars</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>


<span class="k">class</span> <span class="nc">ParseExpression</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract subclass of ParserElement, for combining and post-processing parsed tokens.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">_generatorType</span> <span class="p">):</span>
            <span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">exprs</span> <span class="p">)</span> <span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span> <span class="p">):</span>
            <span class="c1"># if sequence of strings provided, wrap with Literal</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">basestring</span><span class="p">)</span> <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">exprs</span><span class="p">):</span>
                <span class="n">exprs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">,</span> <span class="n">exprs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span> <span class="n">exprs</span> <span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">exprs</span> <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">i</span> <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">leaveWhitespace</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Extends C{leaveWhitespace} defined in base class, and also invokes C{leaveWhitespace} on</span>
<span class="sd">           all contained expressions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">Suppress</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span> <span class="n">ParseExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                    <span class="n">e</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span> <span class="n">ParseExpression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
                <span class="n">e</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>

        <span class="c1"># collapse nested And&#39;s of the form And( And( And( a,b), c), d) to And( a,b,c,d )</span>
        <span class="c1"># but only if there are no parse actions or resultsNames on the nested And&#39;s</span>
        <span class="c1"># (likewise for Or&#39;s and MatchFirst&#39;s)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="p">)</span> <span class="ow">and</span>
                  <span class="ow">not</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">parseAction</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="n">other</span><span class="o">.</span><span class="n">resultsName</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                  <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">debug</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span>  <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayIndexError</span>

            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="p">)</span> <span class="ow">and</span>
                  <span class="ow">not</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">parseAction</span><span class="p">)</span> <span class="ow">and</span>
                  <span class="n">other</span><span class="o">.</span><span class="n">resultsName</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
                  <span class="ow">not</span> <span class="n">other</span><span class="o">.</span><span class="n">debug</span> <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">exprs</span><span class="p">[:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span>  <span class="o">|=</span> <span class="n">other</span><span class="o">.</span><span class="n">mayIndexError</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Expected &quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">setResultsName</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">listAllMatches</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="p">[]</span> <span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">validateTrace</span><span class="p">[:]</span><span class="o">+</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">exprs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span>

<span class="k">class</span> <span class="nc">And</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Requires all given C{ParseExpression}s to be found in the given order.</span>
<span class="sd">       Expressions may be separated by whitespace.</span>
<span class="sd">       May be constructed using the C{&#39;+&#39;} operator.</span>
<span class="sd">       May also be constructed using the C{&#39;-&#39;} operator, which will suppress backtracking.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">class</span> <span class="nc">_ErrorStop</span><span class="p">(</span><span class="n">Empty</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">And</span><span class="o">.</span><span class="n">_ErrorStop</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span> <span class="o">=</span> <span class="kc">True</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">And</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">whiteChars</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">skipWhitespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="c1"># pass False as last arg to _parse for first element, since we already</span>
        <span class="c1"># pre-parsed the string as part of our And pre-parsing</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">resultlist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="n">errorStop</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">And</span><span class="o">.</span><span class="n">_ErrorStop</span><span class="p">):</span>
                <span class="n">errorStop</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">errorStop</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">loc</span><span class="p">,</span> <span class="n">exprtokens</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span> <span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseSyntaxException</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">except</span> <span class="n">ParseBaseException</span> <span class="k">as</span> <span class="n">pe</span><span class="p">:</span>
                    <span class="n">pe</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">raise</span> <span class="n">ParseSyntaxException</span><span class="p">(</span><span class="n">pe</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">ParseSyntaxException</span><span class="p">(</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">exprtokens</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">exprtokens</span> <span class="ow">or</span> <span class="n">exprtokens</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
                <span class="n">resultlist</span> <span class="o">+=</span> <span class="n">exprtokens</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">resultlist</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span> <span class="c1">#And( [ self, other ] )</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span> <span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span> <span class="bp">self</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span> <span class="n">subRecCheckList</span> <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>


<span class="k">class</span> <span class="nc">Or</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Requires that at least one C{ParseExpression} is found.</span>
<span class="sd">       If two expressions match, the expression that matches the longest string will be used.</span>
<span class="sd">       May be constructed using the C{&#39;^&#39;} operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Or</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">maxException</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">matches</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">loc2</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">tryParse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
            <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="n">err</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">err</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span><span class="n">e</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># save match among all matches, to retry longest to shortest</span>
                <span class="n">matches</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">loc2</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">matches</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">e</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span> <span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                    <span class="n">err</span><span class="o">.</span><span class="n">__traceback__</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                        <span class="n">maxException</span> <span class="o">=</span> <span class="n">err</span>
                        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span>

        <span class="k">if</span> <span class="n">maxException</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">maxException</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span>
            <span class="k">raise</span> <span class="n">maxException</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;no defined alternatives to match&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__ixor__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span> <span class="c1">#Or( [ self, other ] )</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; ^ &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span> <span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span> <span class="bp">self</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span> <span class="n">subRecCheckList</span> <span class="p">)</span>


<span class="k">class</span> <span class="nc">MatchFirst</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Requires that at least one C{ParseExpression} is found.</span>
<span class="sd">       If two expressions match, the first one listed is the one that will match.</span>
<span class="sd">       May be constructed using the C{&#39;|&#39;} operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span> <span class="o">=</span> <span class="kc">False</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MatchFirst</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">maxException</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span> <span class="p">)</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">except</span> <span class="n">ParseException</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">err</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="n">err</span><span class="o">.</span><span class="n">loc</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxExcLoc</span><span class="p">:</span>
                    <span class="n">maxException</span> <span class="o">=</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">),</span><span class="n">e</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>
                    <span class="n">maxExcLoc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>

        <span class="c1"># only got here if no expression matched, raise exception for match that made it the furthest</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">maxException</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">maxException</span><span class="o">.</span><span class="n">msg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span>
                <span class="k">raise</span> <span class="n">maxException</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="s2">&quot;no defined alternatives to match&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ior__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span> <span class="c1">#MatchFirst( [ self, other ] )</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span> <span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span> <span class="bp">self</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span> <span class="n">subRecCheckList</span> <span class="p">)</span>


<span class="k">class</span> <span class="nc">Each</span><span class="p">(</span><span class="n">ParseExpression</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Requires all given C{ParseExpression}s to be found, but in any order.</span>
<span class="sd">       Expressions may be separated by whitespace.</span>
<span class="sd">       May be constructed using the C{&#39;&amp;&#39;} operator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span> <span class="o">=</span> <span class="kc">True</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Each</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">exprs</span><span class="p">,</span> <span class="n">savelist</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initExprGroups</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">initExprGroups</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opt1map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="nb">id</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">expr</span><span class="p">),</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">Optional</span><span class="p">))</span>
            <span class="n">opt1</span> <span class="o">=</span> <span class="p">[</span> <span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">Optional</span><span class="p">)</span> <span class="p">]</span>
            <span class="n">opt2</span> <span class="o">=</span> <span class="p">[</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">Optional</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">optionals</span> <span class="o">=</span> <span class="n">opt1</span> <span class="o">+</span> <span class="n">opt2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multioptionals</span> <span class="o">=</span> <span class="p">[</span> <span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">ZeroOrMore</span><span class="p">)</span> <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">multirequired</span> <span class="o">=</span> <span class="p">[</span> <span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">OneOrMore</span><span class="p">)</span> <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">required</span> <span class="o">=</span> <span class="p">[</span> <span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,(</span><span class="n">Optional</span><span class="p">,</span><span class="n">ZeroOrMore</span><span class="p">,</span><span class="n">OneOrMore</span><span class="p">))</span> <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">required</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multirequired</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">initExprGroups</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">tmpLoc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">tmpReqd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">required</span><span class="p">[:]</span>
        <span class="n">tmpOpt</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">optionals</span><span class="p">[:]</span>
        <span class="n">matchOrder</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">keepMatching</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">keepMatching</span><span class="p">:</span>
            <span class="n">tmpExprs</span> <span class="o">=</span> <span class="n">tmpReqd</span> <span class="o">+</span> <span class="n">tmpOpt</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">multioptionals</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">multirequired</span>
            <span class="n">failed</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpExprs</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">tmpLoc</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">tryParse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">tmpLoc</span> <span class="p">)</span>
                <span class="k">except</span> <span class="n">ParseException</span><span class="p">:</span>
                    <span class="n">failed</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">matchOrder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">opt1map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">e</span><span class="p">),</span><span class="n">e</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpReqd</span><span class="p">:</span>
                        <span class="n">tmpReqd</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpOpt</span><span class="p">:</span>
                        <span class="n">tmpOpt</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">failed</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmpExprs</span><span class="p">):</span>
                <span class="n">keepMatching</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">tmpReqd</span><span class="p">:</span>
            <span class="n">missing</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">tmpReqd</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span><span class="n">loc</span><span class="p">,</span><span class="s2">&quot;Missing one or more required elements (</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">missing</span> <span class="p">)</span>

        <span class="c1"># add any unmatched Optionals, in case they have default values defined</span>
        <span class="n">matchOrder</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">Optional</span><span class="p">)</span> <span class="ow">and</span> <span class="n">e</span><span class="o">.</span><span class="n">expr</span> <span class="ow">in</span> <span class="n">tmpOpt</span><span class="p">]</span>

        <span class="n">resultlist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">matchOrder</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span><span class="n">results</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span><span class="n">loc</span><span class="p">,</span><span class="n">doActions</span><span class="p">)</span>
            <span class="n">resultlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

        <span class="n">finalResults</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">resultlist</span><span class="p">:</span>
            <span class="n">dups</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">r</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">finalResults</span><span class="p">:</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">finalResults</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">tmp</span> <span class="o">+=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="n">dups</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="n">finalResults</span> <span class="o">+=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">dups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">finalResults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">finalResults</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot; &amp; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_ustr</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span> <span class="p">):</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span> <span class="bp">self</span> <span class="p">]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">exprs</span><span class="p">:</span>
            <span class="n">e</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span> <span class="n">subRecCheckList</span> <span class="p">)</span>


<span class="k">class</span> <span class="nc">ParseElementEnhance</span><span class="p">(</span><span class="n">ParserElement</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract subclass of C{ParserElement}, for combining and post-processing parsed tokens.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">savelist</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">expr</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">mayIndexError</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span> <span class="n">expr</span><span class="o">.</span><span class="n">whiteChars</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">skipWhitespace</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">saveAsList</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">callPreparse</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">loc</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">leaveWhitespace</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">Suppress</span> <span class="p">):</span>
            <span class="k">if</span> <span class="n">other</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span> <span class="n">ParseElementEnhance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span> <span class="n">ParseElementEnhance</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">checkRecursion</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">parseElementList</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">in</span> <span class="n">parseElementList</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">RecursiveGrammarException</span><span class="p">(</span> <span class="n">parseElementList</span><span class="o">+</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">subRecCheckList</span> <span class="o">=</span> <span class="n">parseElementList</span><span class="p">[:]</span> <span class="o">+</span> <span class="p">[</span> <span class="bp">self</span> <span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span> <span class="n">subRecCheckList</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="p">[]</span> <span class="p">):</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">validateTrace</span><span class="p">[:]</span><span class="o">+</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">(</span> <span class="p">[]</span> <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:(</span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>


<div class="viewcode-block" id="FollowedBy"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.FollowedBy.html#matplotlib.mathtext.FollowedBy">[docs]</a><span class="k">class</span> <span class="nc">FollowedBy</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lookahead matching of the given parse expression.  C{FollowedBy}</span>
<span class="sd">    does *not* advance the parsing position within the input string, it only</span>
<span class="sd">    verifies that the specified parse expression matches at the current</span>
<span class="sd">    position.  C{FollowedBy} always returns a null token list.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="FollowedBy.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.FollowedBy.__init__.html#matplotlib.mathtext.FollowedBy.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FollowedBy</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="FollowedBy.parseImpl"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.FollowedBy.parseImpl.html#matplotlib.mathtext.FollowedBy.parseImpl">[docs]</a>    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">tryParse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span></div></div>


<span class="k">class</span> <span class="nc">NotAny</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Lookahead to disallow matching with the given parse expression.  C{NotAny}</span>
<span class="sd">    does *not* advance the parsing position within the input string, it only</span>
<span class="sd">    verifies that the specified parse expression does *not* match at the current</span>
<span class="sd">    position.  Also, C{NotAny} does *not* skip over leading whitespace. C{NotAny}</span>
<span class="sd">    always returns a null token list.  May be constructed using the &#39;~&#39; operator.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NotAny</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="c1">#~ self.leaveWhitespace()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># do NOT use self.leaveWhitespace(), don&#39;t want to propagate to exprs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Found unwanted token, &quot;</span><span class="o">+</span><span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">canParseNext</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;~{&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>


<div class="viewcode-block" id="OneOrMore"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.OneOrMore.html#matplotlib.mathtext.OneOrMore">[docs]</a><span class="k">class</span> <span class="nc">OneOrMore</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Repetition of one or more of the given expression.</span>
<span class="sd">    </span>
<span class="sd">       Parameters:</span>
<span class="sd">        - expr - expression that must match one or more times</span>
<span class="sd">        - stopOn - (default=None) - expression for a terminating sentinel</span>
<span class="sd">          (only required if the sentinel would ordinarily match the repetition </span>
<span class="sd">          expression)          </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="OneOrMore.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.OneOrMore.__init__.html#matplotlib.mathtext.OneOrMore.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">stopOn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="n">ender</span> <span class="o">=</span> <span class="n">stopOn</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ender</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="n">ender</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">ender</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">not_ender</span> <span class="o">=</span> <span class="o">~</span><span class="n">ender</span> <span class="k">if</span> <span class="n">ender</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="OneOrMore.parseImpl"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.OneOrMore.parseImpl.html#matplotlib.mathtext.OneOrMore.parseImpl">[docs]</a>    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">self_expr_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span>
        <span class="n">self_skip_ignorables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_skipIgnorables</span>
        <span class="n">check_ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_ender</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">check_ender</span><span class="p">:</span>
            <span class="n">try_not_ender</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">not_ender</span><span class="o">.</span><span class="n">tryParse</span>
        
        <span class="c1"># must be at least one (but first see if we are the stopOn sentinel;</span>
        <span class="c1"># if so, fail)</span>
        <span class="k">if</span> <span class="n">check_ender</span><span class="p">:</span>
            <span class="n">try_not_ender</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
        <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="n">self_expr_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">hasIgnoreExprs</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">)</span>
            <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">check_ender</span><span class="p">:</span>
                    <span class="n">try_not_ender</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">hasIgnoreExprs</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">self_skip_ignorables</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">preloc</span> <span class="o">=</span> <span class="n">loc</span>
                <span class="n">loc</span><span class="p">,</span> <span class="n">tmptokens</span> <span class="o">=</span> <span class="n">self_expr_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">preloc</span><span class="p">,</span> <span class="n">doActions</span> <span class="p">)</span>
                <span class="k">if</span> <span class="n">tmptokens</span> <span class="ow">or</span> <span class="n">tmptokens</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
                    <span class="n">tokens</span> <span class="o">+=</span> <span class="n">tmptokens</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span><span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;}...&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span>

<div class="viewcode-block" id="OneOrMore.setResultsName"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.OneOrMore.setResultsName.html#matplotlib.mathtext.OneOrMore.setResultsName">[docs]</a>    <span class="k">def</span> <span class="nf">setResultsName</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">listAllMatches</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">listAllMatches</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">ret</span></div></div>

<div class="viewcode-block" id="ZeroOrMore"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ZeroOrMore.html#matplotlib.mathtext.ZeroOrMore">[docs]</a><span class="k">class</span> <span class="nc">ZeroOrMore</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optional repetition of zero or more of the given expression.</span>
<span class="sd">    </span>
<span class="sd">       Parameters:</span>
<span class="sd">        - expr - expression that must match zero or more times</span>
<span class="sd">        - stopOn - (default=None) - expression for a terminating sentinel</span>
<span class="sd">          (only required if the sentinel would ordinarily match the repetition </span>
<span class="sd">          expression)          </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ZeroOrMore.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ZeroOrMore.__init__.html#matplotlib.mathtext.ZeroOrMore.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">stopOn</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">ZeroOrMore</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">stopOn</span><span class="o">=</span><span class="n">stopOn</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span></div>
        
<div class="viewcode-block" id="ZeroOrMore.parseImpl"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.ZeroOrMore.parseImpl.html#matplotlib.mathtext.ZeroOrMore.parseImpl">[docs]</a>    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ZeroOrMore</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">parseImpl</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span><span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="p">[]</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]...&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span></div>

<span class="k">class</span> <span class="nc">_NullToken</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__bool__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="n">__nonzero__</span> <span class="o">=</span> <span class="n">__bool__</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="n">_optionalNotMatched</span> <span class="o">=</span> <span class="n">_NullToken</span><span class="p">()</span>
<div class="viewcode-block" id="Optional"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Optional.html#matplotlib.mathtext.Optional">[docs]</a><span class="k">class</span> <span class="nc">Optional</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Optional matching of the given expression.</span>

<span class="sd">       Parameters:</span>
<span class="sd">        - expr - expression that must match zero or more times</span>
<span class="sd">        - default (optional) - value to be returned if the optional expression</span>
<span class="sd">          is not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Optional.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Optional.__init__.html#matplotlib.mathtext.Optional.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">_optionalNotMatched</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Optional</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">expr</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span> <span class="o">=</span> <span class="n">default</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Optional.parseImpl"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Optional.parseImpl.html#matplotlib.mathtext.Optional.parseImpl">[docs]</a>    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span><span class="p">(</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span><span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_optionalNotMatched</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">resultsName</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">([</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span> <span class="p">])</span>
                    <span class="n">tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">resultsName</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">defaultValue</span> <span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokens</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="s2">&quot;[&quot;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span></div>

<span class="k">class</span> <span class="nc">SkipTo</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Token for skipping over all undefined text until the matched expression is found.</span>

<span class="sd">       Parameters:</span>
<span class="sd">        - expr - target expression marking the end of the data to be skipped</span>
<span class="sd">        - include - (default=False) if True, the target expression is also parsed </span>
<span class="sd">          (the skipped text and target expression are returned as a 2-element list).</span>
<span class="sd">        - ignore - (default=None) used to define grammars (typically quoted strings and </span>
<span class="sd">          comments) that might contain false matches to the target expression</span>
<span class="sd">        - failOn - (default=None) define expressions that are not allowed to be </span>
<span class="sd">          included in the skipped test; if found before the target expression is found, </span>
<span class="sd">          the SkipTo is not a match</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">include</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ignore</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">failOn</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span> <span class="n">SkipTo</span><span class="p">,</span> <span class="bp">self</span> <span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExpr</span> <span class="o">=</span> <span class="n">ignore</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">includeMatch</span> <span class="o">=</span> <span class="n">include</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">asList</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">failOn</span><span class="p">,</span> <span class="n">basestring</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">failOn</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span> <span class="o">=</span> <span class="n">failOn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;No match found for &quot;</span><span class="o">+</span><span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parseImpl</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="n">startloc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="n">instrlen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instring</span><span class="p">)</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span>
        <span class="n">expr_parse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">_parse</span>
        <span class="n">self_failOn_canParseNext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span><span class="o">.</span><span class="n">canParseNext</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">failOn</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">self_ignoreExpr_tryParse</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExpr</span><span class="o">.</span><span class="n">tryParse</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>
        
        <span class="n">tmploc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="k">while</span> <span class="n">tmploc</span> <span class="o">&lt;=</span> <span class="n">instrlen</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">self_failOn_canParseNext</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># break if failOn expression matches</span>
                <span class="k">if</span> <span class="n">self_failOn_canParseNext</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmploc</span><span class="p">):</span>
                    <span class="k">break</span>
                    
            <span class="k">if</span> <span class="n">self_ignoreExpr_tryParse</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># advance past ignore expressions</span>
                <span class="k">while</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">tmploc</span> <span class="o">=</span> <span class="n">self_ignoreExpr_tryParse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmploc</span><span class="p">)</span>
                    <span class="k">except</span> <span class="n">ParseBaseException</span><span class="p">:</span>
                        <span class="k">break</span>
            
            <span class="k">try</span><span class="p">:</span>
                <span class="n">expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">tmploc</span><span class="p">,</span> <span class="n">doActions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="n">ParseException</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
                <span class="c1"># no match, advance loc in string</span>
                <span class="n">tmploc</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># matched skipto expr, done</span>
                <span class="k">break</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># ran off the end of the input string without matching skipto expr, fail</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errmsg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># build up return values</span>
        <span class="n">loc</span> <span class="o">=</span> <span class="n">tmploc</span>
        <span class="n">skiptext</span> <span class="o">=</span> <span class="n">instring</span><span class="p">[</span><span class="n">startloc</span><span class="p">:</span><span class="n">loc</span><span class="p">]</span>
        <span class="n">skipresult</span> <span class="o">=</span> <span class="n">ParseResults</span><span class="p">(</span><span class="n">skiptext</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">includeMatch</span><span class="p">:</span>
            <span class="n">loc</span><span class="p">,</span> <span class="n">mat</span> <span class="o">=</span> <span class="n">expr_parse</span><span class="p">(</span><span class="n">instring</span><span class="p">,</span><span class="n">loc</span><span class="p">,</span><span class="n">doActions</span><span class="p">,</span><span class="n">callPreParse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">skipresult</span> <span class="o">+=</span> <span class="n">mat</span>

        <span class="k">return</span> <span class="n">loc</span><span class="p">,</span> <span class="n">skipresult</span>

<div class="viewcode-block" id="Forward"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Forward.html#matplotlib.mathtext.Forward">[docs]</a><span class="k">class</span> <span class="nc">Forward</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Forward declaration of an expression to be defined later -</span>
<span class="sd">       used for recursive grammars, such as algebraic infix notation.</span>
<span class="sd">       When the expression is known, it is assigned to the C{Forward} variable using the &#39;&lt;&lt;&#39; operator.</span>

<span class="sd">       Note: take care when assigning to C{Forward} not to overlook precedence of operators.</span>
<span class="sd">       Specifically, &#39;|&#39; has a lower precedence than &#39;&lt;&lt;&#39;, so that::</span>
<span class="sd">          fwdExpr &lt;&lt; a | b | c</span>
<span class="sd">       will actually be evaluated as::</span>
<span class="sd">          (fwdExpr &lt;&lt; a) | b | c</span>
<span class="sd">       thereby leaving b and c out as parseable alternatives.  It is recommended that you</span>
<span class="sd">       explicitly group the values inserted into the C{Forward}::</span>
<span class="sd">          fwdExpr &lt;&lt; (a | b | c)</span>
<span class="sd">       Converting to use the &#39;&lt;&lt;=&#39; operator instead will avoid this problem.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Forward.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Forward.__init__.html#matplotlib.mathtext.Forward.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Forward</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">__lshift__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span> <span class="n">other</span><span class="p">,</span> <span class="n">basestring</span> <span class="p">):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="n">ParserElement</span><span class="o">.</span><span class="n">_literalStringClass</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">other</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strRepr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayIndexError</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">mayIndexError</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mayReturnEmpty</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">mayReturnEmpty</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">whiteChars</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">skipWhitespace</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">saveAsList</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ignoreExprs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
        
    <span class="k">def</span> <span class="nf">__ilshift__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">&lt;&lt;</span> <span class="n">other</span>
    
<div class="viewcode-block" id="Forward.leaveWhitespace"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Forward.leaveWhitespace.html#matplotlib.mathtext.Forward.leaveWhitespace">[docs]</a>    <span class="k">def</span> <span class="nf">leaveWhitespace</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Forward.streamline"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Forward.streamline.html#matplotlib.mathtext.Forward.streamline">[docs]</a>    <span class="k">def</span> <span class="nf">streamline</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">streamlined</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Forward.validate"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Forward.validate.html#matplotlib.mathtext.Forward.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">validateTrace</span><span class="o">=</span><span class="p">[]</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">validateTrace</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">validateTrace</span><span class="p">[:]</span><span class="o">+</span><span class="p">[</span><span class="bp">self</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkRecursion</span><span class="p">([])</span></div>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s2">&quot;: ...&quot;</span>

        <span class="c1"># stubbed out for now - creates awful memory and perf issues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_revertClass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">=</span> <span class="n">_ForwardNoRecurse</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">retString</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">retString</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_revertClass</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">retString</span>

<div class="viewcode-block" id="Forward.copy"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Forward.copy.html#matplotlib.mathtext.Forward.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Forward</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
            <span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="bp">self</span>
            <span class="k">return</span> <span class="n">ret</span></div></div>

<span class="k">class</span> <span class="nc">_ForwardNoRecurse</span><span class="p">(</span><span class="n">Forward</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;...&quot;</span>

<span class="k">class</span> <span class="nc">TokenConverter</span><span class="p">(</span><span class="n">ParseElementEnhance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Abstract subclass of C{ParseExpression}, for converting parsed results.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">savelist</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">expr</span> <span class="p">)</span><span class="c1">#, savelist )</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="Combine"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Combine.html#matplotlib.mathtext.Combine">[docs]</a><span class="k">class</span> <span class="nc">Combine</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converter to concatenate all matching tokens to a single string.</span>
<span class="sd">       By default, the matching patterns must also be contiguous in the input string;</span>
<span class="sd">       this can be disabled by specifying C{&#39;adjacent=False&#39;} in the constructor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Combine.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Combine.__init__.html#matplotlib.mathtext.Combine.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">joinString</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Combine</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">expr</span> <span class="p">)</span>
        <span class="c1"># suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself</span>
        <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjacent</span> <span class="o">=</span> <span class="n">adjacent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skipWhitespace</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">joinString</span> <span class="o">=</span> <span class="n">joinString</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Combine.ignore"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Combine.ignore.html#matplotlib.mathtext.Combine.ignore">[docs]</a>    <span class="k">def</span> <span class="nf">ignore</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">other</span> <span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjacent</span><span class="p">:</span>
            <span class="n">ParserElement</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">(</span> <span class="n">Combine</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span> <span class="n">other</span> <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Combine.postParse"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Combine.postParse.html#matplotlib.mathtext.Combine.postParse">[docs]</a>    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span> <span class="p">):</span>
        <span class="n">retToks</span> <span class="o">=</span> <span class="n">tokenlist</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">retToks</span><span class="p">[:]</span>
        <span class="n">retToks</span> <span class="o">+=</span> <span class="n">ParseResults</span><span class="p">([</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokenlist</span><span class="o">.</span><span class="n">_asStringList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">joinString</span><span class="p">))</span> <span class="p">],</span> <span class="n">modal</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">modalResults</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span> <span class="ow">and</span> <span class="n">retToks</span><span class="o">.</span><span class="n">haskeys</span><span class="p">():</span>
            <span class="k">return</span> <span class="p">[</span> <span class="n">retToks</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">retToks</span></div></div>

<div class="viewcode-block" id="Group"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Group.html#matplotlib.mathtext.Group">[docs]</a><span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converter to return the matched tokens as a list - useful for returning tokens of C{L{ZeroOrMore}} and C{L{OneOrMore}} expressions.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="Group.__init__"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Group.__init__.html#matplotlib.mathtext.Group.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Group</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">expr</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Group.postParse"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Group.postParse.html#matplotlib.mathtext.Group.postParse">[docs]</a>    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span> <span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span> <span class="n">tokenlist</span> <span class="p">]</span></div></div>

<span class="k">class</span> <span class="nc">Dict</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converter to return a repetitive expression as a list, but also as a dictionary.</span>
<span class="sd">       Each element can also be referenced using the first token in the expression as its key.</span>
<span class="sd">       Useful for tabular report scraping when the first column can be used as a item key.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">expr</span> <span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Dict</span><span class="p">,</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span> <span class="n">expr</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">saveAsList</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">tok</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tokenlist</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">ikey</span> <span class="o">=</span> <span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ikey</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
                <span class="n">ikey</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ParseResults</span><span class="p">):</span>
                <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">tok</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dictvalue</span> <span class="o">=</span> <span class="n">tok</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1">#ParseResults(i)</span>
                <span class="k">del</span> <span class="n">dictvalue</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">)</span><span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">)</span> <span class="ow">and</span> <span class="n">dictvalue</span><span class="o">.</span><span class="n">haskeys</span><span class="p">()):</span>
                    <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tokenlist</span><span class="p">[</span><span class="n">ikey</span><span class="p">]</span> <span class="o">=</span> <span class="n">_ParseResultsWithOffset</span><span class="p">(</span><span class="n">dictvalue</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resultsName</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span> <span class="n">tokenlist</span> <span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tokenlist</span>


<div class="viewcode-block" id="Suppress"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Suppress.html#matplotlib.mathtext.Suppress">[docs]</a><span class="k">class</span> <span class="nc">Suppress</span><span class="p">(</span><span class="n">TokenConverter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Converter for ignoring the results of a parsed expression.&quot;&quot;&quot;</span>
<div class="viewcode-block" id="Suppress.postParse"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Suppress.postParse.html#matplotlib.mathtext.Suppress.postParse">[docs]</a>    <span class="k">def</span> <span class="nf">postParse</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">instring</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">tokenlist</span> <span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="Suppress.suppress"><a class="viewcode-back" href="../generated/generated/matplotlib.mathtext.Suppress.suppress.html#matplotlib.mathtext.Suppress.suppress">[docs]</a>    <span class="k">def</span> <span class="nf">suppress</span><span class="p">(</span> <span class="bp">self</span> <span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<span class="k">class</span> <span class="nc">OnlyOnce</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper for parse actions, to ensure they are only called once.&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methodCall</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callable</span> <span class="o">=</span> <span class="n">_trim_arity</span><span class="p">(</span><span class="n">methodCall</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">called</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">callable</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="n">results</span>
        <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">called</span> <span class="o">=</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">traceParseAction</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Decorator for debugging parse actions.&quot;&quot;&quot;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">_trim_arity</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">z</span><span class="p">(</span><span class="o">*</span><span class="n">paArgs</span><span class="p">):</span>
        <span class="n">thisFunc</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__name__</span>
        <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span> <span class="o">=</span> <span class="n">paArgs</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">paArgs</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">thisFunc</span> <span class="o">=</span> <span class="n">paArgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">thisFunc</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="s2">&quot;&gt;&gt;entering </span><span class="si">%s</span><span class="s2">(line: &#39;</span><span class="si">%s</span><span class="s2">&#39;, </span><span class="si">%d</span><span class="s2">, </span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thisFunc</span><span class="p">,</span><span class="n">line</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">s</span><span class="p">),</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">paArgs</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="s2">&quot;&lt;&lt;leaving </span><span class="si">%s</span><span class="s2"> (exception: </span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thisFunc</span><span class="p">,</span><span class="n">exc</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">raise</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="s2">&quot;&lt;&lt;leaving </span><span class="si">%s</span><span class="s2"> (ret: </span><span class="si">%s</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">thisFunc</span><span class="p">,</span><span class="n">ret</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">z</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">z</span>

<span class="c1">#</span>
<span class="c1"># global helpers</span>
<span class="c1">#</span>
<span class="k">def</span> <span class="nf">delimitedList</span><span class="p">(</span> <span class="n">expr</span><span class="p">,</span> <span class="n">delim</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">False</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define a delimited list of expressions - the delimiter defaults to &#39;,&#39;.</span>
<span class="sd">       By default, the list elements and delimiters can have intervening whitespace, and</span>
<span class="sd">       comments, but this can be overridden by passing C{combine=True} in the constructor.</span>
<span class="sd">       If C{combine} is set to C{True}, the matching tokens are returned as a single token</span>
<span class="sd">       string, with the delimiters included; otherwise, the matching tokens are returned</span>
<span class="sd">       as a list of tokens, with the delimiters suppressed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dlName</span> <span class="o">=</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; [&quot;</span><span class="o">+</span><span class="n">_ustr</span><span class="p">(</span><span class="n">delim</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;]...&quot;</span>
    <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Combine</span><span class="p">(</span> <span class="n">expr</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span> <span class="n">delim</span> <span class="o">+</span> <span class="n">expr</span> <span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">dlName</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span> <span class="n">expr</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span> <span class="n">Suppress</span><span class="p">(</span> <span class="n">delim</span> <span class="p">)</span> <span class="o">+</span> <span class="n">expr</span> <span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">dlName</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">countedArray</span><span class="p">(</span> <span class="n">expr</span><span class="p">,</span> <span class="n">intExpr</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define a counted list of expressions.</span>
<span class="sd">       This helper defines a pattern of the form::</span>
<span class="sd">           integer expr expr expr...</span>
<span class="sd">       where the leading integer tells how many expr expressions follow.</span>
<span class="sd">       The matched tokens returns the array of expr tokens as a list - the leading count token is suppressed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arrayExpr</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">countFieldParseAction</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">arrayExpr</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="ow">and</span> <span class="n">Group</span><span class="p">(</span><span class="n">And</span><span class="p">([</span><span class="n">expr</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">))</span> <span class="ow">or</span> <span class="n">Group</span><span class="p">(</span><span class="n">empty</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">intExpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">intExpr</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">intExpr</span> <span class="o">=</span> <span class="n">intExpr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">intExpr</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;arrayLen&quot;</span><span class="p">)</span>
    <span class="n">intExpr</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">countFieldParseAction</span><span class="p">,</span> <span class="n">callDuringTry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">intExpr</span> <span class="o">+</span> <span class="n">arrayExpr</span> <span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;(len) &#39;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;...&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_flatten</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">L</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_flatten</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">matchPreviousLiteral</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from</span>
<span class="sd">       the tokens matched in a previous expression, that is, it looks</span>
<span class="sd">       for a &#39;repeat&#39; of a previous expression.  For example::</span>
<span class="sd">           first = Word(nums)</span>
<span class="sd">           second = matchPreviousLiteral(first)</span>
<span class="sd">           matchExpr = first + &quot;:&quot; + second</span>
<span class="sd">       will match C{&quot;1:1&quot;}, but not C{&quot;1:2&quot;}.  Because this matches a</span>
<span class="sd">       previous literal, will also match the leading C{&quot;1:1&quot;} in C{&quot;1:10&quot;}.</span>
<span class="sd">       If this is not desired, use C{matchPreviousExpr}.</span>
<span class="sd">       Do *not* use with packrat parsing enabled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rep</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">copyTokenToRepeater</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">t</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">rep</span> <span class="o">&lt;&lt;</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># flatten t tokens</span>
                <span class="n">tflat</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">asList</span><span class="p">())</span>
                <span class="n">rep</span> <span class="o">&lt;&lt;</span> <span class="n">And</span><span class="p">(</span><span class="n">Literal</span><span class="p">(</span><span class="n">tt</span><span class="p">)</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">tflat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rep</span> <span class="o">&lt;&lt;</span> <span class="n">Empty</span><span class="p">()</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">copyTokenToRepeater</span><span class="p">,</span> <span class="n">callDuringTry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rep</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;(prev) &#39;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rep</span>

<span class="k">def</span> <span class="nf">matchPreviousExpr</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define an expression that is indirectly defined from</span>
<span class="sd">       the tokens matched in a previous expression, that is, it looks</span>
<span class="sd">       for a &#39;repeat&#39; of a previous expression.  For example::</span>
<span class="sd">           first = Word(nums)</span>
<span class="sd">           second = matchPreviousExpr(first)</span>
<span class="sd">           matchExpr = first + &quot;:&quot; + second</span>
<span class="sd">       will match C{&quot;1:1&quot;}, but not C{&quot;1:2&quot;}.  Because this matches by</span>
<span class="sd">       expressions, will *not* match the leading C{&quot;1:1&quot;} in C{&quot;1:10&quot;};</span>
<span class="sd">       the expressions are evaluated first, and then compared, so</span>
<span class="sd">       C{&quot;1&quot;} is compared with C{&quot;10&quot;}.</span>
<span class="sd">       Do *not* use with packrat parsing enabled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rep</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">rep</span> <span class="o">&lt;&lt;=</span> <span class="n">e2</span>
    <span class="k">def</span> <span class="nf">copyTokenToRepeater</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="n">matchTokens</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">asList</span><span class="p">())</span>
        <span class="k">def</span> <span class="nf">mustMatchTheseTokens</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
            <span class="n">theseTokens</span> <span class="o">=</span> <span class="n">_flatten</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">asList</span><span class="p">())</span>
            <span class="k">if</span>  <span class="n">theseTokens</span> <span class="o">!=</span> <span class="n">matchTokens</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="n">rep</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span> <span class="n">mustMatchTheseTokens</span><span class="p">,</span> <span class="n">callDuringTry</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
    <span class="n">expr</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">copyTokenToRepeater</span><span class="p">,</span> <span class="n">callDuringTry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">rep</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;(prev) &#39;</span> <span class="o">+</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">rep</span>

<span class="k">def</span> <span class="nf">_escapeRegexRangeChars</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="c1">#~  escape these chars: ^-]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="s2">r&quot;\^-]&quot;</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">_bslash</span><span class="o">+</span><span class="n">c</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">r&quot;\n&quot;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span><span class="s2">r&quot;\t&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

<div class="viewcode-block" id="oneOf"><a class="viewcode-back" href="../generated/matplotlib.mathtext.oneOf.html#matplotlib.mathtext.oneOf">[docs]</a><span class="k">def</span> <span class="nf">oneOf</span><span class="p">(</span> <span class="n">strs</span><span class="p">,</span> <span class="n">caseless</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">useRegex</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to quickly define a set of alternative Literals, and makes sure to do</span>
<span class="sd">       longest-first testing when there is a conflict, regardless of the input order,</span>
<span class="sd">       but returns a C{L{MatchFirst}} for best performance.</span>

<span class="sd">       Parameters:</span>
<span class="sd">        - strs - a string of space-delimited literals, or a list of string literals</span>
<span class="sd">        - caseless - (default=False) - treat all literals as caseless</span>
<span class="sd">        - useRegex - (default=True) - as an optimization, will generate a Regex</span>
<span class="sd">          object; otherwise, will generate a C{MatchFirst} object (if C{caseless=True}, or</span>
<span class="sd">          if creating a C{Regex} raises an exception)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">caseless</span><span class="p">:</span>
        <span class="n">isequal</span> <span class="o">=</span> <span class="p">(</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="p">)</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">(</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span> <span class="p">)</span>
        <span class="n">parseElementClass</span> <span class="o">=</span> <span class="n">CaselessLiteral</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">isequal</span> <span class="o">=</span> <span class="p">(</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="p">)</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">(</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">:</span> <span class="n">b</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">)</span>
        <span class="n">parseElementClass</span> <span class="o">=</span> <span class="n">Literal</span>

    <span class="n">symbols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span><span class="n">basestring</span><span class="p">):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="n">strs</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="p">):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">strs</span><span class="p">[:])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strs</span><span class="p">,</span> <span class="n">_generatorType</span><span class="p">):</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">strs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Invalid argument to oneOf, expected string or list&quot;</span><span class="p">,</span>
                <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symbols</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">NoMatch</span><span class="p">()</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">cur</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span><span class="n">other</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">isequal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span> <span class="p">):</span>
                <span class="k">del</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="k">elif</span> <span class="p">(</span> <span class="n">masks</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="p">):</span>
                <span class="k">del</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">symbols</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">other</span><span class="p">)</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">other</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">caseless</span> <span class="ow">and</span> <span class="n">useRegex</span><span class="p">:</span>
        <span class="c1">#~ print (strs,&quot;-&gt;&quot;, &quot;|&quot;.join( [ _escapeRegexChars(sym) for sym in symbols] ))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">symbols</span><span class="p">)):</span>
                <span class="k">return</span> <span class="n">Regex</span><span class="p">(</span> <span class="s2">&quot;[</span><span class="si">%s</span><span class="s2">]&quot;</span> <span class="o">%</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_escapeRegexRangeChars</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Regex</span><span class="p">(</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Exception creating Regex for oneOf, building MatchFirst&quot;</span><span class="p">,</span>
                    <span class="ne">SyntaxWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>


    <span class="c1"># last resort, just use MatchFirst</span>
    <span class="k">return</span> <span class="n">MatchFirst</span><span class="p">(</span><span class="n">parseElementClass</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span> <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span></div>

<span class="k">def</span> <span class="nf">dictOf</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to easily and clearly define a dictionary by specifying the respective patterns</span>
<span class="sd">       for the key and value.  Takes care of defining the C{L{Dict}}, C{L{ZeroOrMore}}, and C{L{Group}} tokens</span>
<span class="sd">       in the proper order.  The key pattern can include delimiting markers or punctuation,</span>
<span class="sd">       as long as they are suppressed, thereby leaving the significant key text.  The value</span>
<span class="sd">       pattern can include named results, so that the C{Dict} results can include named token</span>
<span class="sd">       fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Dict</span><span class="p">(</span> <span class="n">ZeroOrMore</span><span class="p">(</span> <span class="n">Group</span> <span class="p">(</span> <span class="n">key</span> <span class="o">+</span> <span class="n">value</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">originalTextFor</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">asString</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to return the original, untokenized text for a given expression.  Useful to</span>
<span class="sd">       restore the parsed fields of an HTML start tag into the raw tag text itself, or to</span>
<span class="sd">       revert separate tokens with intervening whitespace back to the original matching</span>
<span class="sd">       input text. By default, returns astring containing the original parsed text.  </span>
<span class="sd">       </span>
<span class="sd">       If the optional C{asString} argument is passed as C{False}, then the return value is a </span>
<span class="sd">       C{L{ParseResults}} containing any results names that were originally matched, and a </span>
<span class="sd">       single token containing the original matched text from the input string.  So if </span>
<span class="sd">       the expression passed to C{L{originalTextFor}} contains expressions with defined</span>
<span class="sd">       results names, you must set C{asString} to C{False} if you want to preserve those</span>
<span class="sd">       results name values.&quot;&quot;&quot;</span>
    <span class="n">locMarker</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">loc</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="n">loc</span><span class="p">)</span>
    <span class="n">endlocMarker</span> <span class="o">=</span> <span class="n">locMarker</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">endlocMarker</span><span class="o">.</span><span class="n">callPreparse</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">locMarker</span><span class="p">(</span><span class="s2">&quot;_original_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">expr</span> <span class="o">+</span> <span class="n">endlocMarker</span><span class="p">(</span><span class="s2">&quot;_original_end&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">asString</span><span class="p">:</span>
        <span class="n">extractText</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">_original_start</span><span class="p">:</span><span class="n">t</span><span class="o">.</span><span class="n">_original_end</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">extractText</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
            <span class="n">t</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_original_start&#39;</span><span class="p">):</span><span class="n">t</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;_original_end&#39;</span><span class="p">)]]</span>
    <span class="n">matchExpr</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">extractText</span><span class="p">)</span>
    <span class="n">matchExpr</span><span class="o">.</span><span class="n">ignoreExprs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">ignoreExprs</span>
    <span class="k">return</span> <span class="n">matchExpr</span>

<span class="k">def</span> <span class="nf">ungroup</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;Helper to undo pyparsing&#39;s default grouping of And expressions, even</span>
<span class="sd">       if all but one are non-empty.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">TokenConverter</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">locatedExpr</span><span class="p">(</span><span class="n">expr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to decorate a returned token with its starting and ending locations in the input string.</span>
<span class="sd">       This helper adds the following results names:</span>
<span class="sd">        - locn_start = location where matched expression begins</span>
<span class="sd">        - locn_end = location where matched expression ends</span>
<span class="sd">        - value = the actual parsed results</span>

<span class="sd">       Be careful if the input text contains C{&lt;TAB&gt;} characters, you may want to call</span>
<span class="sd">       C{L{ParserElement.parseWithTabs}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">locator</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="n">l</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Group</span><span class="p">(</span><span class="n">locator</span><span class="p">(</span><span class="s2">&quot;locn_start&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">expr</span><span class="p">(</span><span class="s2">&quot;value&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">locator</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()(</span><span class="s2">&quot;locn_end&quot;</span><span class="p">))</span>


<span class="c1"># convenience constants for positional expressions</span>
<span class="n">empty</span>       <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;empty&quot;</span><span class="p">)</span>
<span class="n">lineStart</span>   <span class="o">=</span> <span class="n">LineStart</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;lineStart&quot;</span><span class="p">)</span>
<span class="n">lineEnd</span>     <span class="o">=</span> <span class="n">LineEnd</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;lineEnd&quot;</span><span class="p">)</span>
<span class="n">stringStart</span> <span class="o">=</span> <span class="n">StringStart</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;stringStart&quot;</span><span class="p">)</span>
<span class="n">stringEnd</span>   <span class="o">=</span> <span class="n">StringEnd</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;stringEnd&quot;</span><span class="p">)</span>

<span class="n">_escapedPunc</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span> <span class="n">_bslash</span><span class="p">,</span> <span class="s2">r&quot;\[]-*.$+^?()~ &quot;</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">2</span> <span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
<span class="n">_escapedHexChar</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;</span><span class="se">\\</span><span class="s2">0?[xX][0-9a-fA-F]+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span><span class="n">unichr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">r&#39;\0x&#39;</span><span class="p">),</span><span class="mi">16</span><span class="p">)))</span>
<span class="n">_escapedOctChar</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;</span><span class="se">\\</span><span class="s2">0[0-7]+&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span><span class="n">unichr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">8</span><span class="p">)))</span>
<span class="n">_singleChar</span> <span class="o">=</span> <span class="n">_escapedPunc</span> <span class="o">|</span> <span class="n">_escapedHexChar</span> <span class="o">|</span> <span class="n">_escapedOctChar</span> <span class="o">|</span> <span class="n">Word</span><span class="p">(</span><span class="n">printables</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="s1">r&#39;\]&#39;</span><span class="p">,</span> <span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;\w&quot;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">UNICODE</span><span class="p">)</span>
<span class="n">_charRange</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">_singleChar</span> <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">_singleChar</span><span class="p">)</span>
<span class="n">_reBracketExpr</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;^&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;negate&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span> <span class="n">OneOrMore</span><span class="p">(</span> <span class="n">_charRange</span> <span class="o">|</span> <span class="n">_singleChar</span> <span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span>

<span class="k">def</span> <span class="nf">srange</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">r&quot;&quot;&quot;Helper to easily define string ranges for use in Word construction.  Borrows</span>
<span class="sd">       syntax from regexp &#39;[]&#39; string range definitions::</span>
<span class="sd">          srange(&quot;[0-9]&quot;)   -&gt; &quot;0123456789&quot;</span>
<span class="sd">          srange(&quot;[a-z]&quot;)   -&gt; &quot;abcdefghijklmnopqrstuvwxyz&quot;</span>
<span class="sd">          srange(&quot;[a-z$_]&quot;) -&gt; &quot;abcdefghijklmnopqrstuvwxyz$_&quot;</span>
<span class="sd">       The input string must be enclosed in []&#39;s, and the returned string is the expanded</span>
<span class="sd">       character set joined into a single string.</span>
<span class="sd">       The values enclosed in the []&#39;s may be::</span>
<span class="sd">          a single character</span>
<span class="sd">          an escaped character with a leading backslash (such as \- or \])</span>
<span class="sd">          an escaped hex character with a leading &#39;\x&#39; (\x21, which is a &#39;!&#39; character) </span>
<span class="sd">            (\0x## is also supported for backwards compatibility) </span>
<span class="sd">          an escaped octal character with a leading &#39;\0&#39; (\041, which is a &#39;!&#39; character)</span>
<span class="sd">          a range of any of the above, separated by a dash (&#39;a-z&#39;, etc.)</span>
<span class="sd">          any combination of the above (&#39;aeiouy&#39;, &#39;a-zA-Z0-9_$&#39;, etc.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_expanded</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="n">p</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">ParseResults</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">unichr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">ord</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_expanded</span><span class="p">(</span><span class="n">part</span><span class="p">)</span> <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">_reBracketExpr</span><span class="o">.</span><span class="n">parseString</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

<span class="k">def</span> <span class="nf">matchOnlyAtCol</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for defining parse actions that require matching at a specific</span>
<span class="sd">       column in the input text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">verifyCol</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span><span class="n">locn</span><span class="p">,</span><span class="n">toks</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">col</span><span class="p">(</span><span class="n">locn</span><span class="p">,</span><span class="n">strg</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">strg</span><span class="p">,</span><span class="n">locn</span><span class="p">,</span><span class="s2">&quot;matched token not at column </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">verifyCol</span>

<span class="k">def</span> <span class="nf">replaceWith</span><span class="p">(</span><span class="n">replStr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for common parse actions that simply return a literal value.  Especially</span>
<span class="sd">       useful when used with C{L{transformString&lt;ParserElement.transformString&gt;}()}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="p">[</span><span class="n">replStr</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">removeQuotes</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper parse action for removing quotation marks from parsed quoted strings.</span>
<span class="sd">       To use, add this parse action to quoted string using::</span>
<span class="sd">         quotedString.setParseAction( removeQuotes )</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">tokenMap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to define a parse action by mapping a function to all elements of a ParseResults list.If any additional </span>
<span class="sd">       args are passed, they are forwarded to the given function as additional arguments after</span>
<span class="sd">       the token, as in C{hex_integer = Word(hexnums).setParseAction(tokenMap(int, 16))}, which will convert the</span>
<span class="sd">       parsed data to an integer using base 16.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="n">t</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">tokn</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="k">for</span> <span class="n">tokn</span> <span class="ow">in</span> <span class="n">t</span><span class="p">]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__name__&#39;</span><span class="p">,</span> 
                            <span class="nb">getattr</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="s1">&#39;__class__&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="n">pa</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">func_name</span>

    <span class="k">return</span> <span class="n">pa</span>

<span class="n">upcaseTokens</span> <span class="o">=</span> <span class="n">tokenMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
<span class="sd">&quot;&quot;&quot;Helper parse action to convert tokens to upper case.&quot;&quot;&quot;</span>

<span class="n">downcaseTokens</span> <span class="o">=</span> <span class="n">tokenMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">_ustr</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
<span class="sd">&quot;&quot;&quot;Helper parse action to convert tokens to lower case.&quot;&quot;&quot;</span>
    
<span class="k">def</span> <span class="nf">_makeTags</span><span class="p">(</span><span class="n">tagStr</span><span class="p">,</span> <span class="n">xml</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Internal helper to construct opening and closing tag expressions, given a tag name&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tagStr</span><span class="p">,</span><span class="n">basestring</span><span class="p">):</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">tagStr</span>
        <span class="n">tagStr</span> <span class="o">=</span> <span class="n">Keyword</span><span class="p">(</span><span class="n">tagStr</span><span class="p">,</span> <span class="n">caseless</span><span class="o">=</span><span class="ow">not</span> <span class="n">xml</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">resname</span> <span class="o">=</span> <span class="n">tagStr</span><span class="o">.</span><span class="n">name</span>

    <span class="n">tagAttrName</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span><span class="n">alphanums</span><span class="o">+</span><span class="s2">&quot;_-:&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">xml</span><span class="p">):</span>
        <span class="n">tagAttrValue</span> <span class="o">=</span> <span class="n">dblQuotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span> <span class="n">removeQuotes</span> <span class="p">)</span>
        <span class="n">openTag</span> <span class="o">=</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tagStr</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">)</span> <span class="o">+</span> \
                <span class="n">Dict</span><span class="p">(</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">Group</span><span class="p">(</span> <span class="n">tagAttrName</span> <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tagAttrValue</span> <span class="p">)))</span> <span class="o">+</span> \
                <span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">])</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;empty&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">printablesLessRAbrack</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">printables</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>
        <span class="n">tagAttrValue</span> <span class="o">=</span> <span class="n">quotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span> <span class="n">removeQuotes</span> <span class="p">)</span> <span class="o">|</span> <span class="n">Word</span><span class="p">(</span><span class="n">printablesLessRAbrack</span><span class="p">)</span>
        <span class="n">openTag</span> <span class="o">=</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tagStr</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">)</span> <span class="o">+</span> \
                <span class="n">Dict</span><span class="p">(</span><span class="n">ZeroOrMore</span><span class="p">(</span><span class="n">Group</span><span class="p">(</span> <span class="n">tagAttrName</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">downcaseTokens</span><span class="p">)</span> <span class="o">+</span> \
                <span class="n">Optional</span><span class="p">(</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tagAttrValue</span> <span class="p">)</span> <span class="p">)))</span> <span class="o">+</span> \
                <span class="n">Optional</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span><span class="n">default</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">])</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;empty&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>
    <span class="n">closeTag</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">_L</span><span class="p">(</span><span class="s2">&quot;&lt;/&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">tagStr</span> <span class="o">+</span> <span class="s2">&quot;&gt;&quot;</span><span class="p">)</span>

    <span class="n">openTag</span> <span class="o">=</span> <span class="n">openTag</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="o">+</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">resname</span><span class="p">)</span>
    <span class="n">closeTag</span> <span class="o">=</span> <span class="n">closeTag</span><span class="o">.</span><span class="n">setResultsName</span><span class="p">(</span><span class="s2">&quot;end&quot;</span><span class="o">+</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resname</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;&lt;/</span><span class="si">%s</span><span class="s2">&gt;&quot;</span> <span class="o">%</span> <span class="n">resname</span><span class="p">)</span>
    <span class="n">openTag</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">resname</span>
    <span class="n">closeTag</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">resname</span>
    <span class="k">return</span> <span class="n">openTag</span><span class="p">,</span> <span class="n">closeTag</span>

<span class="k">def</span> <span class="nf">makeHTMLTags</span><span class="p">(</span><span class="n">tagStr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for HTML, given a tag name&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_makeTags</span><span class="p">(</span> <span class="n">tagStr</span><span class="p">,</span> <span class="kc">False</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">makeXMLTags</span><span class="p">(</span><span class="n">tagStr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to construct opening and closing tag expressions for XML, given a tag name&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_makeTags</span><span class="p">(</span> <span class="n">tagStr</span><span class="p">,</span> <span class="kc">True</span> <span class="p">)</span>

<span class="k">def</span> <span class="nf">withAttribute</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span><span class="o">**</span><span class="n">attrDict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper to create a validating parse action to be used with start tags created</span>
<span class="sd">       with C{L{makeXMLTags}} or C{L{makeHTMLTags}}. Use C{withAttribute} to qualify a starting tag</span>
<span class="sd">       with a required attribute value, to avoid false matches on common tags such as</span>
<span class="sd">       C{&lt;TD&gt;} or C{&lt;DIV&gt;}.</span>

<span class="sd">       Call C{withAttribute} with a series of attribute names and values. Specify the list</span>
<span class="sd">       of filter attributes names and values as:</span>
<span class="sd">        - keyword arguments, as in C{(align=&quot;right&quot;)}, or</span>
<span class="sd">        - as an explicit dict with C{**} operator, when an attribute name is also a Python</span>
<span class="sd">          reserved word, as in C{**{&quot;class&quot;:&quot;Customer&quot;, &quot;align&quot;:&quot;right&quot;}}</span>
<span class="sd">        - a list of name-value tuples, as in ( (&quot;ns1:class&quot;, &quot;Customer&quot;), (&quot;ns2:align&quot;,&quot;right&quot;) )</span>
<span class="sd">       For attribute names with a namespace prefix, you must use the second form.  Attribute</span>
<span class="sd">       names are matched insensitive to upper/lower case.</span>
<span class="sd">       </span>
<span class="sd">       If just testing for C{class} (with or without a namespace), use C{L{withClass}}.</span>

<span class="sd">       To verify that the attribute exists, but without specifying a value, pass</span>
<span class="sd">       C{withAttribute.ANY_VALUE} as the value.</span>
<span class="sd">       &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">args</span><span class="p">[:]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="n">attrDict</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="n">attrs</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">]</span>
    <span class="k">def</span> <span class="nf">pa</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">tokens</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">attrName</span><span class="p">,</span><span class="n">attrValue</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">attrName</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="s2">&quot;no matching attribute &quot;</span> <span class="o">+</span> <span class="n">attrName</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attrValue</span> <span class="o">!=</span> <span class="n">withAttribute</span><span class="o">.</span><span class="n">ANY_VALUE</span> <span class="ow">and</span> <span class="n">tokens</span><span class="p">[</span><span class="n">attrName</span><span class="p">]</span> <span class="o">!=</span> <span class="n">attrValue</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="s2">&quot;attribute &#39;</span><span class="si">%s</span><span class="s2">&#39; has value &#39;</span><span class="si">%s</span><span class="s2">&#39;, must be &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span>
                                            <span class="p">(</span><span class="n">attrName</span><span class="p">,</span> <span class="n">tokens</span><span class="p">[</span><span class="n">attrName</span><span class="p">],</span> <span class="n">attrValue</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">pa</span>
<span class="n">withAttribute</span><span class="o">.</span><span class="n">ANY_VALUE</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">withClass</span><span class="p">(</span><span class="n">classname</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Simplified version of C{L{withAttribute}} when matching on a div class - made</span>
<span class="sd">       difficult because C{class} is a reserved word in Python.</span>
<span class="sd">       &quot;&quot;&quot;</span>
    <span class="n">classattr</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">:class&quot;</span> <span class="o">%</span> <span class="n">namespace</span> <span class="k">if</span> <span class="n">namespace</span> <span class="k">else</span> <span class="s2">&quot;class&quot;</span>
    <span class="k">return</span> <span class="n">withAttribute</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">classattr</span> <span class="p">:</span> <span class="n">classname</span><span class="p">})</span>        

<span class="n">opAssoc</span> <span class="o">=</span> <span class="n">_Constants</span><span class="p">()</span>
<span class="n">opAssoc</span><span class="o">.</span><span class="n">LEFT</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>
<span class="n">opAssoc</span><span class="o">.</span><span class="n">RIGHT</span> <span class="o">=</span> <span class="nb">object</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">infixNotation</span><span class="p">(</span> <span class="n">baseExpr</span><span class="p">,</span> <span class="n">opList</span><span class="p">,</span> <span class="n">lpar</span><span class="o">=</span><span class="n">Suppress</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">),</span> <span class="n">rpar</span><span class="o">=</span><span class="n">Suppress</span><span class="p">(</span><span class="s1">&#39;)&#39;</span><span class="p">)</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for constructing grammars of expressions made up of</span>
<span class="sd">       operators working in a precedence hierarchy.  Operators may be unary or</span>
<span class="sd">       binary, left- or right-associative.  Parse actions can also be attached</span>
<span class="sd">       to operator expressions.</span>

<span class="sd">       Parameters:</span>
<span class="sd">        - baseExpr - expression representing the most basic element for the nested</span>
<span class="sd">        - opList - list of tuples, one for each operator precedence level in the</span>
<span class="sd">          expression grammar; each tuple is of the form</span>
<span class="sd">          (opExpr, numTerms, rightLeftAssoc, parseAction), where:</span>
<span class="sd">           - opExpr is the pyparsing expression for the operator;</span>
<span class="sd">              may also be a string, which will be converted to a Literal;</span>
<span class="sd">              if numTerms is 3, opExpr is a tuple of two expressions, for the</span>
<span class="sd">              two operators separating the 3 terms</span>
<span class="sd">           - numTerms is the number of terms for this operator (must</span>
<span class="sd">              be 1, 2, or 3)</span>
<span class="sd">           - rightLeftAssoc is the indicator whether the operator is</span>
<span class="sd">              right or left associative, using the pyparsing-defined</span>
<span class="sd">              constants C{opAssoc.RIGHT} and C{opAssoc.LEFT}.</span>
<span class="sd">           - parseAction is the parse action to be associated with</span>
<span class="sd">              expressions matching this operator expression (the</span>
<span class="sd">              parse action tuple member may be omitted)</span>
<span class="sd">        - lpar - expression for matching left-parentheses (default=Suppress(&#39;(&#39;))</span>
<span class="sd">        - rpar - expression for matching right-parentheses (default=Suppress(&#39;)&#39;))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="n">lastExpr</span> <span class="o">=</span> <span class="n">baseExpr</span> <span class="o">|</span> <span class="p">(</span> <span class="n">lpar</span> <span class="o">+</span> <span class="n">ret</span> <span class="o">+</span> <span class="n">rpar</span> <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">operDef</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">opList</span><span class="p">):</span>
        <span class="n">opExpr</span><span class="p">,</span><span class="n">arity</span><span class="p">,</span><span class="n">rightLeftAssoc</span><span class="p">,</span><span class="n">pa</span> <span class="o">=</span> <span class="p">(</span><span class="n">operDef</span> <span class="o">+</span> <span class="p">(</span><span class="kc">None</span><span class="p">,))[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">termName</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> term&quot;</span> <span class="o">%</span> <span class="n">opExpr</span> <span class="k">if</span> <span class="n">arity</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="s2"> term&quot;</span> <span class="o">%</span> <span class="n">opExpr</span>
        <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">opExpr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">opExpr</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;if numterms=3, opExpr must be a tuple or list of two expressions&quot;</span><span class="p">)</span>
            <span class="n">opExpr1</span><span class="p">,</span> <span class="n">opExpr2</span> <span class="o">=</span> <span class="n">opExpr</span>
        <span class="n">thisExpr</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">termName</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rightLeftAssoc</span> <span class="o">==</span> <span class="n">opAssoc</span><span class="o">.</span><span class="n">LEFT</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">FollowedBy</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span> <span class="n">opExpr</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">FollowedBy</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr</span> <span class="o">+</span> <span class="n">lastExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span> <span class="n">opExpr</span> <span class="o">+</span> <span class="n">lastExpr</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">FollowedBy</span><span class="p">(</span><span class="n">lastExpr</span><span class="o">+</span><span class="n">lastExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">lastExpr</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">FollowedBy</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr1</span> <span class="o">+</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr2</span> <span class="o">+</span> <span class="n">lastExpr</span><span class="p">)</span> <span class="o">+</span> \
                            <span class="n">Group</span><span class="p">(</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr1</span> <span class="o">+</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr2</span> <span class="o">+</span> <span class="n">lastExpr</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;operator must be unary (1), binary (2), or ternary (3)&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">rightLeftAssoc</span> <span class="o">==</span> <span class="n">opAssoc</span><span class="o">.</span><span class="n">RIGHT</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># try to avoid LR with this extra test</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">opExpr</span><span class="p">,</span> <span class="n">Optional</span><span class="p">):</span>
                    <span class="n">opExpr</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">(</span><span class="n">opExpr</span><span class="p">)</span>
                <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">FollowedBy</span><span class="p">(</span><span class="n">opExpr</span><span class="o">.</span><span class="n">expr</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span> <span class="n">opExpr</span> <span class="o">+</span> <span class="n">thisExpr</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">opExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">FollowedBy</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span> <span class="n">opExpr</span> <span class="o">+</span> <span class="n">thisExpr</span> <span class="p">)</span> <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">FollowedBy</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">OneOrMore</span><span class="p">(</span> <span class="n">thisExpr</span> <span class="p">)</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">arity</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">matchExpr</span> <span class="o">=</span> <span class="n">FollowedBy</span><span class="p">(</span><span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr1</span> <span class="o">+</span> <span class="n">thisExpr</span> <span class="o">+</span> <span class="n">opExpr2</span> <span class="o">+</span> <span class="n">thisExpr</span><span class="p">)</span> <span class="o">+</span> \
                            <span class="n">Group</span><span class="p">(</span> <span class="n">lastExpr</span> <span class="o">+</span> <span class="n">opExpr1</span> <span class="o">+</span> <span class="n">thisExpr</span> <span class="o">+</span> <span class="n">opExpr2</span> <span class="o">+</span> <span class="n">thisExpr</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;operator must be unary (1), binary (2), or ternary (3)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;operator must indicate right or left associativity&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pa</span><span class="p">:</span>
            <span class="n">matchExpr</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span> <span class="n">pa</span> <span class="p">)</span>
        <span class="n">thisExpr</span> <span class="o">&lt;&lt;=</span> <span class="p">(</span> <span class="n">matchExpr</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="n">termName</span><span class="p">)</span> <span class="o">|</span> <span class="n">lastExpr</span> <span class="p">)</span>
        <span class="n">lastExpr</span> <span class="o">=</span> <span class="n">thisExpr</span>
    <span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="n">lastExpr</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="n">operatorPrecedence</span> <span class="o">=</span> <span class="n">infixNotation</span>
<span class="sd">&quot;&quot;&quot;(Deprecated) Former name of C{L{infixNotation}}, will be dropped in a future release.&quot;&quot;&quot;</span>

<span class="n">dblQuotedString</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;&quot;(?:[^&quot;\n\r</span><span class="se">\\</span><span class="s1">]|(?:&quot;&quot;)|(?:</span><span class="se">\\</span><span class="s1">(?:[^x]|x[0-9a-fA-F]+)))*&#39;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;&quot;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;string enclosed in double quotes&quot;</span><span class="p">)</span>
<span class="n">sglQuotedString</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;&#39;(?:[^&#39;\n\r</span><span class="se">\\</span><span class="s2">]|(?:&#39;&#39;)|(?:</span><span class="se">\\</span><span class="s2">(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;string enclosed in single quotes&quot;</span><span class="p">)</span>
<span class="n">quotedString</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;&quot;(?:[^&quot;\n\r</span><span class="se">\\</span><span class="s1">]|(?:&quot;&quot;)|(?:</span><span class="se">\\</span><span class="s1">(?:[^x]|x[0-9a-fA-F]+)))*&#39;</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;&quot;&#39;</span><span class="o">|</span>
                       <span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;&#39;(?:[^&#39;\n\r</span><span class="se">\\</span><span class="s2">]|(?:&#39;&#39;)|(?:</span><span class="se">\\</span><span class="s2">(?:[^x]|x[0-9a-fA-F]+)))*&quot;</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&#39;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;quotedString using single or double quotes&quot;</span><span class="p">)</span>
<span class="n">unicodeString</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">_L</span><span class="p">(</span><span class="s1">&#39;u&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">quotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;unicode string literal&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">nestedExpr</span><span class="p">(</span><span class="n">opener</span><span class="o">=</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="n">closer</span><span class="o">=</span><span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ignoreExpr</span><span class="o">=</span><span class="n">quotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">()):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for defining nested lists enclosed in opening and closing</span>
<span class="sd">       delimiters (&quot;(&quot; and &quot;)&quot; are the default).</span>

<span class="sd">       Parameters:</span>
<span class="sd">        - opener - opening character for a nested list (default=&quot;(&quot;); can also be a pyparsing expression</span>
<span class="sd">        - closer - closing character for a nested list (default=&quot;)&quot;); can also be a pyparsing expression</span>
<span class="sd">        - content - expression for items within the nested lists (default=None)</span>
<span class="sd">        - ignoreExpr - expression for ignoring opening and closing delimiters (default=quotedString)</span>

<span class="sd">       If an expression is not provided for the content argument, the nested</span>
<span class="sd">       expression will capture all whitespace-delimited content between delimiters</span>
<span class="sd">       as a list of separate values.</span>

<span class="sd">       Use the C{ignoreExpr} argument to define expressions that may contain</span>
<span class="sd">       opening or closing characters that should not be treated as opening</span>
<span class="sd">       or closing characters for nesting, such as quotedString or a comment</span>
<span class="sd">       expression.  Specify multiple expressions using an C{L{Or}} or C{L{MatchFirst}}.</span>
<span class="sd">       The default is L{quotedString}, but if no expressions are to be ignored,</span>
<span class="sd">       then pass C{None} for this argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">opener</span> <span class="o">==</span> <span class="n">closer</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;opening and closing strings cannot be the same&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">content</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">opener</span><span class="p">,</span><span class="n">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">closer</span><span class="p">,</span><span class="n">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">closer</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ignoreExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="p">(</span><span class="n">Combine</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="o">~</span><span class="n">ignoreExpr</span> <span class="o">+</span>
                                    <span class="n">CharsNotIn</span><span class="p">(</span><span class="n">opener</span><span class="o">+</span><span class="n">closer</span><span class="o">+</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                                <span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="p">(</span><span class="n">empty</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span><span class="o">+</span><span class="n">CharsNotIn</span><span class="p">(</span><span class="n">opener</span><span class="o">+</span><span class="n">closer</span><span class="o">+</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span>
                                <span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ignoreExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="p">(</span><span class="n">Combine</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="o">~</span><span class="n">ignoreExpr</span> <span class="o">+</span> 
                                    <span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span> <span class="o">+</span> <span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="n">closer</span><span class="p">)</span> <span class="o">+</span>
                                    <span class="n">CharsNotIn</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                                <span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">content</span> <span class="o">=</span> <span class="p">(</span><span class="n">Combine</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span> <span class="o">+</span> <span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="n">closer</span><span class="p">)</span> <span class="o">+</span>
                                    <span class="n">CharsNotIn</span><span class="p">(</span><span class="n">ParserElement</span><span class="o">.</span><span class="n">DEFAULT_WHITE_CHARS</span><span class="p">,</span><span class="n">exact</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                                <span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;opening and closing arguments must be strings if no content expression is given&quot;</span><span class="p">)</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">Forward</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">ignoreExpr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="n">Group</span><span class="p">(</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span> <span class="n">ignoreExpr</span> <span class="o">|</span> <span class="n">ret</span> <span class="o">|</span> <span class="n">content</span> <span class="p">)</span> <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">closer</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">&lt;&lt;=</span> <span class="n">Group</span><span class="p">(</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">opener</span><span class="p">)</span> <span class="o">+</span> <span class="n">ZeroOrMore</span><span class="p">(</span> <span class="n">ret</span> <span class="o">|</span> <span class="n">content</span> <span class="p">)</span>  <span class="o">+</span> <span class="n">Suppress</span><span class="p">(</span><span class="n">closer</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;nested </span><span class="si">%s%s</span><span class="s1"> expression&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">opener</span><span class="p">,</span><span class="n">closer</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">indentedBlock</span><span class="p">(</span><span class="n">blockStatementExpr</span><span class="p">,</span> <span class="n">indentStack</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper method for defining space-delimited indentation blocks, such as</span>
<span class="sd">       those used to define block statements in Python source code.</span>

<span class="sd">       Parameters:</span>
<span class="sd">        - blockStatementExpr - expression defining syntax of statement that</span>
<span class="sd">            is repeated within the indented block</span>
<span class="sd">        - indentStack - list created by caller to manage indentation stack</span>
<span class="sd">            (multiple statementWithIndentedBlock expressions within a single grammar</span>
<span class="sd">            should share a common indentStack)</span>
<span class="sd">        - indent - boolean indicating whether block must be indented beyond the</span>
<span class="sd">            the current level; set to False for block of left-most statements</span>
<span class="sd">            (default=True)</span>

<span class="sd">       A valid block must contain at least one C{blockStatement}.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">checkPeerIndent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="k">return</span>
        <span class="n">curCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curCol</span> <span class="o">!=</span> <span class="n">indentStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">curCol</span> <span class="o">&gt;</span> <span class="n">indentStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">ParseFatalException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="s2">&quot;illegal nesting&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="s2">&quot;not a peer entry&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">checkSubIndent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="n">curCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curCol</span> <span class="o">&gt;</span> <span class="n">indentStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">indentStack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">curCol</span> <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="s2">&quot;not a subentry&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">checkUnindent</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">):</span> <span class="k">return</span>
        <span class="n">curCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">(</span><span class="n">l</span><span class="p">,</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">indentStack</span> <span class="ow">and</span> <span class="n">curCol</span> <span class="o">&lt;</span> <span class="n">indentStack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">curCol</span> <span class="o">&lt;=</span> <span class="n">indentStack</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]):</span>
            <span class="k">raise</span> <span class="n">ParseException</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="s2">&quot;not an unindent&quot;</span><span class="p">)</span>
        <span class="n">indentStack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">NL</span> <span class="o">=</span> <span class="n">OneOrMore</span><span class="p">(</span><span class="n">LineEnd</span><span class="p">()</span><span class="o">.</span><span class="n">setWhitespaceChars</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> &quot;</span><span class="p">)</span><span class="o">.</span><span class="n">suppress</span><span class="p">())</span>
    <span class="n">INDENT</span> <span class="o">=</span> <span class="p">(</span><span class="n">Empty</span><span class="p">()</span> <span class="o">+</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">checkSubIndent</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;INDENT&#39;</span><span class="p">)</span>
    <span class="n">PEER</span>   <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">checkPeerIndent</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="n">UNDENT</span> <span class="o">=</span> <span class="n">Empty</span><span class="p">()</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">checkUnindent</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;UNINDENT&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">indent</span><span class="p">:</span>
        <span class="n">smExpr</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span> <span class="n">Optional</span><span class="p">(</span><span class="n">NL</span><span class="p">)</span> <span class="o">+</span>
            <span class="c1">#~ FollowedBy(blockStatementExpr) +</span>
            <span class="n">INDENT</span> <span class="o">+</span> <span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span> <span class="n">PEER</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">blockStatementExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">NL</span><span class="p">)</span> <span class="p">))</span> <span class="o">+</span> <span class="n">UNDENT</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">smExpr</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span> <span class="n">Optional</span><span class="p">(</span><span class="n">NL</span><span class="p">)</span> <span class="o">+</span>
            <span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span> <span class="n">PEER</span> <span class="o">+</span> <span class="n">Group</span><span class="p">(</span><span class="n">blockStatementExpr</span><span class="p">)</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">NL</span><span class="p">)</span> <span class="p">))</span> <span class="p">)</span>
    <span class="n">blockStatementExpr</span><span class="o">.</span><span class="n">ignore</span><span class="p">(</span><span class="n">_bslash</span> <span class="o">+</span> <span class="n">LineEnd</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">smExpr</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;indented block&#39;</span><span class="p">)</span>

<span class="n">alphas8bit</span> <span class="o">=</span> <span class="n">srange</span><span class="p">(</span><span class="s2">r&quot;[\0xc0-\0xd6\0xd8-\0xf6\0xf8-\0xff]&quot;</span><span class="p">)</span>
<span class="n">punc8bit</span> <span class="o">=</span> <span class="n">srange</span><span class="p">(</span><span class="s2">r&quot;[\0xa1-\0xbf\0xd7\0xf7]&quot;</span><span class="p">)</span>

<span class="n">anyOpenTag</span><span class="p">,</span><span class="n">anyCloseTag</span> <span class="o">=</span> <span class="n">makeHTMLTags</span><span class="p">(</span><span class="n">Word</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span><span class="n">alphanums</span><span class="o">+</span><span class="s2">&quot;_:&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s1">&#39;any tag&#39;</span><span class="p">))</span>
<span class="n">_htmlEntityMap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="s2">&quot;gt lt amp nbsp quot apos&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span><span class="s1">&#39;&gt;&lt;&amp; &quot;</span><span class="se">\&#39;</span><span class="s1">&#39;</span><span class="p">))</span>
<span class="n">commonHTMLEntity</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">&#39;&amp;(?P&lt;entity&gt;&#39;</span> <span class="o">+</span> <span class="s1">&#39;|&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_htmlEntityMap</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">+</span><span class="s2">&quot;);&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;common HTML entity&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">replaceHTMLEntity</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Helper parser action to replace common HTML entities with their special characters&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_htmlEntityMap</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">entity</span><span class="p">)</span>

<span class="c1"># it&#39;s easy to get these comment structures wrong - they&#39;re very common, so may as well make them available</span>
<span class="n">cStyleComment</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;/\*(?:[^*]|\*(?!/))*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;*/&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;C style comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of the form C{/* ... */}&quot;</span>

<span class="n">htmlComment</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;&lt;!--[\s\S]*?--&gt;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;HTML comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of the form C{&lt;!-- ... --&gt;}&quot;</span>

<span class="n">restOfLine</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;.*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">leaveWhitespace</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;rest of line&quot;</span><span class="p">)</span>
<span class="n">dblSlashComment</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;//(?:</span><span class="se">\\</span><span class="s2">\n|[^\n])*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;// comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of the form C{// ... (to end of line)}&quot;</span>

<span class="n">cppStyleComment</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;/\*(?:[^*]|\*(?!/))*&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;*/&#39;</span><span class="o">|</span> <span class="n">dblSlashComment</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;C++ style comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of either form C{L</span><span class="si">{cStyleComment}</span><span class="s2">} or C{L</span><span class="si">{dblSlashComment}</span><span class="s2">}&quot;</span>

<span class="n">javaStyleComment</span> <span class="o">=</span> <span class="n">cppStyleComment</span>
<span class="s2">&quot;Same as C{L</span><span class="si">{cppStyleComment}</span><span class="s2">}&quot;</span>

<span class="n">pythonStyleComment</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s2">r&quot;#.*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;Python style comment&quot;</span><span class="p">)</span>
<span class="s2">&quot;Comment of the form C{# ... (to end of line)}&quot;</span>

<span class="n">_commasepitem</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">(</span><span class="n">OneOrMore</span><span class="p">(</span><span class="n">Word</span><span class="p">(</span><span class="n">printables</span><span class="p">,</span> <span class="n">excludeChars</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span> <span class="o">+</span>
                                  <span class="n">Optional</span><span class="p">(</span> <span class="n">Word</span><span class="p">(</span><span class="s2">&quot; </span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span> <span class="o">+</span>
                                            <span class="o">~</span><span class="n">Literal</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="o">~</span><span class="n">LineEnd</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;commaItem&quot;</span><span class="p">)</span>
<span class="n">commaSeparatedList</span> <span class="o">=</span> <span class="n">delimitedList</span><span class="p">(</span> <span class="n">Optional</span><span class="p">(</span> <span class="n">quotedString</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">|</span> <span class="n">_commasepitem</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;commaSeparatedList&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;Predefined expression of 1 or more printable words or quoted strings, separated by commas.&quot;&quot;&quot;</span>

<span class="c1"># some other useful expressions - using lower-case class name since we are really using this as a namespace</span>
<span class="k">class</span> <span class="nc">pyparsing_common</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Here are some common low-level expressions that may be useful in jump-starting parser development:</span>
<span class="sd">     - numeric forms (L{integers&lt;integer&gt;}, L{reals&lt;real&gt;}, L{scientific notation&lt;sciReal&gt;})</span>
<span class="sd">     - common L{programming identifiers&lt;identifier&gt;}</span>
<span class="sd">     - network addresses (L{MAC&lt;mac_address&gt;}, L{IPv4&lt;ipv4_address&gt;}, L{IPv6&lt;ipv6_address&gt;})</span>
<span class="sd">     - ISO8601 L{dates&lt;iso8601_date&gt;} and L{datetime&lt;iso8601_datetime&gt;}</span>
<span class="sd">     - L{UUID&lt;uuid&gt;}</span>
<span class="sd">    Parse actions:</span>
<span class="sd">     - C{L{convertToInteger}}</span>
<span class="sd">     - C{L{convertToFloat}}</span>
<span class="sd">     - C{L{convertToDate}}</span>
<span class="sd">     - C{L{convertToDatetime}}</span>
<span class="sd">     - C{L{stripHTMLTags}}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">convertToInteger</span> <span class="o">=</span> <span class="n">tokenMap</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse action for converting parsed integers to Python int</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">convertToFloat</span> <span class="o">=</span> <span class="n">tokenMap</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse action for converting parsed numbers to Python float</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">integer</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;integer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToInteger</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;expression that parses an unsigned integer, returns an int&quot;&quot;&quot;</span>

    <span class="n">hex_integer</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">hexnums</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;hex integer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">tokenMap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="mi">16</span><span class="p">))</span>
    <span class="sd">&quot;&quot;&quot;expression that parses a hexadecimal integer, returns an int&quot;&quot;&quot;</span>

    <span class="n">signedInteger</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;[+-]?\d+&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;signed integer&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToInteger</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;expression that parses an integer with optional leading sign, returns an int&quot;&quot;&quot;</span>

    <span class="n">fraction</span> <span class="o">=</span> <span class="p">(</span><span class="n">signedInteger</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;/&#39;</span> <span class="o">+</span> <span class="n">signedInteger</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;fraction&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;fractional expression of an integer divided by an integer, returns a float&quot;&quot;&quot;</span>
    <span class="n">fraction</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">t</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">mixed_integer</span> <span class="o">=</span> <span class="p">(</span><span class="n">fraction</span> <span class="o">|</span> <span class="n">integer</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">Optional</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span> <span class="o">+</span> <span class="n">fraction</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;fraction or mixed integer-fraction&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;mixed integer of the form &#39;integer - fraction&#39;, with optional leading integer, returns float&quot;&quot;&quot;</span>
    <span class="n">mixed_integer</span><span class="o">.</span><span class="n">addParseAction</span><span class="p">(</span><span class="nb">sum</span><span class="p">)</span>

    <span class="n">real</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;[+-]?\d+\.\d*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;real number&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;expression that parses a floating point number and returns a float&quot;&quot;&quot;</span>

    <span class="n">sciReal</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;[+-]?\d+([eE][+-]?\d+|\.\d*([eE][+-]?\d+)?)&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;real number with scientific notation&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;expression that parses a floating point number with optional scientific notation and returns a float&quot;&quot;&quot;</span>

    <span class="c1"># streamlining this expression makes the docs nicer-looking</span>
    <span class="n">numeric</span> <span class="o">=</span> <span class="p">(</span><span class="n">sciReal</span> <span class="o">|</span> <span class="n">real</span> <span class="o">|</span> <span class="n">signedInteger</span><span class="p">)</span><span class="o">.</span><span class="n">streamline</span><span class="p">()</span>
    <span class="sd">&quot;&quot;&quot;any numeric expression, returns the corresponding Python type&quot;&quot;&quot;</span>

    <span class="n">number</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;[+-]?\d+\.?\d*([eE][+-]?\d+)?&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;number&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">convertToFloat</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;any int or real number, returned as float&quot;&quot;&quot;</span>
    
    <span class="n">identifier</span> <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">alphas</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">alphanums</span><span class="o">+</span><span class="s1">&#39;_&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;identifier&quot;</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;typical code identifier (leading alpha or &#39;_&#39;, followed by 0 or more alphas, nums, or &#39;_&#39;)&quot;&quot;&quot;</span>
    
    <span class="n">ipv4_address</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2}))</span><span class="si">{3}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;IPv4 address&quot;</span><span class="p">)</span>
    <span class="s2">&quot;IPv4 address (C{0.0.0.0 - 255.255.255.255})&quot;</span>

    <span class="n">_ipv6_part</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;[0-9a-fA-F]{1,4}&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;hex_integer&quot;</span><span class="p">)</span>
    <span class="n">_full_ipv6_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">_ipv6_part</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">_ipv6_part</span><span class="p">)</span><span class="o">*</span><span class="mi">7</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;full IPv6 address&quot;</span><span class="p">)</span>
    <span class="n">_short_ipv6_address</span> <span class="o">=</span> <span class="p">(</span><span class="n">Optional</span><span class="p">(</span><span class="n">_ipv6_part</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">_ipv6_part</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;::&quot;</span> <span class="o">+</span> <span class="n">Optional</span><span class="p">(</span><span class="n">_ipv6_part</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;:&#39;</span> <span class="o">+</span> <span class="n">_ipv6_part</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">6</span><span class="p">)))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;short IPv6 address&quot;</span><span class="p">)</span>
    <span class="n">_short_ipv6_address</span><span class="o">.</span><span class="n">addCondition</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">tt</span> <span class="ow">in</span> <span class="n">t</span> <span class="k">if</span> <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">_ipv6_part</span><span class="o">.</span><span class="n">matches</span><span class="p">(</span><span class="n">tt</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">_mixed_ipv6_address</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;::ffff:&quot;</span> <span class="o">+</span> <span class="n">ipv4_address</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;mixed IPv6 address&quot;</span><span class="p">)</span>
    <span class="n">ipv6_address</span> <span class="o">=</span> <span class="n">Combine</span><span class="p">((</span><span class="n">_full_ipv6_address</span> <span class="o">|</span> <span class="n">_mixed_ipv6_address</span> <span class="o">|</span> <span class="n">_short_ipv6_address</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;IPv6 address&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;IPv6 address&quot;</span><span class="p">)</span>
    <span class="s2">&quot;IPv6 address (long, short, or mixed form)&quot;</span>
    
    <span class="n">mac_address</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;[0-9a-fA-F]</span><span class="si">{2}</span><span class="s1">([:.-])[0-9a-fA-F]</span><span class="si">{2}</span><span class="s1">(?:\1[0-9a-fA-F]</span><span class="si">{2}</span><span class="s1">)</span><span class="si">{4}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;MAC address&quot;</span><span class="p">)</span>
    <span class="s2">&quot;MAC address xx:xx:xx:xx:xx (may also have &#39;-&#39; or &#39;.&#39; delimiters)&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convertToDate</span><span class="p">(</span><span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper to create a parse action for converting parsed date string to Python datetime.date</span>

<span class="sd">        Params -</span>
<span class="sd">         - fmt - format to be passed to datetime.strptime (default=C{&quot;%Y-%m-%d&quot;})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fmt</span><span class="p">)</span><span class="o">.</span><span class="n">date</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">convertToDatetime</span><span class="p">(</span><span class="n">fmt</span><span class="o">=</span><span class="s2">&quot;%Y-%m-</span><span class="si">%d</span><span class="s2">T%H:%M:%S.</span><span class="si">%f</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper to create a parse action for converting parsed datetime string to Python datetime.datetime</span>

<span class="sd">        Params -</span>
<span class="sd">         - fmt - format to be passed to datetime.strptime (default=C{&quot;%Y-%m-%dT%H:%M:%S.%f&quot;})</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">s</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">t</span><span class="p">:</span> <span class="n">datetime</span><span class="o">.</span><span class="n">strptime</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fmt</span><span class="p">)</span>

    <span class="n">iso8601_date</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;(?P&lt;year&gt;\d</span><span class="si">{4}</span><span class="s1">)(?:-(?P&lt;month&gt;\d\d)(?:-(?P&lt;day&gt;\d\d))?)?&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;ISO8601 date&quot;</span><span class="p">)</span>
    <span class="s2">&quot;ISO8601 date (C{yyyy-mm-dd})&quot;</span>

    <span class="n">iso8601_datetime</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;(?P&lt;year&gt;\d</span><span class="si">{4}</span><span class="s1">)-(?P&lt;month&gt;\d\d)-(?P&lt;day&gt;\d\d)[T ](?P&lt;hour&gt;\d\d):(?P&lt;minute&gt;\d\d)(:(?P&lt;second&gt;\d\d(\.\d*)?)?)?(?P&lt;tz&gt;Z|[+-]\d\d:?\d\d)?&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;ISO8601 datetime&quot;</span><span class="p">)</span>
    <span class="s2">&quot;ISO8601 datetime (C{yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)}) - trailing seconds, milliseconds, and timezone optional; accepts separating C{&#39;T&#39;} or C{&#39; &#39;}&quot;</span>

    <span class="n">uuid</span> <span class="o">=</span> <span class="n">Regex</span><span class="p">(</span><span class="s1">r&#39;[0-9a-fA-F]</span><span class="si">{8}</span><span class="s1">(-[0-9a-fA-F]</span><span class="si">{4}</span><span class="s1">)</span><span class="si">{3}</span><span class="s1">-[0-9a-fA-F]</span><span class="si">{12}</span><span class="s1">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;UUID&quot;</span><span class="p">)</span>
    <span class="s2">&quot;UUID (C{xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx})&quot;</span>

    <span class="n">_html_stripper</span> <span class="o">=</span> <span class="n">anyOpenTag</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span> <span class="o">|</span> <span class="n">anyCloseTag</span><span class="o">.</span><span class="n">suppress</span><span class="p">()</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stripHTMLTags</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">tokens</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Parse action to remove HTML tags from web page HTML source&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">_html_stripper</span><span class="o">.</span><span class="n">transformString</span><span class="p">(</span><span class="n">tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">selectToken</span>    <span class="o">=</span> <span class="n">CaselessLiteral</span><span class="p">(</span><span class="s2">&quot;select&quot;</span><span class="p">)</span>
    <span class="n">fromToken</span>      <span class="o">=</span> <span class="n">CaselessLiteral</span><span class="p">(</span><span class="s2">&quot;from&quot;</span><span class="p">)</span>

    <span class="n">ident</span>          <span class="o">=</span> <span class="n">Word</span><span class="p">(</span><span class="n">alphas</span><span class="p">,</span> <span class="n">alphanums</span> <span class="o">+</span> <span class="s2">&quot;_$&quot;</span><span class="p">)</span>

    <span class="n">columnName</span>     <span class="o">=</span> <span class="n">delimitedList</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">upcaseTokens</span><span class="p">)</span>
    <span class="n">columnNameList</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">delimitedList</span><span class="p">(</span><span class="n">columnName</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;columns&quot;</span><span class="p">)</span>
    <span class="n">columnSpec</span>     <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;*&#39;</span> <span class="o">|</span> <span class="n">columnNameList</span><span class="p">)</span>

    <span class="n">tableName</span>      <span class="o">=</span> <span class="n">delimitedList</span><span class="p">(</span><span class="n">ident</span><span class="p">,</span> <span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">upcaseTokens</span><span class="p">)</span>
    <span class="n">tableNameList</span>  <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">delimitedList</span><span class="p">(</span><span class="n">tableName</span><span class="p">))</span><span class="o">.</span><span class="n">setName</span><span class="p">(</span><span class="s2">&quot;tables&quot;</span><span class="p">)</span>
    
    <span class="n">simpleSQL</span>      <span class="o">=</span> <span class="n">selectToken</span><span class="p">(</span><span class="s2">&quot;command&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">columnSpec</span><span class="p">(</span><span class="s2">&quot;columns&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">fromToken</span> <span class="o">+</span> <span class="n">tableNameList</span><span class="p">(</span><span class="s2">&quot;tables&quot;</span><span class="p">)</span>

    <span class="c1"># demo runTests method, including embedded comments in test string</span>
    <span class="n">simpleSQL</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        # &#39;*&#39; as column list and dotted table name</span>
<span class="s2">        select * from SYS.XYZZY</span>

<span class="s2">        # caseless match on &quot;SELECT&quot;, and casts back to &quot;select&quot;</span>
<span class="s2">        SELECT * from XYZZY, ABC</span>

<span class="s2">        # list of column names, and mixed case SELECT keyword</span>
<span class="s2">        Select AA,BB,CC from Sys.dual</span>

<span class="s2">        # multiple tables</span>
<span class="s2">        Select A, B, C from Sys.dual, Table2</span>

<span class="s2">        # invalid SELECT keyword - should fail</span>
<span class="s2">        Xelect A, B, C from Sys.dual</span>

<span class="s2">        # incomplete command - should fail</span>
<span class="s2">        Select</span>

<span class="s2">        # invalid column name - should fail</span>
<span class="s2">        Select ^^^ frox Sys.dual</span>

<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">numeric</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        100</span>
<span class="s2">        -100</span>
<span class="s2">        +100</span>
<span class="s2">        3.14159</span>
<span class="s2">        6.02e23</span>
<span class="s2">        1e-12</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="c1"># any int or real number, returned as float</span>
    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">number</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        100</span>
<span class="s2">        -100</span>
<span class="s2">        +100</span>
<span class="s2">        3.14159</span>
<span class="s2">        6.02e23</span>
<span class="s2">        1e-12</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">hex_integer</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        100</span>
<span class="s2">        FF</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="kn">import</span> <span class="nn">uuid</span>
    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">uuid</span><span class="o">.</span><span class="n">setParseAction</span><span class="p">(</span><span class="n">tokenMap</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">UUID</span><span class="p">))</span>
    <span class="n">pyparsing_common</span><span class="o">.</span><span class="n">uuid</span><span class="o">.</span><span class="n">runTests</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">        12345678-1234-5678-1234-567812345678</span>
<span class="s2">        &quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>